
--- Manual ---
('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']])
parse_name: class cv.Vec8i with ['cv'] -> fullname:cv::Vec8i namespace:cv classpath: classname: name:Vec8i
register class cv::Vec8i (('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']]))

--- Manual ---
('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6d with ['cv'] -> fullname:cv::Vec6d namespace:cv classpath: classname: name:Vec6d
register class cv::Vec6d (('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6f with ['cv'] -> fullname:cv::Vec6f namespace:cv classpath: classname: name:Vec6f
register class cv::Vec6f (('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6i with ['cv'] -> fullname:cv::Vec6i namespace:cv classpath: classname: name:Vec6i
register class cv::Vec6i (('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4d with ['cv'] -> fullname:cv::Vec4d namespace:cv classpath: classname: name:Vec4d
register class cv::Vec4d (('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4f with ['cv'] -> fullname:cv::Vec4f namespace:cv classpath: classname: name:Vec4f
register class cv::Vec4f (('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4i with ['cv'] -> fullname:cv::Vec4i namespace:cv classpath: classname: name:Vec4i
register class cv::Vec4i (('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4w with ['cv'] -> fullname:cv::Vec4w namespace:cv classpath: classname: name:Vec4w
register class cv::Vec4w (('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4s with ['cv'] -> fullname:cv::Vec4s namespace:cv classpath: classname: name:Vec4s
register class cv::Vec4s (('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4b with ['cv'] -> fullname:cv::Vec4b namespace:cv classpath: classname: name:Vec4b
register class cv::Vec4b (('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3d with ['cv'] -> fullname:cv::Vec3d namespace:cv classpath: classname: name:Vec3d
register class cv::Vec3d (('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3f with ['cv'] -> fullname:cv::Vec3f namespace:cv classpath: classname: name:Vec3f
register class cv::Vec3f (('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3i with ['cv'] -> fullname:cv::Vec3i namespace:cv classpath: classname: name:Vec3i
register class cv::Vec3i (('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3w with ['cv'] -> fullname:cv::Vec3w namespace:cv classpath: classname: name:Vec3w
register class cv::Vec3w (('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3s with ['cv'] -> fullname:cv::Vec3s namespace:cv classpath: classname: name:Vec3s
register class cv::Vec3s (('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3b with ['cv'] -> fullname:cv::Vec3b namespace:cv classpath: classname: name:Vec3b
register class cv::Vec3b (('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2d with ['cv'] -> fullname:cv::Vec2d namespace:cv classpath: classname: name:Vec2d
register class cv::Vec2d (('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2d',
    '',
    ['/Simple'],
    [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']])
parse_name: class cv.Size2d with ['cv'] -> fullname:cv::Size2d namespace:cv classpath: classname: name:Size2d
register class cv::Size2d (('class cv.Size2d', '', ['/Simple'], [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2d',
    '',
    ['/Simple'],
    [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']])
parse_name: class cv.Point2d with ['cv'] -> fullname:cv::Point2d namespace:cv classpath: classname: name:Point2d
register class cv::Point2d (('class cv.Point2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2d',
    '',
    ['/Simple'],
    [   ['double', 'x', '', '/RW'],
        ['double', 'y', '', '/RW'],
        ['double', 'width', '', '/RW'],
        ['double', 'height', '', '/RW']])
parse_name: class cv.Rect2d with ['cv'] -> fullname:cv::Rect2d namespace:cv classpath: classname: name:Rect2d
register class cv::Rect2d (('class cv.Rect2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW'], ['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2f with ['cv'] -> fullname:cv::Vec2f namespace:cv classpath: classname: name:Vec2f
register class cv::Vec2f (('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2f',
    '',
    ['/Simple'],
    [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']])
parse_name: class cv.Size2f with ['cv'] -> fullname:cv::Size2f namespace:cv classpath: classname: name:Size2f
register class cv::Size2f (('class cv.Size2f', '', ['/Simple'], [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2f',
    '',
    ['/Simple'],
    [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']])
parse_name: class cv.Point2f with ['cv'] -> fullname:cv::Point2f namespace:cv classpath: classname: name:Point2f
register class cv::Point2f (('class cv.Point2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2f',
    '',
    ['/Simple'],
    [   ['float', 'x', '', '/RW'],
        ['float', 'y', '', '/RW'],
        ['float', 'width', '', '/RW'],
        ['float', 'height', '', '/RW']])
parse_name: class cv.Rect2f with ['cv'] -> fullname:cv::Rect2f namespace:cv classpath: classname: name:Rect2f
register class cv::Rect2f (('class cv.Rect2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW'], ['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size2l',
    '',
    ['/Simple'],
    [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']])
parse_name: class cv.Size2l with ['cv'] -> fullname:cv::Size2l namespace:cv classpath: classname: name:Size2l
register class cv::Size2l (('class cv.Size2l', '', ['/Simple'], [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2l',
    '',
    ['/Simple'],
    [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']])
parse_name: class cv.Point2l with ['cv'] -> fullname:cv::Point2l namespace:cv classpath: classname: name:Point2l
register class cv::Point2l (('class cv.Point2l', '', ['/Simple'], [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']]))

--- Manual ---
('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2i with ['cv'] -> fullname:cv::Vec2i namespace:cv classpath: classname: name:Vec2i
register class cv::Vec2i (('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2i',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size2i with ['cv'] -> fullname:cv::Size2i namespace:cv classpath: classname: name:Size2i
register class cv::Size2i (('class cv.Size2i', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2i',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point2i with ['cv'] -> fullname:cv::Point2i namespace:cv classpath: classname: name:Point2i
register class cv::Point2i (('class cv.Point2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2i',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect2i with ['cv'] -> fullname:cv::Rect2i namespace:cv classpath: classname: name:Rect2i
register class cv::Rect2i (('class cv.Rect2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size with ['cv'] -> fullname:cv::Size namespace:cv classpath: classname: name:Size
register class cv::Size (('class cv.Size', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point with ['cv'] -> fullname:cv::Point namespace:cv classpath: classname: name:Point
register class cv::Point (('class cv.Point', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect with ['cv'] -> fullname:cv::Rect namespace:cv classpath: classname: name:Rect
register class cv::Rect (('class cv.Rect', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2w with ['cv'] -> fullname:cv::Vec2w namespace:cv classpath: classname: name:Vec2w
register class cv::Vec2w (('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2s with ['cv'] -> fullname:cv::Vec2s namespace:cv classpath: classname: name:Vec2s
register class cv::Vec2s (('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2b with ['cv'] -> fullname:cv::Vec2b namespace:cv classpath: classname: name:Vec2b
register class cv::Vec2b (('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Scalar with ['cv'] -> fullname:cv::Scalar namespace:cv classpath: classname: name:Scalar
register class cv::Scalar (('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv._InputArray', '', ['/Ghost'], [])
parse_name: class cv._InputArray with ['cv'] -> fullname:cv::_InputArray namespace:cv classpath: classname: name:_InputArray
register class cv::_InputArray (('class cv._InputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputArray', 'const _InputArray&', [], [])
parse_name: typedef cv.InputArray with ['cv'] -> fullname:cv::InputArray namespace:cv classpath: classname: name:InputArray
Registering an unknown type: InputArray

--- Manual ---
('class cv._OutputArray', '', ['/Ghost'], [])
parse_name: class cv._OutputArray with ['cv'] -> fullname:cv::_OutputArray namespace:cv classpath: classname: name:_OutputArray
register class cv::_OutputArray (('class cv._OutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.OutputArray', '_OutputArray&', [], [])
parse_name: typedef cv.OutputArray with ['cv'] -> fullname:cv::OutputArray namespace:cv classpath: classname: name:OutputArray
Registering an unknown type: OutputArray

--- Manual ---
('class cv._InputOutputArray', '', ['/Ghost'], [])
parse_name: class cv._InputOutputArray with ['cv'] -> fullname:cv::_InputOutputArray namespace:cv classpath: classname: name:_InputOutputArray
register class cv::_InputOutputArray (('class cv._InputOutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputOutputArray', '_InputOutputArray&', [], [])
parse_name: typedef cv.InputOutputArray with ['cv'] -> fullname:cv::InputOutputArray namespace:cv classpath: classname: name:InputOutputArray
Registering an unknown type: InputOutputArray

--- Manual ---
('typedef cv.InputArrayOfArrays', 'InputArray', [], [])
parse_name: typedef cv.InputArrayOfArrays with ['cv'] -> fullname:cv::InputArrayOfArrays namespace:cv classpath: classname: name:InputArrayOfArrays
Registering an unknown type: InputArrayOfArrays

--- Manual ---
('typedef cv.OutputArrayOfArrays', 'OutputArray', [], [])
parse_name: typedef cv.OutputArrayOfArrays with ['cv'] -> fullname:cv::OutputArrayOfArrays namespace:cv classpath: classname: name:OutputArrayOfArrays
Registering an unknown type: OutputArrayOfArrays

--- Manual ---
('typedef cv.InputOutputArrayOfArrays', 'InputOutputArray', [], [])
parse_name: typedef cv.InputOutputArrayOfArrays with ['cv'] -> fullname:cv::InputOutputArrayOfArrays namespace:cv classpath: classname: name:InputOutputArrayOfArrays
Registering an unknown type: InputOutputArrayOfArrays

--- Manual ---
('class cv.Range', '', ['/Ghost'], [])
parse_name: class cv.Range with ['cv'] -> fullname:cv::Range namespace:cv classpath: classname: name:Range
register class cv::Range (('class cv.Range', '', ['/Ghost'], []))

--- Manual ---
('class cv.MatExpr', '', ['/Ghost'], [])
parse_name: class cv.MatExpr with ['cv'] -> fullname:cv::MatExpr namespace:cv classpath: classname: name:MatExpr
register class cv::MatExpr (('class cv.MatExpr', '', ['/Ghost'], []))

--- Manual ---
('class cv.Mat', '', ['/Ghost'], [])
parse_name: class cv.Mat with ['cv'] -> fullname:cv::Mat namespace:cv classpath: classname: name:Mat
register class cv::Mat (('class cv.Mat', '', ['/Ghost'], []))

--- Manual ---
('class cv.UMat', '', ['/Ghost'], [])
parse_name: class cv.UMat with ['cv'] -> fullname:cv::UMat namespace:cv classpath: classname: name:UMat
register class cv::UMat (('class cv.UMat', '', ['/Ghost'], []))

--- Manual ---
('class cv.Algorithm', '', ['/Ghost'], [])
parse_name: class cv.Algorithm with ['cv'] -> fullname:cv::Algorithm namespace:cv classpath: classname: name:Algorithm
register class cv::Algorithm (('class cv.Algorithm', '', ['/Ghost'], []))

--- Manual ---
('class cv.DMatch', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.DMatch with ['cv'] -> fullname:cv::DMatch namespace:cv classpath: classname: name:DMatch
register class cv::DMatch (('class cv.DMatch', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.KeyPoint', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.KeyPoint with ['cv'] -> fullname:cv::KeyPoint namespace:cv classpath: classname: name:KeyPoint
register class cv::KeyPoint (('class cv.KeyPoint', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.RotatedRect', '', ['/Ghost'], [])
parse_name: class cv.RotatedRect with ['cv'] -> fullname:cv::RotatedRect namespace:cv classpath: classname: name:RotatedRect
register class cv::RotatedRect (('class cv.RotatedRect', '', ['/Ghost'], []))

--- Manual ---
('class cv.TermCriteria', '', ['/Ghost'], [])
parse_name: class cv.TermCriteria with ['cv'] -> fullname:cv::TermCriteria namespace:cv classpath: classname: name:TermCriteria
register class cv::TermCriteria (('class cv.TermCriteria', '', ['/Ghost'], []))

--- Manual ---
('class cv.utils.logging.LogTag', '', ['/Ghost'], [])
parse_name: class cv.utils.logging.LogTag with ['cv'] -> fullname:cv::utils::logging::LogTag namespace:cv classpath:utils::logging classname:logging name:LogTag
register class cv::utils::logging::LogTag (('class cv.utils.logging.LogTag', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileNode', '', ['/Ghost'], [])
parse_name: class cv.FileNode with ['cv'] -> fullname:cv::FileNode namespace:cv classpath: classname: name:FileNode
register class cv::FileNode (('class cv.FileNode', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileStorage', '', ['/Ghost'], [])
parse_name: class cv.FileStorage with ['cv'] -> fullname:cv::FileStorage namespace:cv classpath: classname: name:FileStorage
register class cv::FileStorage (('class cv.FileStorage', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.LayerParams', '', ['/Ghost'], [])
parse_name: class cv.dnn.LayerParams with ['cv'] -> fullname:cv::dnn::LayerParams namespace:cv classpath:dnn classname:dnn name:LayerParams
register class cv::dnn::LayerParams (('class cv.dnn.LayerParams', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.Layer', '', ['/Ghost'], [])
parse_name: class cv.dnn.Layer with ['cv'] -> fullname:cv::dnn::Layer namespace:cv classpath:dnn classname:dnn name:Layer
register class cv::dnn::Layer (('class cv.dnn.Layer', '', ['/Ghost'], []))

--- Manual ---
('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])
parse_name: class cv.Feature2D with ['cv'] -> fullname:cv::Feature2D namespace:cv classpath: classname: name:Feature2D
register class cv::Feature2D (('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])) impl:cv::Algorithm

--- Manual ---
('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])
parse_name: class cv.DescriptorMatcher with ['cv'] -> fullname:cv::DescriptorMatcher namespace:cv classpath: classname: name:DescriptorMatcher
register class cv::DescriptorMatcher (('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])) impl:cv::Algorithm

--- Manual ---
('typedef cv.FeatureDetector', 'Feature2D', [], [])
parse_name: typedef cv.FeatureDetector with ['cv'] -> fullname:cv::FeatureDetector namespace:cv classpath: classname: name:FeatureDetector
Registering an unknown type: FeatureDetector

--- Manual ---
('typedef cv.DescriptorExtractor', 'Feature2D', [], [])
parse_name: typedef cv.DescriptorExtractor with ['cv'] -> fullname:cv::DescriptorExtractor namespace:cv classpath: classname: name:DescriptorExtractor
Registering an unknown type: DescriptorExtractor

--- Manual ---
('enum cv.InterpolationFlags', '', ['/Ghost'], [])
parse_name: enum cv.InterpolationFlags with ['cv'] -> fullname:cv::InterpolationFlags namespace:cv classpath: classname: name:InterpolationFlags


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/calib3d.hpp ================


Namespaces: ['cv', 'cv.fisheye']
Comment: {'calib3d': '\n@defgroup calib3d Camera Calibration and 3D Reconstruction\n\nThe functions in this section use a so-called pinhole camera model. In this model, a scene view is\nformed by projecting 3D points into the image plane using a perspective transformation.\n\n\\f[s  \\; m\' = A [R|t] M\'\\f]\n\nor\n\n\\f[s  \\vecthree{u}{v}{1} = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\n\\begin{bmatrix}\nr_{11} & r_{12} & r_{13} & t_1  \\\\\nr_{21} & r_{22} & r_{23} & t_2  \\\\\nr_{31} & r_{32} & r_{33} & t_3\n\\end{bmatrix}\n\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n1\n\\end{bmatrix}\\f]\n\nwhere:\n\n-   \\f$(X, Y, Z)\\f$ are the coordinates of a 3D point in the world coordinate space\n-   \\f$(u, v)\\f$ are the coordinates of the projection point in pixels\n-   \\f$A\\f$ is a camera matrix, or a matrix of intrinsic parameters\n-   \\f$(cx, cy)\\f$ is a principal point that is usually at the image center\n-   \\f$fx, fy\\f$ are the focal lengths expressed in pixel units.\n\nThus, if an image from the camera is scaled by a factor, all of these parameters should be scaled\n(multiplied/divided, respectively) by the same factor. The matrix of intrinsic parameters does not\ndepend on the scene viewed. So, once estimated, it can be re-used as long as the focal length is\nfixed (in case of zoom lens). The joint rotation-translation matrix \\f$[R|t]\\f$ is called a matrix of\nextrinsic parameters. It is used to describe the camera motion around a static scene, or vice versa,\nrigid motion of an object in front of a still camera. That is, \\f$[R|t]\\f$ translates coordinates of a\npoint \\f$(X, Y, Z)\\f$ to a coordinate system, fixed with respect to the camera. The transformation above\nis equivalent to the following (when \\f$z \\ne 0\\f$ ):\n\n\\f[\\begin{array}{l}\n\\vecthree{x}{y}{z} = R  \\vecthree{X}{Y}{Z} + t \\\\\nx\' = x/z \\\\\ny\' = y/z \\\\\nu = f_x*x\' + c_x \\\\\nv = f_y*y\' + c_y\n\\end{array}\\f]\n\nThe following figure illustrates the pinhole camera model.\n\n![Pinhole camera model](pics/pinhole_camera_model.png)\n\nReal lenses usually have some distortion, mostly radial distortion and slight tangential distortion.\nSo, the above model is extended as:\n\n\\f[\\begin{array}{l}\n\\vecthree{x}{y}{z} = R  \\vecthree{X}{Y}{Z} + t \\\\\nx\' = x/z \\\\\ny\' = y/z \\\\\nx\'\' = x\'  \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + 2 p_1 x\' y\' + p_2(r^2 + 2 x\'^2) + s_1 r^2 + s_2 r^4 \\\\\ny\'\' = y\'  \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + p_1 (r^2 + 2 y\'^2) + 2 p_2 x\' y\' + s_3 r^2 + s_4 r^4 \\\\\n\\text{where} \\quad r^2 = x\'^2 + y\'^2  \\\\\nu = f_x*x\'\' + c_x \\\\\nv = f_y*y\'\' + c_y\n\\end{array}\\f]\n\n\\f$k_1\\f$, \\f$k_2\\f$, \\f$k_3\\f$, \\f$k_4\\f$, \\f$k_5\\f$, and \\f$k_6\\f$ are radial distortion coefficients. \\f$p_1\\f$ and \\f$p_2\\f$ are\ntangential distortion coefficients. \\f$s_1\\f$, \\f$s_2\\f$, \\f$s_3\\f$, and \\f$s_4\\f$, are the thin prism distortion\ncoefficients. Higher-order coefficients are not considered in OpenCV.\n\nThe next figures show two common types of radial distortion: barrel distortion (typically \\f$ k_1 < 0 \\f$) and pincushion distortion (typically \\f$ k_1 > 0 \\f$).\n\n![](pics/distortion_examples.png)\n![](pics/distortion_examples2.png)\n\nIn some cases the image sensor may be tilted in order to focus an oblique plane in front of the\ncamera (Scheimpfug condition). This can be useful for particle image velocimetry (PIV) or\ntriangulation with a laser fan. The tilt causes a perspective distortion of \\f$x\'\'\\f$ and\n\\f$y\'\'\\f$. This distortion can be modelled in the following way, see e.g. @cite Louhichi07.\n\n\\f[\\begin{array}{l}\ns\\vecthree{x\'\'\'}{y\'\'\'}{1} =\n\\vecthreethree{R_{33}(\\tau_x, \\tau_y)}{0}{-R_{13}(\\tau_x, \\tau_y)}\n{0}{R_{33}(\\tau_x, \\tau_y)}{-R_{23}(\\tau_x, \\tau_y)}\n{0}{0}{1} R(\\tau_x, \\tau_y) \\vecthree{x\'\'}{y\'\'}{1}\\\\\nu = f_x*x\'\'\' + c_x \\\\\nv = f_y*y\'\'\' + c_y\n\\end{array}\\f]\n\nwhere the matrix \\f$R(\\tau_x, \\tau_y)\\f$ is defined by two rotations with angular parameter \\f$\\tau_x\\f$\nand \\f$\\tau_y\\f$, respectively,\n\n\\f[\nR(\\tau_x, \\tau_y) =\n\\vecthreethree{\\cos(\\tau_y)}{0}{-\\sin(\\tau_y)}{0}{1}{0}{\\sin(\\tau_y)}{0}{\\cos(\\tau_y)}\n\\vecthreethree{1}{0}{0}{0}{\\cos(\\tau_x)}{\\sin(\\tau_x)}{0}{-\\sin(\\tau_x)}{\\cos(\\tau_x)} =\n\\vecthreethree{\\cos(\\tau_y)}{\\sin(\\tau_y)\\sin(\\tau_x)}{-\\sin(\\tau_y)\\cos(\\tau_x)}\n{0}{\\cos(\\tau_x)}{\\sin(\\tau_x)}\n{\\sin(\\tau_y)}{-\\cos(\\tau_y)\\sin(\\tau_x)}{\\cos(\\tau_y)\\cos(\\tau_x)}.\n\\f]\n\nIn the functions below the coefficients are passed or returned as\n\n\\f[(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f]\n\nvector. That is, if the vector contains four elements, it means that \\f$k_3=0\\f$ . The distortion\ncoefficients do not depend on the scene viewed. Thus, they also belong to the intrinsic camera\nparameters. And they remain the same regardless of the captured image resolution. If, for example, a\ncamera has been calibrated on images of 320 x 240 resolution, absolutely the same distortion\ncoefficients can be used for 640 x 480 images from the same camera while \\f$f_x\\f$, \\f$f_y\\f$, \\f$c_x\\f$, and\n\\f$c_y\\f$ need to be scaled appropriately.\n\nThe functions below use the above model to do the following:\n\n-   Project 3D points to the image plane given intrinsic and extrinsic parameters.\n-   Compute extrinsic parameters given intrinsic parameters, a few 3D points, and their\nprojections.\n-   Estimate intrinsic and extrinsic camera parameters from several views of a known calibration\npattern (every view is described by several 3D-2D point correspondences).\n-   Estimate the relative position and orientation of the stereo camera "heads" and compute the\n*rectification* transformation that makes the camera optical axes parallel.\n\n@note\n-   A calibration sample for 3 cameras in horizontal position can be found at\nopencv_source_code/samples/cpp/3calibration.cpp\n-   A calibration sample based on a sequence of images can be found at\nopencv_source_code/samples/cpp/calibration.cpp\n-   A calibration sample in order to do 3D reconstruction can be found at\nopencv_source_code/samples/cpp/build3dmodel.cpp\n-   A calibration example on stereo calibration can be found at\nopencv_source_code/samples/cpp/stereo_calib.cpp\n-   A calibration example on stereo matching can be found at\nopencv_source_code/samples/cpp/stereo_match.cpp\n-   (Python) A camera calibration sample can be found at\nopencv_source_code/samples/python/calibrate.py\n\n@{\n@defgroup calib3d_fisheye Fisheye camera model\n\nDefinitions: Let P be a point in 3D of coordinates X in the world reference frame (stored in the\nmatrix X) The coordinate vector of P in the camera reference frame is:\n\n\\f[Xc = R X + T\\f]\n\nwhere R is the rotation matrix corresponding to the rotation vector om: R = rodrigues(om); call x, y\nand z the 3 coordinates of Xc:\n\n\\f[x = Xc_1 \\\\ y = Xc_2 \\\\ z = Xc_3\\f]\n\nThe pinhole projection coordinates of P is [a; b] where\n\n\\f[a = x / z \\ and \\ b = y / z \\\\ r^2 = a^2 + b^2 \\\\ \\theta = atan(r)\\f]\n\nFisheye distortion:\n\n\\f[\\theta_d = \\theta (1 + k_1 \\theta^2 + k_2 \\theta^4 + k_3 \\theta^6 + k_4 \\theta^8)\\f]\n\nThe distorted point coordinates are [x\'; y\'] where\n\n\\f[x\' = (\\theta_d / r) a \\\\ y\' = (\\theta_d / r) b \\f]\n\nFinally, conversion into pixel coordinates: The final pixel coordinates vector [u; v] where:\n\n\\f[u = f_x (x\' + \\alpha y\') + c_x \\\\\nv = f_y y\' + c_y\\f]\n\n@defgroup calib3d_c C API\n\n@}\n\n'}

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   [   'const cv.LMEDS',
            '4',
            [],
            [],
            None,
            'least-median of squares algorithm\n'],
        ['const cv.RANSAC', '8', [], [], None, 'RANSAC algorithm\n'],
        ['const cv.RHO', '16', [], [], None, 'RHO algorithm\n']],
    None,
    '@addtogroup calib3d\n@{\ntype of the robust estimation algorithm']
parse_name: const cv.LMEDS with ['cv', 'cv::fisheye'] -> fullname:cv::LMEDS namespace:cv classpath: classname: name:LMEDS
parse_name: const cv.RANSAC with ['cv', 'cv::fisheye'] -> fullname:cv::RANSAC namespace:cv classpath: classname: name:RANSAC
parse_name: const cv.RHO with ['cv', 'cv::fisheye'] -> fullname:cv::RHO namespace:cv classpath: classname: name:RHO

--- Incoming ---
[   'enum cv.SolvePnPMethod',
    '',
    [],
    [   ['const cv.SOLVEPNP_ITERATIVE', '0', [], [], None, ''],
        [   'const cv.SOLVEPNP_EPNP',
            '1',
            [],
            [],
            None,
            'EPnP: Efficient Perspective-n-Point Camera Pose Estimation @cite '
            'lepetit2009epnp\n'],
        [   'const cv.SOLVEPNP_P3P',
            '2',
            [],
            [],
            None,
            'Complete Solution Classification for the Perspective-Three-Point '
            'Problem @cite gao2003complete\n'],
        [   'const cv.SOLVEPNP_DLS',
            '3',
            [],
            [],
            None,
            'A Direct Least-Squares (DLS) Method for PnP  @cite '
            'hesch2011direct\n'],
        [   'const cv.SOLVEPNP_UPNP',
            '4',
            [],
            [],
            None,
            'Exhaustive Linearization for Robust Camera Pose and Focal Length '
            'Estimation @cite penate2013exhaustive\n'],
        [   'const cv.SOLVEPNP_AP3P',
            '5',
            [],
            [],
            None,
            'An Efficient Algebraic Solution to the Perspective-Three-Point '
            'Problem @cite Ke17\n'],
        [   'const cv.SOLVEPNP_IPPE',
            '6',
            [],
            [],
            None,
            'Infinitesimal Plane-Based Pose Estimation @cite Collins14 \\n\n'],
        [   'const cv.SOLVEPNP_IPPE_SQUARE',
            '7',
            [],
            [],
            None,
            'Infinitesimal Plane-Based Pose Estimation @cite Collins14 \\n\n'],
        [   'const cv.SOLVEPNP_MAX_COUNT',
            '7+1',
            [],
            [],
            None,
            'Used for count\n']],
    None,
    '']
parse_name: const cv.SOLVEPNP_ITERATIVE with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_ITERATIVE namespace:cv classpath: classname: name:SOLVEPNP_ITERATIVE
parse_name: const cv.SOLVEPNP_EPNP with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_EPNP namespace:cv classpath: classname: name:SOLVEPNP_EPNP
parse_name: const cv.SOLVEPNP_P3P with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_P3P namespace:cv classpath: classname: name:SOLVEPNP_P3P
parse_name: const cv.SOLVEPNP_DLS with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_DLS namespace:cv classpath: classname: name:SOLVEPNP_DLS
parse_name: const cv.SOLVEPNP_UPNP with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_UPNP namespace:cv classpath: classname: name:SOLVEPNP_UPNP
parse_name: const cv.SOLVEPNP_AP3P with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_AP3P namespace:cv classpath: classname: name:SOLVEPNP_AP3P
parse_name: const cv.SOLVEPNP_IPPE with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_IPPE namespace:cv classpath: classname: name:SOLVEPNP_IPPE
parse_name: const cv.SOLVEPNP_IPPE_SQUARE with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_IPPE_SQUARE namespace:cv classpath: classname: name:SOLVEPNP_IPPE_SQUARE
parse_name: const cv.SOLVEPNP_MAX_COUNT with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_MAX_COUNT namespace:cv classpath: classname: name:SOLVEPNP_MAX_COUNT
parse_name: enum cv.SolvePnPMethod with ['cv', 'cv::fisheye'] -> fullname:cv::SolvePnPMethod namespace:cv classpath: classname: name:SolvePnPMethod
parse_name: const cv.SOLVEPNP_ITERATIVE with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_ITERATIVE namespace:cv classpath: classname: name:SOLVEPNP_ITERATIVE
parse_name: const cv.SOLVEPNP_EPNP with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_EPNP namespace:cv classpath: classname: name:SOLVEPNP_EPNP
parse_name: const cv.SOLVEPNP_P3P with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_P3P namespace:cv classpath: classname: name:SOLVEPNP_P3P
parse_name: const cv.SOLVEPNP_DLS with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_DLS namespace:cv classpath: classname: name:SOLVEPNP_DLS
parse_name: const cv.SOLVEPNP_UPNP with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_UPNP namespace:cv classpath: classname: name:SOLVEPNP_UPNP
parse_name: const cv.SOLVEPNP_AP3P with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_AP3P namespace:cv classpath: classname: name:SOLVEPNP_AP3P
parse_name: const cv.SOLVEPNP_IPPE with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_IPPE namespace:cv classpath: classname: name:SOLVEPNP_IPPE
parse_name: const cv.SOLVEPNP_IPPE_SQUARE with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_IPPE_SQUARE namespace:cv classpath: classname: name:SOLVEPNP_IPPE_SQUARE
parse_name: const cv.SOLVEPNP_MAX_COUNT with ['cv', 'cv::fisheye'] -> fullname:cv::SOLVEPNP_MAX_COUNT namespace:cv classpath: classname: name:SOLVEPNP_MAX_COUNT

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CALIB_CB_ADAPTIVE_THRESH', '1', [], [], None, ''],
        ['const cv.CALIB_CB_NORMALIZE_IMAGE', '2', [], [], None, ''],
        ['const cv.CALIB_CB_FILTER_QUADS', '4', [], [], None, ''],
        ['const cv.CALIB_CB_FAST_CHECK', '8', [], [], None, ''],
        ['const cv.CALIB_CB_EXHAUSTIVE', '16', [], [], None, ''],
        ['const cv.CALIB_CB_ACCURACY', '32', [], [], None, '']],
    None,
    '']
parse_name: const cv.CALIB_CB_ADAPTIVE_THRESH with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_ADAPTIVE_THRESH namespace:cv classpath: classname: name:CALIB_CB_ADAPTIVE_THRESH
parse_name: const cv.CALIB_CB_NORMALIZE_IMAGE with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_NORMALIZE_IMAGE namespace:cv classpath: classname: name:CALIB_CB_NORMALIZE_IMAGE
parse_name: const cv.CALIB_CB_FILTER_QUADS with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_FILTER_QUADS namespace:cv classpath: classname: name:CALIB_CB_FILTER_QUADS
parse_name: const cv.CALIB_CB_FAST_CHECK with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_FAST_CHECK namespace:cv classpath: classname: name:CALIB_CB_FAST_CHECK
parse_name: const cv.CALIB_CB_EXHAUSTIVE with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_EXHAUSTIVE namespace:cv classpath: classname: name:CALIB_CB_EXHAUSTIVE
parse_name: const cv.CALIB_CB_ACCURACY with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_ACCURACY namespace:cv classpath: classname: name:CALIB_CB_ACCURACY

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CALIB_CB_SYMMETRIC_GRID', '1', [], [], None, ''],
        ['const cv.CALIB_CB_ASYMMETRIC_GRID', '2', [], [], None, ''],
        ['const cv.CALIB_CB_CLUSTERING', '4', [], [], None, '']],
    None,
    '']
parse_name: const cv.CALIB_CB_SYMMETRIC_GRID with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_SYMMETRIC_GRID namespace:cv classpath: classname: name:CALIB_CB_SYMMETRIC_GRID
parse_name: const cv.CALIB_CB_ASYMMETRIC_GRID with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_ASYMMETRIC_GRID namespace:cv classpath: classname: name:CALIB_CB_ASYMMETRIC_GRID
parse_name: const cv.CALIB_CB_CLUSTERING with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_CB_CLUSTERING namespace:cv classpath: classname: name:CALIB_CB_CLUSTERING

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CALIB_NINTRINSIC', '18', [], [], None, ''],
        ['const cv.CALIB_USE_INTRINSIC_GUESS', '0x00001', [], [], None, ''],
        ['const cv.CALIB_FIX_ASPECT_RATIO', '0x00002', [], [], None, ''],
        ['const cv.CALIB_FIX_PRINCIPAL_POINT', '0x00004', [], [], None, ''],
        ['const cv.CALIB_ZERO_TANGENT_DIST', '0x00008', [], [], None, ''],
        ['const cv.CALIB_FIX_FOCAL_LENGTH', '0x00010', [], [], None, ''],
        ['const cv.CALIB_FIX_K1', '0x00020', [], [], None, ''],
        ['const cv.CALIB_FIX_K2', '0x00040', [], [], None, ''],
        ['const cv.CALIB_FIX_K3', '0x00080', [], [], None, ''],
        ['const cv.CALIB_FIX_K4', '0x00800', [], [], None, ''],
        ['const cv.CALIB_FIX_K5', '0x01000', [], [], None, ''],
        ['const cv.CALIB_FIX_K6', '0x02000', [], [], None, ''],
        ['const cv.CALIB_RATIONAL_MODEL', '0x04000', [], [], None, ''],
        ['const cv.CALIB_THIN_PRISM_MODEL', '0x08000', [], [], None, ''],
        ['const cv.CALIB_FIX_S1_S2_S3_S4', '0x10000', [], [], None, ''],
        ['const cv.CALIB_TILTED_MODEL', '0x40000', [], [], None, ''],
        ['const cv.CALIB_FIX_TAUX_TAUY', '0x80000', [], [], None, ''],
        [   'const cv.CALIB_USE_QR',
            '0x100000',
            [],
            [],
            None,
            'use QR instead of SVD decomposition for solving. Faster but '
            'potentially less precise\n'],
        ['const cv.CALIB_FIX_TANGENT_DIST', '0x200000', [], [], None, ''],
        ['const cv.CALIB_FIX_INTRINSIC', '0x00100', [], [], None, ''],
        ['const cv.CALIB_SAME_FOCAL_LENGTH', '0x00200', [], [], None, ''],
        ['const cv.CALIB_ZERO_DISPARITY', '0x00400', [], [], None, ''],
        [   'const cv.CALIB_USE_LU',
            '(1 << 17)',
            [],
            [],
            None,
            'use LU instead of SVD decomposition for solving. much faster but '
            'potentially less precise\n'],
        [   'const cv.CALIB_USE_EXTRINSIC_GUESS',
            '(1 << 22)',
            [],
            [],
            None,
            'for stereoCalibrate\n']],
    None,
    '']
parse_name: const cv.CALIB_NINTRINSIC with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_NINTRINSIC namespace:cv classpath: classname: name:CALIB_NINTRINSIC
parse_name: const cv.CALIB_USE_INTRINSIC_GUESS with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_USE_INTRINSIC_GUESS namespace:cv classpath: classname: name:CALIB_USE_INTRINSIC_GUESS
parse_name: const cv.CALIB_FIX_ASPECT_RATIO with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_ASPECT_RATIO namespace:cv classpath: classname: name:CALIB_FIX_ASPECT_RATIO
parse_name: const cv.CALIB_FIX_PRINCIPAL_POINT with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_PRINCIPAL_POINT namespace:cv classpath: classname: name:CALIB_FIX_PRINCIPAL_POINT
parse_name: const cv.CALIB_ZERO_TANGENT_DIST with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_ZERO_TANGENT_DIST namespace:cv classpath: classname: name:CALIB_ZERO_TANGENT_DIST
parse_name: const cv.CALIB_FIX_FOCAL_LENGTH with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_FOCAL_LENGTH namespace:cv classpath: classname: name:CALIB_FIX_FOCAL_LENGTH
parse_name: const cv.CALIB_FIX_K1 with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_K1 namespace:cv classpath: classname: name:CALIB_FIX_K1
parse_name: const cv.CALIB_FIX_K2 with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_K2 namespace:cv classpath: classname: name:CALIB_FIX_K2
parse_name: const cv.CALIB_FIX_K3 with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_K3 namespace:cv classpath: classname: name:CALIB_FIX_K3
parse_name: const cv.CALIB_FIX_K4 with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_K4 namespace:cv classpath: classname: name:CALIB_FIX_K4
parse_name: const cv.CALIB_FIX_K5 with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_K5 namespace:cv classpath: classname: name:CALIB_FIX_K5
parse_name: const cv.CALIB_FIX_K6 with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_K6 namespace:cv classpath: classname: name:CALIB_FIX_K6
parse_name: const cv.CALIB_RATIONAL_MODEL with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_RATIONAL_MODEL namespace:cv classpath: classname: name:CALIB_RATIONAL_MODEL
parse_name: const cv.CALIB_THIN_PRISM_MODEL with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_THIN_PRISM_MODEL namespace:cv classpath: classname: name:CALIB_THIN_PRISM_MODEL
parse_name: const cv.CALIB_FIX_S1_S2_S3_S4 with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_S1_S2_S3_S4 namespace:cv classpath: classname: name:CALIB_FIX_S1_S2_S3_S4
parse_name: const cv.CALIB_TILTED_MODEL with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_TILTED_MODEL namespace:cv classpath: classname: name:CALIB_TILTED_MODEL
parse_name: const cv.CALIB_FIX_TAUX_TAUY with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_TAUX_TAUY namespace:cv classpath: classname: name:CALIB_FIX_TAUX_TAUY
parse_name: const cv.CALIB_USE_QR with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_USE_QR namespace:cv classpath: classname: name:CALIB_USE_QR
parse_name: const cv.CALIB_FIX_TANGENT_DIST with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_TANGENT_DIST namespace:cv classpath: classname: name:CALIB_FIX_TANGENT_DIST
parse_name: const cv.CALIB_FIX_INTRINSIC with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_FIX_INTRINSIC namespace:cv classpath: classname: name:CALIB_FIX_INTRINSIC
parse_name: const cv.CALIB_SAME_FOCAL_LENGTH with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_SAME_FOCAL_LENGTH namespace:cv classpath: classname: name:CALIB_SAME_FOCAL_LENGTH
parse_name: const cv.CALIB_ZERO_DISPARITY with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_ZERO_DISPARITY namespace:cv classpath: classname: name:CALIB_ZERO_DISPARITY
parse_name: const cv.CALIB_USE_LU with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_USE_LU namespace:cv classpath: classname: name:CALIB_USE_LU
parse_name: const cv.CALIB_USE_EXTRINSIC_GUESS with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_USE_EXTRINSIC_GUESS namespace:cv classpath: classname: name:CALIB_USE_EXTRINSIC_GUESS

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.FM_7POINT', '1', [], [], None, '7-point algorithm\n'],
        ['const cv.FM_8POINT', '2', [], [], None, '8-point algorithm\n'],
        [   'const cv.FM_LMEDS',
            '4',
            [],
            [],
            None,
            'least-median algorithm. 7-point algorithm is used.\n'],
        [   'const cv.FM_RANSAC',
            '8',
            [],
            [],
            None,
            'RANSAC algorithm. It needs at least 15 points. 7-point algorithm '
            'is used.\n']],
    None,
    'the algorithm for finding fundamental matrix']
parse_name: const cv.FM_7POINT with ['cv', 'cv::fisheye'] -> fullname:cv::FM_7POINT namespace:cv classpath: classname: name:FM_7POINT
parse_name: const cv.FM_8POINT with ['cv', 'cv::fisheye'] -> fullname:cv::FM_8POINT namespace:cv classpath: classname: name:FM_8POINT
parse_name: const cv.FM_LMEDS with ['cv', 'cv::fisheye'] -> fullname:cv::FM_LMEDS namespace:cv classpath: classname: name:FM_LMEDS
parse_name: const cv.FM_RANSAC with ['cv', 'cv::fisheye'] -> fullname:cv::FM_RANSAC namespace:cv classpath: classname: name:FM_RANSAC

--- Incoming ---
[   'enum cv.HandEyeCalibrationMethod',
    '',
    [],
    [   [   'const cv.CALIB_HAND_EYE_TSAI',
            '0',
            [],
            [],
            None,
            'A New Technique for Fully Autonomous and Efficient 3D Robotics '
            'Hand/Eye Calibration @cite Tsai89\n'],
        [   'const cv.CALIB_HAND_EYE_PARK',
            '1',
            [],
            [],
            None,
            'Robot Sensor Calibration: Solving AX = XB on the Euclidean Group '
            '@cite Park94\n'],
        [   'const cv.CALIB_HAND_EYE_HORAUD',
            '2',
            [],
            [],
            None,
            'Hand-eye Calibration @cite Horaud95\n'],
        [   'const cv.CALIB_HAND_EYE_ANDREFF',
            '3',
            [],
            [],
            None,
            'On-line Hand-Eye Calibration @cite Andreff99\n'],
        [   'const cv.CALIB_HAND_EYE_DANIILIDIS',
            '4',
            [],
            [],
            None,
            'Hand-Eye Calibration Using Dual Quaternions @cite '
            'Daniilidis98\n']],
    None,
    '']
parse_name: const cv.CALIB_HAND_EYE_TSAI with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_TSAI namespace:cv classpath: classname: name:CALIB_HAND_EYE_TSAI
parse_name: const cv.CALIB_HAND_EYE_PARK with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_PARK namespace:cv classpath: classname: name:CALIB_HAND_EYE_PARK
parse_name: const cv.CALIB_HAND_EYE_HORAUD with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_HORAUD namespace:cv classpath: classname: name:CALIB_HAND_EYE_HORAUD
parse_name: const cv.CALIB_HAND_EYE_ANDREFF with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_ANDREFF namespace:cv classpath: classname: name:CALIB_HAND_EYE_ANDREFF
parse_name: const cv.CALIB_HAND_EYE_DANIILIDIS with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_DANIILIDIS namespace:cv classpath: classname: name:CALIB_HAND_EYE_DANIILIDIS
parse_name: enum cv.HandEyeCalibrationMethod with ['cv', 'cv::fisheye'] -> fullname:cv::HandEyeCalibrationMethod namespace:cv classpath: classname: name:HandEyeCalibrationMethod
parse_name: const cv.CALIB_HAND_EYE_TSAI with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_TSAI namespace:cv classpath: classname: name:CALIB_HAND_EYE_TSAI
parse_name: const cv.CALIB_HAND_EYE_PARK with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_PARK namespace:cv classpath: classname: name:CALIB_HAND_EYE_PARK
parse_name: const cv.CALIB_HAND_EYE_HORAUD with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_HORAUD namespace:cv classpath: classname: name:CALIB_HAND_EYE_HORAUD
parse_name: const cv.CALIB_HAND_EYE_ANDREFF with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_ANDREFF namespace:cv classpath: classname: name:CALIB_HAND_EYE_ANDREFF
parse_name: const cv.CALIB_HAND_EYE_DANIILIDIS with ['cv', 'cv::fisheye'] -> fullname:cv::CALIB_HAND_EYE_DANIILIDIS namespace:cv classpath: classname: name:CALIB_HAND_EYE_DANIILIDIS

--- Incoming ---
[   'cv.Rodrigues',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['OutputArray', 'jacobian', 'noArray()', []]],
    None,
    '@brief Converts a rotation matrix to a rotation vector or vice versa.\n'
    '\n'
    '@param src Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).\n'
    '@param dst Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), '
    'respectively.\n'
    '@param jacobian Optional output Jacobian matrix, 3x9 or 9x3, which is a '
    'matrix of partial\n'
    'derivatives of the output array components with respect to the input '
    'array components.\n'
    '\n'
    '\\f[\\begin{array}{l} \\theta \\leftarrow norm(r) \\\\ r  \\leftarrow r/ '
    '\\theta \\\\ R =  \\cos{\\theta} I + (1- \\cos{\\theta} ) r r^T +  '
    '\\sin{\\theta} \\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} '
    '\\end{array}\\f]\n'
    '\n'
    'Inverse transformation can be also done easily, since\n'
    '\n'
    '\\f[\\sin ( \\theta ) '
    '\\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \\frac{R - '
    'R^T}{2}\\f]\n'
    '\n'
    'A rotation vector is a convenient and most compact representation of a '
    'rotation matrix (since any\n'
    'rotation matrix has just 3 degrees of freedom). The representation is '
    'used in the global 3D geometry\n'
    'optimization procedures like calibrateCamera, stereoCalibrate, or '
    'solvePnP .']
parse_name: cv.Rodrigues with ['cv', 'cv::fisheye'] -> fullname:cv::Rodrigues namespace:cv classpath: classname: name:Rodrigues
register (function) Rodrigues (cv_Rodrigues__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'class cv.LMSolver',
    ': cv::Algorithm',
    [],
    [],
    None,
    'Levenberg-Marquardt solver. Starting with the specified vector of '
    'parameters it\n'
    'optimizes the target vector criteria "err"\n'
    '(finds local minima of each target vector component absolute value).\n'
    '\n'
    'When needed, it calls user-provided callback.']
parse_name: class cv.LMSolver with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver namespace:cv classpath: classname: name:LMSolver
register class cv::LMSolver (['class cv.LMSolver', ': cv::Algorithm', [], [], None, 'Levenberg-Marquardt solver. Starting with the specified vector of parameters it\noptimizes the target vector criteria "err"\n(finds local minima of each target vector component absolute value).\n\nWhen needed, it calls user-provided callback.']) impl:cv::Algorithm

--- Incoming ---
['class cv.LMSolver.Callback', '', [], [], None, '']
parse_name: class cv.LMSolver.Callback with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::Callback namespace:cv classpath:LMSolver classname:LMSolver name:Callback
register class cv::LMSolver::Callback (['class cv.LMSolver.Callback', '', [], [], None, ''])

--- Incoming ---
['cv.LMSolver.Callback.~Callback', '~', [], [], None, '']
parse_name: cv.LMSolver.Callback.~Callback with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::Callback::~Callback namespace:cv classpath:LMSolver::Callback classname:Callback name:~Callback
Registering an unknown type: ~
ignore destructor (method) ~Callback in cv::LMSolver::Callback

--- Incoming ---
[   'cv.LMSolver.Callback.compute',
    'bool',
    ['/A', '/C'],
    [   ['InputArray', 'param', '', []],
        ['OutputArray', 'err', '', []],
        ['OutputArray', 'J', '', []]],
    None,
    'computes error and Jacobian for the specified vector of parameters\n'
    '\n'
    '@param param the current vector of parameters\n'
    '@param err output vector of errors: err_i = actual_f_i - ideal_f_i\n'
    '@param J output Jacobian: J_ij = d(err_i)/d(param_j)\n'
    '\n'
    'when J=noArray(), it means that it does not need to be computed.\n'
    'Dimensionality of error vector and param vector can be different.\n'
    'The callback should explicitly allocate (with "create" method) each '
    'output array\n'
    "(unless it's noArray())."]
parse_name: cv.LMSolver.Callback.compute with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::Callback::compute namespace:cv classpath:LMSolver::Callback classname:Callback name:compute
register (method) compute in cv::LMSolver::Callback (trait) (cv_LMSolver_Callback_compute_const__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.LMSolver.run',
    'int',
    ['/A', '/C'],
    [['InputOutputArray', 'param', '', []]],
    None,
    'Runs Levenberg-Marquardt algorithm using the passed vector of parameters '
    'as the start point.\n'
    'The final vector of parameters (whether the algorithm converged or not) '
    'is stored at the same\n'
    "vector. The method returns the number of iterations used. If it's equal "
    'to the previously specified\n'
    'maxIters, there is a big chance the algorithm did not converge.\n'
    '\n'
    '@param param initial/final vector of parameters.\n'
    '\n'
    'Note that the dimensionality of parameter space is defined by the size of '
    'param vector,\n'
    'and the dimensionality of optimized criteria is defined by the size of '
    'err vector\n'
    'computed by the callback.']
parse_name: cv.LMSolver.run with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::run namespace:cv classpath:LMSolver classname:LMSolver name:run
register (method) run in cv::LMSolver (trait) (cv_LMSolver_run_const__InputOutputArray)

--- Incoming ---
[   'cv.LMSolver.setMaxIters',
    'void',
    ['/A'],
    [['int', 'maxIters', '', []]],
    None,
    'Sets the maximum number of iterations\n'
    '@param maxIters the number of iterations']
parse_name: cv.LMSolver.setMaxIters with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::setMaxIters namespace:cv classpath:LMSolver classname:LMSolver name:setMaxIters
register (method) setMaxIters in cv::LMSolver (trait) (cv_LMSolver_setMaxIters_int)

--- Incoming ---
[   'cv.LMSolver.getMaxIters',
    'int',
    ['/A', '/C'],
    [],
    None,
    'Retrieves the current maximum number of iterations']
parse_name: cv.LMSolver.getMaxIters with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::getMaxIters namespace:cv classpath:LMSolver classname:LMSolver name:getMaxIters
register (method) getMaxIters in cv::LMSolver (trait) (cv_LMSolver_getMaxIters_const)

--- Incoming ---
[   'cv.LMSolver.create',
    'Ptr<LMSolver>',
    ['/S'],
    [   ['const Ptr<LMSolver::Callback>&', 'cb', '', []],
        ['int', 'maxIters', '', []]],
    None,
    'Creates Levenberg-Marquard solver\n'
    '\n'
    '@param cb callback\n'
    '@param maxIters maximum number of iterations that can be further\n'
    'modified using setMaxIters() method.']
parse_name: cv.LMSolver.create with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::create namespace:cv classpath:LMSolver classname:LMSolver name:create
register (method) create in cv::LMSolver (trait) (cv_LMSolver_create_PtrOfCallback_int)

--- Incoming ---
[   'cv.LMSolver.create',
    'Ptr<LMSolver>',
    ['/S'],
    [   ['const Ptr<LMSolver::Callback>&', 'cb', '', []],
        ['int', 'maxIters', '', []],
        ['double', 'eps', '', []]],
    None,
    '']
parse_name: cv.LMSolver.create with ['cv', 'cv::fisheye'] -> fullname:cv::LMSolver::create namespace:cv classpath:LMSolver classname:LMSolver name:create
register (method) create in cv::LMSolver (trait) (cv_LMSolver_create_PtrOfCallback_int_double)

--- Incoming ---
[   'cv.findHomography',
    'Mat',
    [],
    [   ['InputArray', 'srcPoints', '', []],
        ['InputArray', 'dstPoints', '', []],
        ['int', 'method', '0', []],
        ['double', 'ransacReprojThreshold', '3', []],
        ['OutputArray', 'mask', 'noArray()', []],
        ['const int', 'maxIters', '2000', []],
        ['const double', 'confidence', '0.995', []]],
    None,
    '@brief Finds a perspective transformation between two planes.\n'
    '\n'
    '@param srcPoints Coordinates of the points in the original plane, a '
    'matrix of the type CV_32FC2\n'
    'or vector\\<Point2f\\> .\n'
    '@param dstPoints Coordinates of the points in the target plane, a matrix '
    'of the type CV_32FC2 or\n'
    'a vector\\<Point2f\\> .\n'
    '@param method Method used to compute a homography matrix. The following '
    'methods are possible:\n'
    '-   **0** - a regular method using all the points, i.e., the least '
    'squares method\n'
    '-   **RANSAC** - RANSAC-based robust method\n'
    '-   **LMEDS** - Least-Median robust method\n'
    '-   **RHO** - PROSAC-based robust method\n'
    '@param ransacReprojThreshold Maximum allowed reprojection error to treat '
    'a point pair as an inlier\n'
    '(used in the RANSAC and RHO methods only). That is, if\n'
    '\\f[\\| \\texttt{dstPoints} _i -  \\texttt{convertPointsHomogeneous} ( '
    '\\texttt{H} * \\texttt{srcPoints} _i) \\|_2  >  '
    '\\texttt{ransacReprojThreshold}\\f]\n'
    'then the point \\f$i\\f$ is considered as an outlier. If srcPoints and '
    'dstPoints are measured in pixels,\n'
    'it usually makes sense to set this parameter somewhere in the range of 1 '
    'to 10.\n'
    '@param mask Optional output mask set by a robust method ( RANSAC or LMEDS '
    '). Note that the input\n'
    'mask values are ignored.\n'
    '@param maxIters The maximum number of RANSAC iterations.\n'
    '@param confidence Confidence level, between 0 and 1.\n'
    '\n'
    'The function finds and returns the perspective transformation \\f$H\\f$ '
    'between the source and the\n'
    'destination planes:\n'
    '\n'
    "\\f[s_i  \\vecthree{x'_i}{y'_i}{1} \\sim H  \\vecthree{x_i}{y_i}{1}\\f]\n"
    '\n'
    'so that the back-projection error\n'
    '\n'
    "\\f[\\sum _i \\left ( x'_i- \\frac{h_{11} x_i + h_{12} y_i + "
    "h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \\right )^2+ \\left ( y'_i- "
    '\\frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + '
    'h_{33}} \\right )^2\\f]\n'
    '\n'
    'is minimized. If the parameter method is set to the default value 0, the '
    'function uses all the point\n'
    'pairs to compute an initial homography estimate with a simple '
    'least-squares scheme.\n'
    '\n'
    'However, if not all of the point pairs ( \\f$srcPoints_i\\f$, '
    '\\f$dstPoints_i\\f$ ) fit the rigid perspective\n'
    'transformation (that is, there are some outliers), this initial estimate '
    'will be poor. In this case,\n'
    'you can use one of the three robust methods. The methods RANSAC, LMeDS '
    'and RHO try many different\n'
    'random subsets of the corresponding point pairs (of four pairs each, '
    'collinear pairs are discarded), estimate the homography matrix\n'
    'using this subset and a simple least-squares algorithm, and then compute '
    'the quality/goodness of the\n'
    'computed homography (which is the number of inliers for RANSAC or the '
    'least median re-projection error for\n'
    'LMeDS). The best subset is then used to produce the initial estimate of '
    'the homography matrix and\n'
    'the mask of inliers/outliers.\n'
    '\n'
    'Regardless of the method, robust or not, the computed homography matrix '
    'is refined further (using\n'
    'inliers only in case of a robust method) with the Levenberg-Marquardt '
    'method to reduce the\n'
    're-projection error even more.\n'
    '\n'
    'The methods RANSAC and RHO can handle practically any ratio of outliers '
    'but need a threshold to\n'
    'distinguish inliers from outliers. The method LMeDS does not need any '
    'threshold but it works\n'
    'correctly only when there are more than 50% of inliers. Finally, if there '
    'are no outliers and the\n'
    'noise is rather small, use the default method (method=0).\n'
    '\n'
    'The function is used to find initial intrinsic and extrinsic matrices. '
    'Homography matrix is\n'
    'determined up to a scale. Thus, it is normalized so that '
    '\\f$h_{33}=1\\f$. Note that whenever an \\f$H\\f$ matrix\n'
    'cannot be estimated, an empty one will be returned.\n'
    '\n'
    '@sa\n'
    'getAffineTransform, estimateAffine2D, estimateAffinePartial2D, '
    'getPerspectiveTransform, warpPerspective,\n'
    'perspectiveTransform']
parse_name: cv.findHomography with ['cv', 'cv::fisheye'] -> fullname:cv::findHomography namespace:cv classpath: classname: name:findHomography
register (function) findHomography (cv_findHomography__InputArray__InputArray_int_double__OutputArray_int_double)

--- Incoming ---
[   'cv.findHomography',
    'Mat',
    [],
    [   ['InputArray', 'srcPoints', '', []],
        ['InputArray', 'dstPoints', '', []],
        ['OutputArray', 'mask', '', []],
        ['int', 'method', '0', []],
        ['double', 'ransacReprojThreshold', '3', []]],
    None,
    '@overload']
parse_name: cv.findHomography with ['cv', 'cv::fisheye'] -> fullname:cv::findHomography namespace:cv classpath: classname: name:findHomography
register (function) findHomography (cv_findHomography__InputArray__InputArray__OutputArray_int_double)

--- Incoming ---
[   'cv.RQDecomp3x3',
    'Vec3d',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'mtxR', '', []],
        ['OutputArray', 'mtxQ', '', []],
        ['OutputArray', 'Qx', 'noArray()', []],
        ['OutputArray', 'Qy', 'noArray()', []],
        ['OutputArray', 'Qz', 'noArray()', []]],
    None,
    '@brief Computes an RQ decomposition of 3x3 matrices.\n'
    '\n'
    '@param src 3x3 input matrix.\n'
    '@param mtxR Output 3x3 upper-triangular matrix.\n'
    '@param mtxQ Output 3x3 orthogonal matrix.\n'
    '@param Qx Optional output 3x3 rotation matrix around x-axis.\n'
    '@param Qy Optional output 3x3 rotation matrix around y-axis.\n'
    '@param Qz Optional output 3x3 rotation matrix around z-axis.\n'
    '\n'
    'The function computes a RQ decomposition using the given rotations. This '
    'function is used in\n'
    'decomposeProjectionMatrix to decompose the left 3x3 submatrix of a '
    'projection matrix into a camera\n'
    'and a rotation matrix.\n'
    '\n'
    'It optionally returns three rotation matrices, one for each axis, and the '
    'three Euler angles in\n'
    'degrees (as the return value) that could be used in OpenGL. Note, there '
    'is always more than one\n'
    'sequence of rotations about the three principal axes that results in the '
    'same orientation of an\n'
    'object, e.g. see @cite Slabaugh . Returned tree rotation matrices and '
    'corresponding three Euler angles\n'
    'are only one of the possible solutions.']
parse_name: cv.RQDecomp3x3 with ['cv', 'cv::fisheye'] -> fullname:cv::RQDecomp3x3 namespace:cv classpath: classname: name:RQDecomp3x3
register (function) RQDecomp3x3 (cv_RQDecomp3x3__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.decomposeProjectionMatrix',
    'void',
    [],
    [   ['InputArray', 'projMatrix', '', []],
        ['OutputArray', 'cameraMatrix', '', []],
        ['OutputArray', 'rotMatrix', '', []],
        ['OutputArray', 'transVect', '', []],
        ['OutputArray', 'rotMatrixX', 'noArray()', []],
        ['OutputArray', 'rotMatrixY', 'noArray()', []],
        ['OutputArray', 'rotMatrixZ', 'noArray()', []],
        ['OutputArray', 'eulerAngles', 'noArray()', []]],
    None,
    '@brief Decomposes a projection matrix into a rotation matrix and a camera '
    'matrix.\n'
    '\n'
    '@param projMatrix 3x4 input projection matrix P.\n'
    '@param cameraMatrix Output 3x3 camera matrix K.\n'
    '@param rotMatrix Output 3x3 external rotation matrix R.\n'
    '@param transVect Output 4x1 translation vector T.\n'
    '@param rotMatrixX Optional 3x3 rotation matrix around x-axis.\n'
    '@param rotMatrixY Optional 3x3 rotation matrix around y-axis.\n'
    '@param rotMatrixZ Optional 3x3 rotation matrix around z-axis.\n'
    '@param eulerAngles Optional three-element vector containing three Euler '
    'angles of rotation in\n'
    'degrees.\n'
    '\n'
    'The function computes a decomposition of a projection matrix into a '
    'calibration and a rotation\n'
    'matrix and the position of a camera.\n'
    '\n'
    'It optionally returns three rotation matrices, one for each axis, and '
    'three Euler angles that could\n'
    'be used in OpenGL. Note, there is always more than one sequence of '
    'rotations about the three\n'
    'principal axes that results in the same orientation of an object, e.g. '
    'see @cite Slabaugh . Returned\n'
    'tree rotation matrices and corresponding three Euler angles are only one '
    'of the possible solutions.\n'
    '\n'
    'The function is based on RQDecomp3x3 .']
parse_name: cv.decomposeProjectionMatrix with ['cv', 'cv::fisheye'] -> fullname:cv::decomposeProjectionMatrix namespace:cv classpath: classname: name:decomposeProjectionMatrix
register (function) decomposeProjectionMatrix (cv_decomposeProjectionMatrix__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.matMulDeriv',
    'void',
    [],
    [   ['InputArray', 'A', '', []],
        ['InputArray', 'B', '', []],
        ['OutputArray', 'dABdA', '', []],
        ['OutputArray', 'dABdB', '', []]],
    None,
    '@brief Computes partial derivatives of the matrix product for each '
    'multiplied matrix.\n'
    '\n'
    '@param A First multiplied matrix.\n'
    '@param B Second multiplied matrix.\n'
    '@param dABdA First output derivative matrix d(A\\*B)/dA of size\n'
    '\\f$\\texttt{A.rows*B.cols} \\times {A.rows*A.cols}\\f$ .\n'
    '@param dABdB Second output derivative matrix d(A\\*B)/dB of size\n'
    '\\f$\\texttt{A.rows*B.cols} \\times {B.rows*B.cols}\\f$ .\n'
    '\n'
    'The function computes partial derivatives of the elements of the matrix '
    'product \\f$A*B\\f$ with regard to\n'
    'the elements of each of the two input matrices. The function is used to '
    'compute the Jacobian\n'
    'matrices in stereoCalibrate but can also be used in any other similar '
    'optimization function.']
parse_name: cv.matMulDeriv with ['cv', 'cv::fisheye'] -> fullname:cv::matMulDeriv namespace:cv classpath: classname: name:matMulDeriv
register (function) matMulDeriv (cv_matMulDeriv__InputArray__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.composeRT',
    'void',
    [],
    [   ['InputArray', 'rvec1', '', []],
        ['InputArray', 'tvec1', '', []],
        ['InputArray', 'rvec2', '', []],
        ['InputArray', 'tvec2', '', []],
        ['OutputArray', 'rvec3', '', []],
        ['OutputArray', 'tvec3', '', []],
        ['OutputArray', 'dr3dr1', 'noArray()', []],
        ['OutputArray', 'dr3dt1', 'noArray()', []],
        ['OutputArray', 'dr3dr2', 'noArray()', []],
        ['OutputArray', 'dr3dt2', 'noArray()', []],
        ['OutputArray', 'dt3dr1', 'noArray()', []],
        ['OutputArray', 'dt3dt1', 'noArray()', []],
        ['OutputArray', 'dt3dr2', 'noArray()', []],
        ['OutputArray', 'dt3dt2', 'noArray()', []]],
    None,
    '@brief Combines two rotation-and-shift transformations.\n'
    '\n'
    '@param rvec1 First rotation vector.\n'
    '@param tvec1 First translation vector.\n'
    '@param rvec2 Second rotation vector.\n'
    '@param tvec2 Second translation vector.\n'
    '@param rvec3 Output rotation vector of the superposition.\n'
    '@param tvec3 Output translation vector of the superposition.\n'
    '@param dr3dr1 Optional output derivative of rvec3 with regard to rvec1\n'
    '@param dr3dt1 Optional output derivative of rvec3 with regard to tvec1\n'
    '@param dr3dr2 Optional output derivative of rvec3 with regard to rvec2\n'
    '@param dr3dt2 Optional output derivative of rvec3 with regard to tvec2\n'
    '@param dt3dr1 Optional output derivative of tvec3 with regard to rvec1\n'
    '@param dt3dt1 Optional output derivative of tvec3 with regard to tvec1\n'
    '@param dt3dr2 Optional output derivative of tvec3 with regard to rvec2\n'
    '@param dt3dt2 Optional output derivative of tvec3 with regard to tvec2\n'
    '\n'
    'The functions compute:\n'
    '\n'
    '\\f[\\begin{array}{l} \\texttt{rvec3} =  \\mathrm{rodrigues} ^{-1} \\left '
    '( \\mathrm{rodrigues} ( \\texttt{rvec2} )  \\cdot \\mathrm{rodrigues} ( '
    '\\texttt{rvec1} ) \\right )  \\\\ \\texttt{tvec3} =  \\mathrm{rodrigues} '
    '( \\texttt{rvec2} )  \\cdot \\texttt{tvec1} +  \\texttt{tvec2} '
    '\\end{array} ,\\f]\n'
    '\n'
    'where \\f$\\mathrm{rodrigues}\\f$ denotes a rotation vector to a rotation '
    'matrix transformation, and\n'
    '\\f$\\mathrm{rodrigues}^{-1}\\f$ denotes the inverse transformation. See '
    'Rodrigues for details.\n'
    '\n'
    'Also, the functions can compute the derivatives of the output vectors '
    'with regards to the input\n'
    'vectors (see matMulDeriv ). The functions are used inside stereoCalibrate '
    'but can also be used in\n'
    'your own code where Levenberg-Marquardt or another gradient-based solver '
    'is used to optimize a\n'
    'function that contains a matrix multiplication.']
parse_name: cv.composeRT with ['cv', 'cv::fisheye'] -> fullname:cv::composeRT namespace:cv classpath: classname: name:composeRT
register (function) composeRT (cv_composeRT__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.projectPoints',
    'void',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['InputArray', 'rvec', '', []],
        ['InputArray', 'tvec', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['OutputArray', 'imagePoints', '', []],
        ['OutputArray', 'jacobian', 'noArray()', []],
        ['double', 'aspectRatio', '0', []]],
    None,
    '@brief Projects 3D points to an image plane.\n'
    '\n'
    '@param objectPoints Array of object points, 3xN/Nx3 1-channel or 1xN/Nx1 '
    '3-channel (or\n'
    'vector\\<Point3f\\> ), where N is the number of points in the view.\n'
    '@param rvec Rotation vector. See Rodrigues for details.\n'
    '@param tvec Translation vector.\n'
    '@param cameraMatrix Camera matrix \\f$A = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is empty, the zero distortion '
    'coefficients are assumed.\n'
    '@param imagePoints Output array of image points, 1xN/Nx1 2-channel, or\n'
    'vector\\<Point2f\\> .\n'
    '@param jacobian Optional output 2Nx(10+\\<numDistCoeffs\\>) jacobian '
    'matrix of derivatives of image\n'
    'points with respect to components of the rotation vector, translation '
    'vector, focal lengths,\n'
    'coordinates of the principal point and the distortion coefficients. In '
    'the old interface different\n'
    'components of the jacobian are returned via different output parameters.\n'
    '@param aspectRatio Optional "fixed aspect ratio" parameter. If the '
    'parameter is not 0, the\n'
    'function assumes that the aspect ratio (*fx/fy*) is fixed and '
    'correspondingly adjusts the jacobian\n'
    'matrix.\n'
    '\n'
    'The function computes projections of 3D points to the image plane given '
    'intrinsic and extrinsic\n'
    'camera parameters. Optionally, the function computes Jacobians - matrices '
    'of partial derivatives of\n'
    'image points coordinates (as functions of all the input parameters) with '
    'respect to the particular\n'
    'parameters, intrinsic and/or extrinsic. The Jacobians are used during the '
    'global optimization in\n'
    'calibrateCamera, solvePnP, and stereoCalibrate . The function itself can '
    'also be used to compute a\n'
    're-projection error given the current intrinsic and extrinsic '
    'parameters.\n'
    '\n'
    '@note By setting rvec=tvec=(0,0,0) or by setting cameraMatrix to a 3x3 '
    'identity matrix, or by\n'
    'passing zero distortion coefficients, you can get various useful partial '
    'cases of the function. This\n'
    'means that you can compute the distorted coordinates for a sparse set of '
    'points or apply a\n'
    'perspective transformation (and also compute the derivatives) in the '
    'ideal zero-distortion setup.']
parse_name: cv.projectPoints with ['cv', 'cv::fisheye'] -> fullname:cv::projectPoints namespace:cv classpath: classname: name:projectPoints
register (function) projectPoints (cv_projectPoints__InputArray__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_double)

--- Incoming ---
[   'cv.solvePnP',
    'bool',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['InputArray', 'imagePoints', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['OutputArray', 'rvec', '', []],
        ['OutputArray', 'tvec', '', []],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['int', 'flags', 'SOLVEPNP_ITERATIVE', []]],
    None,
    '@brief Finds an object pose from 3D-2D point correspondences.\n'
    'This function returns the rotation and the translation vectors that '
    'transform a 3D point expressed in the object\n'
    'coordinate frame to the camera coordinate frame, using different '
    'methods:\n'
    '- P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): need 4 input '
    'points to return a unique solution.\n'
    '- @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be '
    'coplanar.\n'
    '- @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose '
    'estimation.\n'
    'Number of input points must be 4. Object points must be defined in the '
    'following order:\n'
    '- point 0: [-squareLength / 2,  squareLength / 2, 0]\n'
    '- point 1: [ squareLength / 2,  squareLength / 2, 0]\n'
    '- point 2: [ squareLength / 2, -squareLength / 2, 0]\n'
    '- point 3: [-squareLength / 2, -squareLength / 2, 0]\n'
    '- for all the other flags, number of input points must be >= 4 and object '
    'points can be in any configuration.\n'
    '\n'
    '@param objectPoints Array of object points in the object coordinate '
    'space, Nx3 1-channel or\n'
    '1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3f\\> '
    'can be also passed here.\n'
    '@param imagePoints Array of corresponding image points, Nx2 1-channel or '
    '1xN/Nx1 2-channel,\n'
    'where N is the number of points. vector\\<Point2f\\> can be also passed '
    'here.\n'
    '@param cameraMatrix Input camera matrix \\f$A = '
    '\\vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are\n'
    'assumed.\n'
    '@param rvec Output rotation vector (see @ref Rodrigues ) that, together '
    'with tvec, brings points from\n'
    'the model coordinate system to the camera coordinate system.\n'
    '@param tvec Output translation vector.\n'
    '@param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true '
    '(1), the function uses\n'
    'the provided rvec and tvec values as initial approximations of the '
    'rotation and translation\n'
    'vectors, respectively, and further optimizes them.\n'
    '@param flags Method for solving a PnP problem:\n'
    '-   **SOLVEPNP_ITERATIVE** Iterative method is based on a '
    'Levenberg-Marquardt optimization. In\n'
    'this case the function finds such a pose that minimizes reprojection '
    'error, that is the sum\n'
    'of squared distances between the observed projections imagePoints and the '
    'projected (using\n'
    'projectPoints ) objectPoints .\n'
    '-   **SOLVEPNP_P3P** Method is based on the paper of X.S. Gao, X.-R. Hou, '
    'J. Tang, H.-F. Chang\n'
    '"Complete Solution Classification for the Perspective-Three-Point '
    'Problem" (@cite gao2003complete).\n'
    'In this case the function requires exactly four object and image points.\n'
    '-   **SOLVEPNP_AP3P** Method is based on the paper of T. Ke, S. '
    'Roumeliotis\n'
    '"An Efficient Algebraic Solution to the Perspective-Three-Point Problem" '
    '(@cite Ke17).\n'
    'In this case the function requires exactly four object and image points.\n'
    '-   **SOLVEPNP_EPNP** Method has been introduced by F. Moreno-Noguer, V. '
    'Lepetit and P. Fua in the\n'
    'paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (@cite '
    'lepetit2009epnp).\n'
    '-   **SOLVEPNP_DLS** Method is based on the paper of J. Hesch and S. '
    'Roumeliotis.\n'
    '"A Direct Least-Squares (DLS) Method for PnP" (@cite hesch2011direct).\n'
    '-   **SOLVEPNP_UPNP** Method is based on the paper of A. Penate-Sanchez, '
    'J. Andrade-Cetto,\n'
    'F. Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and '
    'Focal Length\n'
    'Estimation" (@cite penate2013exhaustive). In this case the function also '
    'estimates the parameters \\f$f_x\\f$ and \\f$f_y\\f$\n'
    'assuming that both have the same value. Then the cameraMatrix is updated '
    'with the estimated\n'
    'focal length.\n'
    '-   **SOLVEPNP_IPPE** Method is based on the paper of T. Collins and A. '
    'Bartoli.\n'
    '"Infinitesimal Plane-Based Pose Estimation" (@cite Collins14). This '
    'method requires coplanar object points.\n'
    '-   **SOLVEPNP_IPPE_SQUARE** Method is based on the paper of Toby Collins '
    'and Adrien Bartoli.\n'
    '"Infinitesimal Plane-Based Pose Estimation" (@cite Collins14). This '
    'method is suitable for marker pose estimation.\n'
    'It requires 4 coplanar object points defined in the following order:\n'
    '- point 0: [-squareLength / 2,  squareLength / 2, 0]\n'
    '- point 1: [ squareLength / 2,  squareLength / 2, 0]\n'
    '- point 2: [ squareLength / 2, -squareLength / 2, 0]\n'
    '- point 3: [-squareLength / 2, -squareLength / 2, 0]\n'
    '\n'
    'The function estimates the object pose given a set of object points, '
    'their corresponding image\n'
    'projections, as well as the camera matrix and the distortion '
    'coefficients, see the figure below\n'
    '(more precisely, the X-axis of the camera frame is pointing to the right, '
    'the Y-axis downward\n'
    'and the Z-axis forward).\n'
    '\n'
    '![](pnp.jpg)\n'
    '\n'
    'Points expressed in the world frame \\f$ \\bf{X}_w \\f$ are projected '
    'into the image plane \\f$ \\left[ u, v \\right] \\f$\n'
    'using the perspective projection model \\f$ \\Pi \\f$ and the camera '
    'intrinsic parameters matrix \\f$ \\bf{A} \\f$:\n'
    '\n'
    '\\f[\n'
    '\\begin{align*}\n'
    '\\begin{bmatrix}\n'
    'u \\\\\n'
    'v \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\bf{A} \\hspace{0.1em} \\Pi \\hspace{0.2em} ^{c}\\bf{M}_w\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix} \\\\\n'
    '\\begin{bmatrix}\n'
    'u \\\\\n'
    'v \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\begin{bmatrix}\n'
    'f_x & 0 & c_x \\\\\n'
    '0 & f_y & c_y \\\\\n'
    '0 & 0 & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    '1 & 0 & 0 & 0 \\\\\n'
    '0 & 1 & 0 & 0 \\\\\n'
    '0 & 0 & 1 & 0\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'r_{11} & r_{12} & r_{13} & t_x \\\\\n'
    'r_{21} & r_{22} & r_{23} & t_y \\\\\n'
    'r_{31} & r_{32} & r_{33} & t_z \\\\\n'
    '0 & 0 & 0 & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '\\end{align*}\n'
    '\\f]\n'
    '\n'
    'The estimated pose is thus the rotation (`rvec`) and the translation '
    '(`tvec`) vectors that allow transforming\n'
    'a 3D point expressed in the world frame into the camera frame:\n'
    '\n'
    '\\f[\n'
    '\\begin{align*}\n'
    '\\begin{bmatrix}\n'
    'X_c \\\\\n'
    'Y_c \\\\\n'
    'Z_c \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\hspace{0.2em} ^{c}\\bf{M}_w\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix} \\\\\n'
    '\\begin{bmatrix}\n'
    'X_c \\\\\n'
    'Y_c \\\\\n'
    'Z_c \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\begin{bmatrix}\n'
    'r_{11} & r_{12} & r_{13} & t_x \\\\\n'
    'r_{21} & r_{22} & r_{23} & t_y \\\\\n'
    'r_{31} & r_{32} & r_{33} & t_z \\\\\n'
    '0 & 0 & 0 & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '\\end{align*}\n'
    '\\f]\n'
    '\n'
    '@note\n'
    '-   An example of how to use solvePnP for planar augmented reality can be '
    'found at\n'
    'opencv_source_code/samples/python/plane_ar.py\n'
    '-   If you are using Python:\n'
    "- Numpy array slices won't work as input because solvePnP requires "
    'contiguous\n'
    'arrays (enforced by the assertion using cv::Mat::checkVector() around '
    'line 55 of\n'
    'modules/calib3d/src/solvepnp.cpp version 2.4.9)\n'
    '- The P3P algorithm requires image points to be in an array of shape '
    '(N,1,2) due\n'
    'to its calling of cv::undistortPoints (around line 75 of '
    'modules/calib3d/src/solvepnp.cpp version 2.4.9)\n'
    'which requires 2-channel information.\n'
    '- Thus, given some data D = np.array(...) where D.shape = (N,M), in order '
    'to use a subset of\n'
    'it as, e.g., imagePoints, one must effectively copy it into a new array: '
    'imagePoints =\n'
    'np.ascontiguousarray(D[:,:2]).reshape((N,1,2))\n'
    '-   The methods **SOLVEPNP_DLS** and **SOLVEPNP_UPNP** cannot be used as '
    'the current implementations are\n'
    'unstable and sometimes give completely wrong results. If you pass one of '
    'these two\n'
    'flags, **SOLVEPNP_EPNP** method will be used instead.\n'
    '-   The minimum number of points is 4 in the general case. In the case of '
    '**SOLVEPNP_P3P** and **SOLVEPNP_AP3P**\n'
    'methods, it is required to use exactly 4 points (the first 3 points are '
    'used to estimate all the solutions\n'
    'of the P3P problem, the last one is used to retain the best solution that '
    'minimizes the reprojection error).\n'
    '-   With **SOLVEPNP_ITERATIVE** method and `useExtrinsicGuess=true`, the '
    'minimum number of points is 3 (3 points\n'
    'are sufficient to compute a pose but there are up to 4 solutions). The '
    'initial solution should be close to the\n'
    'global solution to converge.\n'
    '-   With **SOLVEPNP_IPPE** input points must be >= 4 and object points '
    'must be coplanar.\n'
    '-   With **SOLVEPNP_IPPE_SQUARE** this is a special case suitable for '
    'marker pose estimation.\n'
    'Number of input points must be 4. Object points must be defined in the '
    'following order:\n'
    '- point 0: [-squareLength / 2,  squareLength / 2, 0]\n'
    '- point 1: [ squareLength / 2,  squareLength / 2, 0]\n'
    '- point 2: [ squareLength / 2, -squareLength / 2, 0]\n'
    '- point 3: [-squareLength / 2, -squareLength / 2, 0]']
parse_name: cv.solvePnP with ['cv', 'cv::fisheye'] -> fullname:cv::solvePnP namespace:cv classpath: classname: name:solvePnP
register (function) solvePnP (cv_solvePnP__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int)

--- Incoming ---
[   'cv.solvePnPRansac',
    'bool',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['InputArray', 'imagePoints', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['OutputArray', 'rvec', '', []],
        ['OutputArray', 'tvec', '', []],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['int', 'iterationsCount', '100', []],
        ['float', 'reprojectionError', '8.0', []],
        ['double', 'confidence', '0.99', []],
        ['OutputArray', 'inliers', 'noArray()', []],
        ['int', 'flags', 'SOLVEPNP_ITERATIVE', []]],
    None,
    '@brief Finds an object pose from 3D-2D point correspondences using the '
    'RANSAC scheme.\n'
    '\n'
    '@param objectPoints Array of object points in the object coordinate '
    'space, Nx3 1-channel or\n'
    '1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3f\\> '
    'can be also passed here.\n'
    '@param imagePoints Array of corresponding image points, Nx2 1-channel or '
    '1xN/Nx1 2-channel,\n'
    'where N is the number of points. vector\\<Point2f\\> can be also passed '
    'here.\n'
    '@param cameraMatrix Input camera matrix \\f$A = '
    '\\vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are\n'
    'assumed.\n'
    '@param rvec Output rotation vector (see @ref Rodrigues ) that, together '
    'with tvec, brings points from\n'
    'the model coordinate system to the camera coordinate system.\n'
    '@param tvec Output translation vector.\n'
    '@param useExtrinsicGuess Parameter used for @ref SOLVEPNP_ITERATIVE. If '
    'true (1), the function uses\n'
    'the provided rvec and tvec values as initial approximations of the '
    'rotation and translation\n'
    'vectors, respectively, and further optimizes them.\n'
    '@param iterationsCount Number of iterations.\n'
    '@param reprojectionError Inlier threshold value used by the RANSAC '
    'procedure. The parameter value\n'
    'is the maximum allowed distance between the observed and computed point '
    'projections to consider it\n'
    'an inlier.\n'
    '@param confidence The probability that the algorithm produces a useful '
    'result.\n'
    '@param inliers Output vector that contains indices of inliers in '
    'objectPoints and imagePoints .\n'
    '@param flags Method for solving a PnP problem (see @ref solvePnP ).\n'
    '\n'
    'The function estimates an object pose given a set of object points, their '
    'corresponding image\n'
    'projections, as well as the camera matrix and the distortion '
    'coefficients. This function finds such\n'
    'a pose that minimizes reprojection error, that is, the sum of squared '
    'distances between the observed\n'
    'projections imagePoints and the projected (using @ref projectPoints ) '
    'objectPoints. The use of RANSAC\n'
    'makes the function resistant to outliers.\n'
    '\n'
    '@note\n'
    '-   An example of how to use solvePNPRansac for object detection can be '
    'found at\n'
    'opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/\n'
    '-   The default method used to estimate the camera pose for the Minimal '
    'Sample Sets step\n'
    'is #SOLVEPNP_EPNP. Exceptions are:\n'
    '- if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be '
    'used.\n'
    '- if the number of input points is equal to 4, #SOLVEPNP_P3P is used.\n'
    '-   The method used to estimate the camera pose using all the inliers is '
    'defined by the\n'
    'flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. '
    'In this case,\n'
    'the method #SOLVEPNP_EPNP will be used instead.']
parse_name: cv.solvePnPRansac with ['cv', 'cv::fisheye'] -> fullname:cv::solvePnPRansac namespace:cv classpath: classname: name:solvePnPRansac
register (function) solvePnPRansac (cv_solvePnPRansac__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int_float_double__OutputArray_int)

--- Incoming ---
[   'cv.solveP3P',
    'int',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['InputArray', 'imagePoints', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['OutputArrayOfArrays', 'rvecs', '', []],
        ['OutputArrayOfArrays', 'tvecs', '', []],
        ['int', 'flags', '', []]],
    None,
    '@brief Finds an object pose from 3 3D-2D point correspondences.\n'
    '\n'
    '@param objectPoints Array of object points in the object coordinate '
    'space, 3x3 1-channel or\n'
    '1x3/3x1 3-channel. vector\\<Point3f\\> can be also passed here.\n'
    '@param imagePoints Array of corresponding image points, 3x2 1-channel or '
    '1x3/3x1 2-channel.\n'
    'vector\\<Point2f\\> can be also passed here.\n'
    '@param cameraMatrix Input camera matrix \\f$A = '
    '\\vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are\n'
    'assumed.\n'
    '@param rvecs Output rotation vectors (see @ref Rodrigues ) that, together '
    'with tvecs, brings points from\n'
    'the model coordinate system to the camera coordinate system. A P3P '
    'problem has up to 4 solutions.\n'
    '@param tvecs Output translation vectors.\n'
    '@param flags Method for solving a P3P problem:\n'
    '-   **SOLVEPNP_P3P** Method is based on the paper of X.S. Gao, X.-R. Hou, '
    'J. Tang, H.-F. Chang\n'
    '"Complete Solution Classification for the Perspective-Three-Point '
    'Problem" (@cite gao2003complete).\n'
    '-   **SOLVEPNP_AP3P** Method is based on the paper of T. Ke and S. '
    'Roumeliotis.\n'
    '"An Efficient Algebraic Solution to the Perspective-Three-Point Problem" '
    '(@cite Ke17).\n'
    '\n'
    'The function estimates the object pose given 3 object points, their '
    'corresponding image\n'
    'projections, as well as the camera matrix and the distortion '
    'coefficients.\n'
    '\n'
    '@note\n'
    'The solutions are sorted by reprojection errors (lowest to highest).']
parse_name: cv.solveP3P with ['cv', 'cv::fisheye'] -> fullname:cv::solveP3P namespace:cv classpath: classname: name:solveP3P
register (function) solveP3P (cv_solveP3P__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_int)

--- Incoming ---
[   'cv.solvePnPRefineLM',
    'void',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['InputArray', 'imagePoints', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['InputOutputArray', 'rvec', '', []],
        ['InputOutputArray', 'tvec', '', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, '
            'FLT_EPSILON)',
            []]],
    None,
    '@brief Refine a pose (the translation and the rotation that transform a '
    '3D point expressed in the object coordinate frame\n'
    'to the camera coordinate frame) from a 3D-2D point correspondences and '
    'starting from an initial solution.\n'
    '\n'
    '@param objectPoints Array of object points in the object coordinate '
    'space, Nx3 1-channel or 1xN/Nx1 3-channel,\n'
    'where N is the number of points. vector\\<Point3f\\> can also be passed '
    'here.\n'
    '@param imagePoints Array of corresponding image points, Nx2 1-channel or '
    '1xN/Nx1 2-channel,\n'
    'where N is the number of points. vector\\<Point2f\\> can also be passed '
    'here.\n'
    '@param cameraMatrix Input camera matrix \\f$A = '
    '\\vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are\n'
    'assumed.\n'
    '@param rvec Input/Output rotation vector (see @ref Rodrigues ) that, '
    'together with tvec, brings points from\n'
    'the model coordinate system to the camera coordinate system. Input values '
    'are used as an initial solution.\n'
    '@param tvec Input/Output translation vector. Input values are used as an '
    'initial solution.\n'
    '@param criteria Criteria when to stop the Levenberg-Marquard iterative '
    'algorithm.\n'
    '\n'
    'The function refines the object pose given at least 3 object points, '
    'their corresponding image\n'
    'projections, an initial solution for the rotation and translation '
    'vector,\n'
    'as well as the camera matrix and the distortion coefficients.\n'
    'The function minimizes the projection error with respect to the rotation '
    'and the translation vectors, according\n'
    'to a Levenberg-Marquardt iterative minimization @cite Madsen04 @cite '
    'Eade13 process.']
parse_name: cv.solvePnPRefineLM with ['cv', 'cv::fisheye'] -> fullname:cv::solvePnPRefineLM namespace:cv classpath: classname: name:solvePnPRefineLM
register (function) solvePnPRefineLM (cv_solvePnPRefineLM__InputArray__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray_TermCriteria)

--- Incoming ---
[   'cv.solvePnPRefineVVS',
    'void',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['InputArray', 'imagePoints', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['InputOutputArray', 'rvec', '', []],
        ['InputOutputArray', 'tvec', '', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, '
            'FLT_EPSILON)',
            []],
        ['double', 'VVSlambda', '1', []]],
    None,
    '@brief Refine a pose (the translation and the rotation that transform a '
    '3D point expressed in the object coordinate frame\n'
    'to the camera coordinate frame) from a 3D-2D point correspondences and '
    'starting from an initial solution.\n'
    '\n'
    '@param objectPoints Array of object points in the object coordinate '
    'space, Nx3 1-channel or 1xN/Nx1 3-channel,\n'
    'where N is the number of points. vector\\<Point3f\\> can also be passed '
    'here.\n'
    '@param imagePoints Array of corresponding image points, Nx2 1-channel or '
    '1xN/Nx1 2-channel,\n'
    'where N is the number of points. vector\\<Point2f\\> can also be passed '
    'here.\n'
    '@param cameraMatrix Input camera matrix \\f$A = '
    '\\vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are\n'
    'assumed.\n'
    '@param rvec Input/Output rotation vector (see @ref Rodrigues ) that, '
    'together with tvec, brings points from\n'
    'the model coordinate system to the camera coordinate system. Input values '
    'are used as an initial solution.\n'
    '@param tvec Input/Output translation vector. Input values are used as an '
    'initial solution.\n'
    '@param criteria Criteria when to stop the Levenberg-Marquard iterative '
    'algorithm.\n'
    '@param VVSlambda Gain for the virtual visual servoing control law, '
    'equivalent to the \\f$\\alpha\\f$\n'
    'gain in the Damped Gauss-Newton formulation.\n'
    '\n'
    'The function refines the object pose given at least 3 object points, '
    'their corresponding image\n'
    'projections, an initial solution for the rotation and translation '
    'vector,\n'
    'as well as the camera matrix and the distortion coefficients.\n'
    'The function minimizes the projection error with respect to the rotation '
    'and the translation vectors, using a\n'
    'virtual visual servoing (VVS) @cite Chaumette06 @cite Marchand16 scheme.']
parse_name: cv.solvePnPRefineVVS with ['cv', 'cv::fisheye'] -> fullname:cv::solvePnPRefineVVS namespace:cv classpath: classname: name:solvePnPRefineVVS
register (function) solvePnPRefineVVS (cv_solvePnPRefineVVS__InputArray__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray_TermCriteria_double)

--- Incoming ---
[   'cv.solvePnPGeneric',
    'int',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['InputArray', 'imagePoints', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['OutputArrayOfArrays', 'rvecs', '', []],
        ['OutputArrayOfArrays', 'tvecs', '', []],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['SolvePnPMethod', 'flags', 'SOLVEPNP_ITERATIVE', []],
        ['InputArray', 'rvec', 'noArray()', []],
        ['InputArray', 'tvec', 'noArray()', []],
        ['OutputArray', 'reprojectionError', 'noArray()', []]],
    None,
    '@brief Finds an object pose from 3D-2D point correspondences.\n'
    'This function returns a list of all the possible solutions (a solution is '
    'a <rotation vector, translation vector>\n'
    'couple), depending on the number of input points and the chosen method:\n'
    '- P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): 3 or 4 input '
    'points. Number of returned solutions can be between 0 and 4 with 3 input '
    'points.\n'
    '- @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be '
    'coplanar. Returns 2 solutions.\n'
    '- @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose '
    'estimation.\n'
    'Number of input points must be 4 and 2 solutions are returned. Object '
    'points must be defined in the following order:\n'
    '- point 0: [-squareLength / 2,  squareLength / 2, 0]\n'
    '- point 1: [ squareLength / 2,  squareLength / 2, 0]\n'
    '- point 2: [ squareLength / 2, -squareLength / 2, 0]\n'
    '- point 3: [-squareLength / 2, -squareLength / 2, 0]\n'
    '- for all the other flags, number of input points must be >= 4 and object '
    'points can be in any configuration.\n'
    'Only 1 solution is returned.\n'
    '\n'
    '@param objectPoints Array of object points in the object coordinate '
    'space, Nx3 1-channel or\n'
    '1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3f\\> '
    'can be also passed here.\n'
    '@param imagePoints Array of corresponding image points, Nx2 1-channel or '
    '1xN/Nx1 2-channel,\n'
    'where N is the number of points. vector\\<Point2f\\> can be also passed '
    'here.\n'
    '@param cameraMatrix Input camera matrix \\f$A = '
    '\\vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are\n'
    'assumed.\n'
    '@param rvecs Vector of output rotation vectors (see @ref Rodrigues ) '
    'that, together with tvecs, brings points from\n'
    'the model coordinate system to the camera coordinate system.\n'
    '@param tvecs Vector of output translation vectors.\n'
    '@param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true '
    '(1), the function uses\n'
    'the provided rvec and tvec values as initial approximations of the '
    'rotation and translation\n'
    'vectors, respectively, and further optimizes them.\n'
    '@param flags Method for solving a PnP problem:\n'
    '-   **SOLVEPNP_ITERATIVE** Iterative method is based on a '
    'Levenberg-Marquardt optimization. In\n'
    'this case the function finds such a pose that minimizes reprojection '
    'error, that is the sum\n'
    'of squared distances between the observed projections imagePoints and the '
    'projected (using\n'
    'projectPoints ) objectPoints .\n'
    '-   **SOLVEPNP_P3P** Method is based on the paper of X.S. Gao, X.-R. Hou, '
    'J. Tang, H.-F. Chang\n'
    '"Complete Solution Classification for the Perspective-Three-Point '
    'Problem" (@cite gao2003complete).\n'
    'In this case the function requires exactly four object and image points.\n'
    '-   **SOLVEPNP_AP3P** Method is based on the paper of T. Ke, S. '
    'Roumeliotis\n'
    '"An Efficient Algebraic Solution to the Perspective-Three-Point Problem" '
    '(@cite Ke17).\n'
    'In this case the function requires exactly four object and image points.\n'
    '-   **SOLVEPNP_EPNP** Method has been introduced by F.Moreno-Noguer, '
    'V.Lepetit and P.Fua in the\n'
    'paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (@cite '
    'lepetit2009epnp).\n'
    '-   **SOLVEPNP_DLS** Method is based on the paper of Joel A. Hesch and '
    'Stergios I. Roumeliotis.\n'
    '"A Direct Least-Squares (DLS) Method for PnP" (@cite hesch2011direct).\n'
    '-   **SOLVEPNP_UPNP** Method is based on the paper of A.Penate-Sanchez, '
    'J.Andrade-Cetto,\n'
    'F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and '
    'Focal Length\n'
    'Estimation" (@cite penate2013exhaustive). In this case the function also '
    'estimates the parameters \\f$f_x\\f$ and \\f$f_y\\f$\n'
    'assuming that both have the same value. Then the cameraMatrix is updated '
    'with the estimated\n'
    'focal length.\n'
    '-   **SOLVEPNP_IPPE** Method is based on the paper of T. Collins and A. '
    'Bartoli.\n'
    '"Infinitesimal Plane-Based Pose Estimation" (@cite Collins14). This '
    'method requires coplanar object points.\n'
    '-   **SOLVEPNP_IPPE_SQUARE** Method is based on the paper of Toby Collins '
    'and Adrien Bartoli.\n'
    '"Infinitesimal Plane-Based Pose Estimation" (@cite Collins14). This '
    'method is suitable for marker pose estimation.\n'
    'It requires 4 coplanar object points defined in the following order:\n'
    '- point 0: [-squareLength / 2,  squareLength / 2, 0]\n'
    '- point 1: [ squareLength / 2,  squareLength / 2, 0]\n'
    '- point 2: [ squareLength / 2, -squareLength / 2, 0]\n'
    '- point 3: [-squareLength / 2, -squareLength / 2, 0]\n'
    '@param rvec Rotation vector used to initialize an iterative PnP '
    'refinement algorithm, when flag is SOLVEPNP_ITERATIVE\n'
    'and useExtrinsicGuess is set to true.\n'
    '@param tvec Translation vector used to initialize an iterative PnP '
    'refinement algorithm, when flag is SOLVEPNP_ITERATIVE\n'
    'and useExtrinsicGuess is set to true.\n'
    '@param reprojectionError Optional vector of reprojection error, that is '
    'the RMS error\n'
    '(\\f$ \\text{RMSE} = \\sqrt{\\frac{\\sum_{i}^{N} \\left ( \\hat{y_i} - '
    'y_i \\right )^2}{N}} \\f$) between the input image points\n'
    'and the 3D object points projected with the estimated pose.\n'
    '\n'
    'The function estimates the object pose given a set of object points, '
    'their corresponding image\n'
    'projections, as well as the camera matrix and the distortion '
    'coefficients, see the figure below\n'
    '(more precisely, the X-axis of the camera frame is pointing to the right, '
    'the Y-axis downward\n'
    'and the Z-axis forward).\n'
    '\n'
    '![](pnp.jpg)\n'
    '\n'
    'Points expressed in the world frame \\f$ \\bf{X}_w \\f$ are projected '
    'into the image plane \\f$ \\left[ u, v \\right] \\f$\n'
    'using the perspective projection model \\f$ \\Pi \\f$ and the camera '
    'intrinsic parameters matrix \\f$ \\bf{A} \\f$:\n'
    '\n'
    '\\f[\n'
    '\\begin{align*}\n'
    '\\begin{bmatrix}\n'
    'u \\\\\n'
    'v \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\bf{A} \\hspace{0.1em} \\Pi \\hspace{0.2em} ^{c}\\bf{M}_w\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix} \\\\\n'
    '\\begin{bmatrix}\n'
    'u \\\\\n'
    'v \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\begin{bmatrix}\n'
    'f_x & 0 & c_x \\\\\n'
    '0 & f_y & c_y \\\\\n'
    '0 & 0 & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    '1 & 0 & 0 & 0 \\\\\n'
    '0 & 1 & 0 & 0 \\\\\n'
    '0 & 0 & 1 & 0\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'r_{11} & r_{12} & r_{13} & t_x \\\\\n'
    'r_{21} & r_{22} & r_{23} & t_y \\\\\n'
    'r_{31} & r_{32} & r_{33} & t_z \\\\\n'
    '0 & 0 & 0 & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '\\end{align*}\n'
    '\\f]\n'
    '\n'
    'The estimated pose is thus the rotation (`rvec`) and the translation '
    '(`tvec`) vectors that allow transforming\n'
    'a 3D point expressed in the world frame into the camera frame:\n'
    '\n'
    '\\f[\n'
    '\\begin{align*}\n'
    '\\begin{bmatrix}\n'
    'X_c \\\\\n'
    'Y_c \\\\\n'
    'Z_c \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\hspace{0.2em} ^{c}\\bf{M}_w\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix} \\\\\n'
    '\\begin{bmatrix}\n'
    'X_c \\\\\n'
    'Y_c \\\\\n'
    'Z_c \\\\\n'
    '1\n'
    '\\end{bmatrix} &=\n'
    '\\begin{bmatrix}\n'
    'r_{11} & r_{12} & r_{13} & t_x \\\\\n'
    'r_{21} & r_{22} & r_{23} & t_y \\\\\n'
    'r_{31} & r_{32} & r_{33} & t_z \\\\\n'
    '0 & 0 & 0 & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X_{w} \\\\\n'
    'Y_{w} \\\\\n'
    'Z_{w} \\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '\\end{align*}\n'
    '\\f]\n'
    '\n'
    '@note\n'
    '-   An example of how to use solvePnP for planar augmented reality can be '
    'found at\n'
    'opencv_source_code/samples/python/plane_ar.py\n'
    '-   If you are using Python:\n'
    "- Numpy array slices won't work as input because solvePnP requires "
    'contiguous\n'
    'arrays (enforced by the assertion using cv::Mat::checkVector() around '
    'line 55 of\n'
    'modules/calib3d/src/solvepnp.cpp version 2.4.9)\n'
    '- The P3P algorithm requires image points to be in an array of shape '
    '(N,1,2) due\n'
    'to its calling of cv::undistortPoints (around line 75 of '
    'modules/calib3d/src/solvepnp.cpp version 2.4.9)\n'
    'which requires 2-channel information.\n'
    '- Thus, given some data D = np.array(...) where D.shape = (N,M), in order '
    'to use a subset of\n'
    'it as, e.g., imagePoints, one must effectively copy it into a new array: '
    'imagePoints =\n'
    'np.ascontiguousarray(D[:,:2]).reshape((N,1,2))\n'
    '-   The methods **SOLVEPNP_DLS** and **SOLVEPNP_UPNP** cannot be used as '
    'the current implementations are\n'
    'unstable and sometimes give completely wrong results. If you pass one of '
    'these two\n'
    'flags, **SOLVEPNP_EPNP** method will be used instead.\n'
    '-   The minimum number of points is 4 in the general case. In the case of '
    '**SOLVEPNP_P3P** and **SOLVEPNP_AP3P**\n'
    'methods, it is required to use exactly 4 points (the first 3 points are '
    'used to estimate all the solutions\n'
    'of the P3P problem, the last one is used to retain the best solution that '
    'minimizes the reprojection error).\n'
    '-   With **SOLVEPNP_ITERATIVE** method and `useExtrinsicGuess=true`, the '
    'minimum number of points is 3 (3 points\n'
    'are sufficient to compute a pose but there are up to 4 solutions). The '
    'initial solution should be close to the\n'
    'global solution to converge.\n'
    '-   With **SOLVEPNP_IPPE** input points must be >= 4 and object points '
    'must be coplanar.\n'
    '-   With **SOLVEPNP_IPPE_SQUARE** this is a special case suitable for '
    'marker pose estimation.\n'
    'Number of input points must be 4. Object points must be defined in the '
    'following order:\n'
    '- point 0: [-squareLength / 2,  squareLength / 2, 0]\n'
    '- point 1: [ squareLength / 2,  squareLength / 2, 0]\n'
    '- point 2: [ squareLength / 2, -squareLength / 2, 0]\n'
    '- point 3: [-squareLength / 2, -squareLength / 2, 0]']
parse_name: cv.solvePnPGeneric with ['cv', 'cv::fisheye'] -> fullname:cv::solvePnPGeneric namespace:cv classpath: classname: name:solvePnPGeneric
register (function) solvePnPGeneric (cv_solvePnPGeneric__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_SolvePnPMethod__InputArray__InputArray__OutputArray)

--- Incoming ---
[   'cv.initCameraMatrix2D',
    'Mat',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'aspectRatio', '1.0', []]],
    None,
    '@brief Finds an initial camera matrix from 3D-2D point correspondences.\n'
    '\n'
    '@param objectPoints Vector of vectors of the calibration pattern points '
    'in the calibration pattern\n'
    'coordinate space. In the old interface all the per-view vectors are '
    'concatenated. See\n'
    'calibrateCamera for details.\n'
    '@param imagePoints Vector of vectors of the projections of the '
    'calibration pattern points. In the\n'
    'old interface all the per-view vectors are concatenated.\n'
    '@param imageSize Image size in pixels used to initialize the principal '
    'point.\n'
    '@param aspectRatio If it is zero or negative, both \\f$f_x\\f$ and '
    '\\f$f_y\\f$ are estimated independently.\n'
    'Otherwise, \\f$f_x = f_y * \\texttt{aspectRatio}\\f$ .\n'
    '\n'
    'The function estimates and returns an initial camera matrix for the '
    'camera calibration process.\n'
    'Currently, the function only supports planar calibration patterns, which '
    'are patterns where each\n'
    'object point has z-coordinate =0.']
parse_name: cv.initCameraMatrix2D with ['cv', 'cv::fisheye'] -> fullname:cv::initCameraMatrix2D namespace:cv classpath: classname: name:initCameraMatrix2D
register (function) initCameraMatrix2D (cv_initCameraMatrix2D__InputArray__InputArray_Size_double)

--- Incoming ---
[   'cv.findChessboardCorners',
    'bool',
    [],
    [   ['InputArray', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['OutputArray', 'corners', '', []],
        [   'int',
            'flags',
            'CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE',
            []]],
    None,
    '@brief Finds the positions of internal corners of the chessboard.\n'
    '\n'
    '@param image Source chessboard view. It must be an 8-bit grayscale or '
    'color image.\n'
    '@param patternSize Number of inner corners per a chessboard row and '
    'column\n'
    '( patternSize = cv::Size(points_per_row,points_per_colum) = '
    'cv::Size(columns,rows) ).\n'
    '@param corners Output array of detected corners.\n'
    '@param flags Various operation flags that can be zero or a combination of '
    'the following values:\n'
    '-   **CALIB_CB_ADAPTIVE_THRESH** Use adaptive thresholding to convert the '
    'image to black\n'
    'and white, rather than a fixed threshold level (computed from the average '
    'image brightness).\n'
    '-   **CALIB_CB_NORMALIZE_IMAGE** Normalize the image gamma with '
    'equalizeHist before\n'
    'applying fixed or adaptive thresholding.\n'
    '-   **CALIB_CB_FILTER_QUADS** Use additional criteria (like contour area, '
    'perimeter,\n'
    'square-like shape) to filter out false quads extracted at the contour '
    'retrieval stage.\n'
    '-   **CALIB_CB_FAST_CHECK** Run a fast check on the image that looks for '
    'chessboard corners,\n'
    'and shortcut the call if none is found. This can drastically speed up the '
    'call in the\n'
    'degenerate condition when no chessboard is observed.\n'
    '\n'
    'The function attempts to determine whether the input image is a view of '
    'the chessboard pattern and\n'
    'locate the internal chessboard corners. The function returns a non-zero '
    'value if all of the corners\n'
    'are found and they are placed in a certain order (row by row, left to '
    'right in every row).\n'
    'Otherwise, if the function fails to find all the corners or reorder them, '
    'it returns 0. For example,\n'
    'a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that '
    'is, points where the black\n'
    'squares touch each other. The detected coordinates are approximate, and '
    'to determine their positions\n'
    'more accurately, the function calls cornerSubPix. You also may use the '
    'function cornerSubPix with\n'
    'different parameters if returned coordinates are not accurate enough.\n'
    '\n'
    'Sample usage of detecting and drawing chessboard corners: :\n'
    '@code\n'
    'Size patternsize(8,6); //interior number of corners\n'
    'Mat gray = ....; //source image\n'
    'vector<Point2f> corners; //this will be filled by the detected corners\n'
    '\n'
    '//CALIB_CB_FAST_CHECK saves a lot of time on images\n'
    '//that do not contain any chessboard corners\n'
    'bool patternfound = findChessboardCorners(gray, patternsize, corners,\n'
    'CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE\n'
    '+ CALIB_CB_FAST_CHECK);\n'
    '\n'
    'if(patternfound)\n'
    'cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),\n'
    'TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));\n'
    '\n'
    'drawChessboardCorners(img, patternsize, Mat(corners), patternfound);\n'
    '@endcode\n'
    '@note The function requires white space (like a square-thick border, the '
    'wider the better) around\n'
    'the board to make the detection more robust in various environments. '
    'Otherwise, if there is no\n'
    'border and the background is dark, the outer black squares cannot be '
    'segmented properly and so the\n'
    'square grouping and ordering algorithm fails.']
parse_name: cv.findChessboardCorners with ['cv', 'cv::fisheye'] -> fullname:cv::findChessboardCorners namespace:cv classpath: classname: name:findChessboardCorners
register (function) findChessboardCorners (cv_findChessboardCorners__InputArray_Size__OutputArray_int)

--- Incoming ---
[   'cv.checkChessboard',
    'bool',
    [],
    [['InputArray', 'img', '', []], ['Size', 'size', '', []]],
    None,
    '']
parse_name: cv.checkChessboard with ['cv', 'cv::fisheye'] -> fullname:cv::checkChessboard namespace:cv classpath: classname: name:checkChessboard
register (function) checkChessboard (cv_checkChessboard__InputArray_Size)

--- Incoming ---
[   'cv.findChessboardCornersSB',
    'bool',
    [],
    [   ['InputArray', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['OutputArray', 'corners', '', []],
        ['int', 'flags', '0', []]],
    None,
    '@brief Finds the positions of internal corners of the chessboard using a '
    'sector based approach.\n'
    '\n'
    '@param image Source chessboard view. It must be an 8-bit grayscale or '
    'color image.\n'
    '@param patternSize Number of inner corners per a chessboard row and '
    'column\n'
    '( patternSize = cv::Size(points_per_row,points_per_colum) = '
    'cv::Size(columns,rows) ).\n'
    '@param corners Output array of detected corners.\n'
    '@param flags Various operation flags that can be zero or a combination of '
    'the following values:\n'
    '-   **CALIB_CB_NORMALIZE_IMAGE** Normalize the image gamma with '
    'equalizeHist before detection.\n'
    '-   **CALIB_CB_EXHAUSTIVE** Run an exhaustive search to improve detection '
    'rate.\n'
    '-   **CALIB_CB_ACCURACY** Up sample input image to improve sub-pixel '
    'accuracy due to aliasing effects.\n'
    'This should be used if an accurate camera calibration is required.\n'
    '\n'
    'The function is analog to findchessboardCorners but uses a localized '
    'radon\n'
    'transformation approximated by box filters being more robust to all sort '
    'of\n'
    'noise, faster on larger images and is able to directly return the '
    'sub-pixel\n'
    'position of the internal chessboard corners. The Method is based on the '
    'paper\n'
    '@cite duda2018 "Accurate Detection and Localization of Checkerboard '
    'Corners for\n'
    'Calibration" demonstrating that the returned sub-pixel positions are '
    'more\n'
    'accurate than the one returned by cornerSubPix allowing a precise camera\n'
    'calibration for demanding applications.\n'
    '\n'
    '@note The function requires a white boarder with roughly the same width '
    'as one\n'
    'of the checkerboard fields around the whole board to improve the '
    'detection in\n'
    'various environments. In addition, because of the localized radon\n'
    'transformation it is beneficial to use round corners for the field '
    'corners\n'
    'which are located on the outside of the board. The following figure '
    'illustrates\n'
    'a sample checkerboard optimized for the detection. However, any other '
    'checkerboard\n'
    'can be used as well.\n'
    '![Checkerboard](pics/checkerboard_radon.png)']
parse_name: cv.findChessboardCornersSB with ['cv', 'cv::fisheye'] -> fullname:cv::findChessboardCornersSB namespace:cv classpath: classname: name:findChessboardCornersSB
register (function) findChessboardCornersSB (cv_findChessboardCornersSB__InputArray_Size__OutputArray_int)

--- Incoming ---
[   'cv.find4QuadCornerSubpix',
    'bool',
    [],
    [   ['InputArray', 'img', '', []],
        ['InputOutputArray', 'corners', '', []],
        ['Size', 'region_size', '', []]],
    None,
    'finds subpixel-accurate positions of the chessboard corners']
parse_name: cv.find4QuadCornerSubpix with ['cv', 'cv::fisheye'] -> fullname:cv::find4QuadCornerSubpix namespace:cv classpath: classname: name:find4QuadCornerSubpix
register (function) find4QuadCornerSubpix (cv_find4QuadCornerSubpix__InputArray__InputOutputArray_Size)

--- Incoming ---
[   'cv.drawChessboardCorners',
    'void',
    [],
    [   ['InputOutputArray', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['InputArray', 'corners', '', []],
        ['bool', 'patternWasFound', '', []]],
    None,
    '@brief Renders the detected chessboard corners.\n'
    '\n'
    '@param image Destination image. It must be an 8-bit color image.\n'
    '@param patternSize Number of inner corners per a chessboard row and '
    'column\n'
    '(patternSize = cv::Size(points_per_row,points_per_column)).\n'
    '@param corners Array of detected corners, the output of '
    'findChessboardCorners.\n'
    '@param patternWasFound Parameter indicating whether the complete board '
    'was found or not. The\n'
    'return value of findChessboardCorners should be passed here.\n'
    '\n'
    'The function draws individual chessboard corners detected either as red '
    'circles if the board was not\n'
    'found, or as colored corners connected with lines if the board was found.']
parse_name: cv.drawChessboardCorners with ['cv', 'cv::fisheye'] -> fullname:cv::drawChessboardCorners namespace:cv classpath: classname: name:drawChessboardCorners
register (function) drawChessboardCorners (cv_drawChessboardCorners__InputOutputArray_Size__InputArray_bool)

--- Incoming ---
[   'cv.drawFrameAxes',
    'void',
    [],
    [   ['InputOutputArray', 'image', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['InputArray', 'rvec', '', []],
        ['InputArray', 'tvec', '', []],
        ['float', 'length', '', []],
        ['int', 'thickness', '3', []]],
    None,
    '@brief Draw axes of the world/object coordinate system from pose '
    'estimation. @sa solvePnP\n'
    '\n'
    '@param image Input/output image. It must have 1 or 3 channels. The number '
    'of channels is not altered.\n'
    '@param cameraMatrix Input 3x3 floating-point matrix of camera intrinsic '
    'parameters.\n'
    '\\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is empty, the zero distortion '
    'coefficients are assumed.\n'
    '@param rvec Rotation vector (see @ref Rodrigues ) that, together with '
    'tvec, brings points from\n'
    'the model coordinate system to the camera coordinate system.\n'
    '@param tvec Translation vector.\n'
    '@param length Length of the painted axes in the same unit than tvec '
    '(usually in meters).\n'
    '@param thickness Line thickness of the painted axes.\n'
    '\n'
    'This function draws the axes of the world/object coordinate system w.r.t. '
    'to the camera frame.\n'
    'OX is drawn in red, OY in green and OZ in blue.']
parse_name: cv.drawFrameAxes with ['cv', 'cv::fisheye'] -> fullname:cv::drawFrameAxes namespace:cv classpath: classname: name:drawFrameAxes
register (function) drawFrameAxes (cv_drawFrameAxes__InputOutputArray__InputArray__InputArray__InputArray__InputArray_float_int)

--- Incoming ---
[   'struct cv.CirclesGridFinderParameters',
    '',
    ['/Simple'],
    [   ['Size2f', 'densityNeighborhoodSize', '', ['/RW']],
        ['float', 'minDensity', '', ['/RW']],
        ['int', 'kmeansAttempts', '', ['/RW']],
        ['int', 'minDistanceToAddKeypoint', '', ['/RW']],
        ['int', 'keypointScale', '', ['/RW']],
        ['float', 'minGraphConfidence', '', ['/RW']],
        ['float', 'vertexGain', '', ['/RW']],
        ['float', 'vertexPenalty', '', ['/RW']],
        ['float', 'existingVertexGain', '', ['/RW']],
        ['float', 'edgeGain', '', ['/RW']],
        ['float', 'edgePenalty', '', ['/RW']],
        ['float', 'convexHullFactor', '', ['/RW']],
        ['float', 'minRNGEdgeSwitchDist', '', ['/RW']],
        [   'float',
            'squareSize',
            'Distance between two adjacent points. Used by '
            'CALIB_CB_CLUSTERING.',
            ['/RW']],
        [   'float',
            'maxRectifiedDistance',
            'Max deviation from predicion. Used by CALIB_CB_CLUSTERING.',
            ['/RW']]],
    None,
    '']
parse_name: struct cv.CirclesGridFinderParameters with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters namespace:cv classpath: classname: name:CirclesGridFinderParameters
register class cv::CirclesGridFinderParameters (['struct cv.CirclesGridFinderParameters', '', ['/Simple'], [['Size2f', 'densityNeighborhoodSize', '', ['/RW']], ['float', 'minDensity', '', ['/RW']], ['int', 'kmeansAttempts', '', ['/RW']], ['int', 'minDistanceToAddKeypoint', '', ['/RW']], ['int', 'keypointScale', '', ['/RW']], ['float', 'minGraphConfidence', '', ['/RW']], ['float', 'vertexGain', '', ['/RW']], ['float', 'vertexPenalty', '', ['/RW']], ['float', 'existingVertexGain', '', ['/RW']], ['float', 'edgeGain', '', ['/RW']], ['float', 'edgePenalty', '', ['/RW']], ['float', 'convexHullFactor', '', ['/RW']], ['float', 'minRNGEdgeSwitchDist', '', ['/RW']], ['float', 'squareSize', 'Distance between two adjacent points. Used by CALIB_CB_CLUSTERING.', ['/RW']], ['float', 'maxRectifiedDistance', 'Max deviation from predicion. Used by CALIB_CB_CLUSTERING.', ['/RW']]], None, ''])

--- Incoming ---
[   'cv.CirclesGridFinderParameters.CirclesGridFinderParameters',
    'C',
    [],
    [],
    None,
    '']
parse_name: cv.CirclesGridFinderParameters.CirclesGridFinderParameters with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters::CirclesGridFinderParameters namespace:cv classpath:CirclesGridFinderParameters classname:CirclesGridFinderParameters name:CirclesGridFinderParameters
register (constructor) default in cv::CirclesGridFinderParameters (simple) (cv_CirclesGridFinderParameters_CirclesGridFinderParameters)

--- Incoming ---
[   'enum cv.CirclesGridFinderParameters.GridType',
    '',
    [],
    [   [   'const cv.CirclesGridFinderParameters.SYMMETRIC_GRID',
            '0',
            [],
            [],
            None,
            ''],
        [   'const cv.CirclesGridFinderParameters.ASYMMETRIC_GRID',
            '1',
            [],
            [],
            None,
            '']],
    None,
    '']
parse_name: const cv.CirclesGridFinderParameters.SYMMETRIC_GRID with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters::SYMMETRIC_GRID namespace:cv classpath:CirclesGridFinderParameters classname:CirclesGridFinderParameters name:SYMMETRIC_GRID
parse_name: const cv.CirclesGridFinderParameters.ASYMMETRIC_GRID with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters::ASYMMETRIC_GRID namespace:cv classpath:CirclesGridFinderParameters classname:CirclesGridFinderParameters name:ASYMMETRIC_GRID
parse_name: enum cv.CirclesGridFinderParameters.GridType with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters::GridType namespace:cv classpath:CirclesGridFinderParameters classname:CirclesGridFinderParameters name:GridType
parse_name: const cv.CirclesGridFinderParameters.SYMMETRIC_GRID with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters::SYMMETRIC_GRID namespace:cv classpath:CirclesGridFinderParameters classname:CirclesGridFinderParameters name:SYMMETRIC_GRID
parse_name: const cv.CirclesGridFinderParameters.ASYMMETRIC_GRID with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters::ASYMMETRIC_GRID namespace:cv classpath:CirclesGridFinderParameters classname:CirclesGridFinderParameters name:ASYMMETRIC_GRID

--- Incoming ---
[   'typedef cv.CirclesGridFinderParameters2',
    'CirclesGridFinderParameters',
    '',
    [],
    None,
    '']
parse_name: typedef cv.CirclesGridFinderParameters2 with ['cv', 'cv::fisheye'] -> fullname:cv::CirclesGridFinderParameters2 namespace:cv classpath: classname: name:CirclesGridFinderParameters2
Registering an unknown type: CirclesGridFinderParameters2

--- Incoming ---
[   'cv.findCirclesGrid',
    'bool',
    [],
    [   ['InputArray', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['OutputArray', 'centers', '', []],
        ['int', 'flags', '', []],
        ['const Ptr<FeatureDetector> &', 'blobDetector', '', []],
        ['const CirclesGridFinderParameters&', 'parameters', '', []]],
    None,
    '@brief Finds centers in the grid of circles.\n'
    '\n'
    '@param image grid view of input circles; it must be an 8-bit grayscale or '
    'color image.\n'
    '@param patternSize number of circles per row and column\n'
    '( patternSize = Size(points_per_row, points_per_colum) ).\n'
    '@param centers output array of detected centers.\n'
    '@param flags various operation flags that can be one of the following '
    'values:\n'
    '-   **CALIB_CB_SYMMETRIC_GRID** uses symmetric pattern of circles.\n'
    '-   **CALIB_CB_ASYMMETRIC_GRID** uses asymmetric pattern of circles.\n'
    '-   **CALIB_CB_CLUSTERING** uses a special algorithm for grid detection. '
    'It is more robust to\n'
    'perspective distortions but much more sensitive to background clutter.\n'
    '@param blobDetector feature detector that finds blobs like dark circles '
    'on light background.\n'
    '@param parameters struct for finding circles in a grid pattern.\n'
    '\n'
    'The function attempts to determine whether the input image contains a '
    'grid of circles. If it is, the\n'
    'function locates centers of the circles. The function returns a non-zero '
    'value if all of the centers\n'
    'have been found and they have been placed in a certain order (row by row, '
    'left to right in every\n'
    'row). Otherwise, if the function fails to find all the corners or reorder '
    'them, it returns 0.\n'
    '\n'
    'Sample usage of detecting and drawing the centers of circles: :\n'
    '@code\n'
    'Size patternsize(7,7); //number of centers\n'
    'Mat gray = ....; //source image\n'
    'vector<Point2f> centers; //this will be filled by the detected centers\n'
    '\n'
    'bool patternfound = findCirclesGrid(gray, patternsize, centers);\n'
    '\n'
    'drawChessboardCorners(img, patternsize, Mat(centers), patternfound);\n'
    '@endcode\n'
    '@note The function requires white space (like a square-thick border, the '
    'wider the better) around\n'
    'the board to make the detection more robust in various environments.']
parse_name: cv.findCirclesGrid with ['cv', 'cv::fisheye'] -> fullname:cv::findCirclesGrid namespace:cv classpath: classname: name:findCirclesGrid
register (function) findCirclesGrid (cv_findCirclesGrid__InputArray_Size__OutputArray_int_PtrOfFeature2D_CirclesGridFinderParameters)

--- Incoming ---
[   'cv.findCirclesGrid',
    'bool',
    [],
    [   ['InputArray', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['OutputArray', 'centers', '', []],
        ['int', 'flags', 'CALIB_CB_SYMMETRIC_GRID', []],
        [   'const Ptr<FeatureDetector> &',
            'blobDetector',
            'SimpleBlobDetector::create()',
            []]],
    None,
    '@overload']
parse_name: cv.findCirclesGrid with ['cv', 'cv::fisheye'] -> fullname:cv::findCirclesGrid namespace:cv classpath: classname: name:findCirclesGrid
register (function) findCirclesGrid (cv_findCirclesGrid__InputArray_Size__OutputArray_int_PtrOfFeature2D)

--- Incoming ---
[   'cv.calibrateCamera',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['InputOutputArray', 'cameraMatrix', '', []],
        ['InputOutputArray', 'distCoeffs', '', []],
        ['OutputArrayOfArrays', 'rvecs', '', []],
        ['OutputArrayOfArrays', 'tvecs', '', []],
        ['OutputArray', 'stdDeviationsIntrinsics', '', []],
        ['OutputArray', 'stdDeviationsExtrinsics', '', []],
        ['OutputArray', 'perViewErrors', '', []],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    None,
    '@brief Finds the camera intrinsic and extrinsic parameters from several '
    'views of a calibration pattern.\n'
    '\n'
    '@param objectPoints In the new interface it is a vector of vectors of '
    'calibration pattern points in\n'
    'the calibration pattern coordinate space (e.g. '
    'std::vector<std::vector<cv::Vec3f>>). The outer\n'
    'vector contains as many elements as the number of the pattern views. If '
    'the same calibration pattern\n'
    'is shown in each view and it is fully visible, all the vectors will be '
    'the same. Although, it is\n'
    'possible to use partially occluded patterns, or even different patterns '
    'in different views. Then,\n'
    'the vectors will be different. The points are 3D, but since they are in a '
    'pattern coordinate system,\n'
    'then, if the rig is planar, it may make sense to put the model to a XY '
    'coordinate plane so that\n'
    'Z-coordinate of each input object point is 0.\n'
    'In the old interface all the vectors of object points from different '
    'views are concatenated\n'
    'together.\n'
    '@param imagePoints In the new interface it is a vector of vectors of the '
    'projections of calibration\n'
    'pattern points (e.g. std::vector<std::vector<cv::Vec2f>>). '
    'imagePoints.size() and\n'
    'objectPoints.size() and imagePoints[i].size() must be equal to '
    'objectPoints[i].size() for each i.\n'
    'In the old interface all the vectors of object points from different '
    'views are concatenated\n'
    'together.\n'
    '@param imageSize Size of the image used only to initialize the intrinsic '
    'camera matrix.\n'
    '@param cameraMatrix Output 3x3 floating-point camera matrix\n'
    '\\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . If '
    'CV\\_CALIB\\_USE\\_INTRINSIC\\_GUESS\n'
    'and/or CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, '
    'cy must be\n'
    'initialized before calling the function.\n'
    '@param distCoeffs Output vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements.\n'
    '@param rvecs Output vector of rotation vectors (see Rodrigues ) estimated '
    'for each pattern view\n'
    '(e.g. std::vector<cv::Mat>>). That is, each k-th rotation vector together '
    'with the corresponding\n'
    'k-th translation vector (see the next output parameter description) '
    'brings the calibration pattern\n'
    'from the model coordinate space (in which object points are specified) to '
    'the world coordinate\n'
    'space, that is, a real position of the calibration pattern in the k-th '
    'pattern view (k=0.. *M* -1).\n'
    '@param tvecs Output vector of translation vectors estimated for each '
    'pattern view.\n'
    '@param stdDeviationsIntrinsics Output vector of standard deviations '
    'estimated for intrinsic parameters.\n'
    'Order of deviations values:\n'
    '\\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, '
    's_2, s_3,\n'
    "s_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's "
    'deviation is equals to zero.\n'
    '@param stdDeviationsExtrinsics Output vector of standard deviations '
    'estimated for extrinsic parameters.\n'
    'Order of deviations values: \\f$(R_1, T_1, \\dotsc , R_M, T_M)\\f$ where '
    'M is number of pattern views,\n'
    '\\f$R_i, T_i\\f$ are concatenated 1x3 vectors.\n'
    '@param perViewErrors Output vector of the RMS re-projection error '
    'estimated for each pattern view.\n'
    '@param flags Different flags that may be zero or a combination of the '
    'following values:\n'
    '-   **CALIB_USE_INTRINSIC_GUESS** cameraMatrix contains valid initial '
    'values of\n'
    'fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is '
    'initially set to the image\n'
    'center ( imageSize is used), and focal distances are computed in a '
    'least-squares fashion.\n'
    'Note, that if intrinsic parameters are known, there is no need to use '
    'this function just to\n'
    'estimate extrinsic parameters. Use solvePnP instead.\n'
    '-   **CALIB_FIX_PRINCIPAL_POINT** The principal point is not changed '
    'during the global\n'
    'optimization. It stays at the center or at a different location specified '
    'when\n'
    'CALIB_USE_INTRINSIC_GUESS is set too.\n'
    '-   **CALIB_FIX_ASPECT_RATIO** The functions considers only fy as a free '
    'parameter. The\n'
    'ratio fx/fy stays the same as in the input cameraMatrix . When\n'
    'CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and '
    'fy are\n'
    'ignored, only their ratio is computed and used further.\n'
    '-   **CALIB_ZERO_TANGENT_DIST** Tangential distortion coefficients '
    '\\f$(p_1, p_2)\\f$ are set\n'
    'to zeros and stay zero.\n'
    '-   **CALIB_FIX_K1,...,CALIB_FIX_K6** The corresponding radial '
    'distortion\n'
    'coefficient is not changed during the optimization. If '
    'CALIB_USE_INTRINSIC_GUESS is\n'
    'set, the coefficient from the supplied distCoeffs matrix is used. '
    'Otherwise, it is set to 0.\n'
    '-   **CALIB_RATIONAL_MODEL** Coefficients k4, k5, and k6 are enabled. To '
    'provide the\n'
    'backward compatibility, this extra flag should be explicitly specified to '
    'make the\n'
    'calibration function use the rational model and return 8 coefficients. If '
    'the flag is not\n'
    'set, the function computes and returns only 5 distortion coefficients.\n'
    '-   **CALIB_THIN_PRISM_MODEL** Coefficients s1, s2, s3 and s4 are '
    'enabled. To provide the\n'
    'backward compatibility, this extra flag should be explicitly specified to '
    'make the\n'
    'calibration function use the thin prism model and return 12 coefficients. '
    'If the flag is not\n'
    'set, the function computes and returns only 5 distortion coefficients.\n'
    '-   **CALIB_FIX_S1_S2_S3_S4** The thin prism distortion coefficients are '
    'not changed during\n'
    'the optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient '
    'from the\n'
    'supplied distCoeffs matrix is used. Otherwise, it is set to 0.\n'
    '-   **CALIB_TILTED_MODEL** Coefficients tauX and tauY are enabled. To '
    'provide the\n'
    'backward compatibility, this extra flag should be explicitly specified to '
    'make the\n'
    'calibration function use the tilted sensor model and return 14 '
    'coefficients. If the flag is not\n'
    'set, the function computes and returns only 5 distortion coefficients.\n'
    '-   **CALIB_FIX_TAUX_TAUY** The coefficients of the tilted sensor model '
    'are not changed during\n'
    'the optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient '
    'from the\n'
    'supplied distCoeffs matrix is used. Otherwise, it is set to 0.\n'
    '@param criteria Termination criteria for the iterative optimization '
    'algorithm.\n'
    '\n'
    '@return the overall RMS re-projection error.\n'
    '\n'
    'The function estimates the intrinsic camera parameters and extrinsic '
    'parameters for each of the\n'
    'views. The algorithm is based on @cite Zhang2000 and @cite BouguetMCT . '
    'The coordinates of 3D object\n'
    'points and their corresponding 2D projections in each view must be '
    'specified. That may be achieved\n'
    'by using an object with a known geometry and easily detectable feature '
    'points. Such an object is\n'
    'called a calibration rig or calibration pattern, and OpenCV has built-in '
    'support for a chessboard as\n'
    'a calibration rig (see findChessboardCorners ). Currently, initialization '
    'of intrinsic parameters\n'
    '(when CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for '
    'planar calibration\n'
    'patterns (where Z-coordinates of the object points must be all zeros). 3D '
    'calibration rigs can also\n'
    'be used as long as initial cameraMatrix is provided.\n'
    '\n'
    'The algorithm performs the following steps:\n'
    '\n'
    '-   Compute the initial intrinsic parameters (the option only available '
    'for planar calibration\n'
    'patterns) or read them from the input parameters. The distortion '
    'coefficients are all set to\n'
    'zeros initially unless some of CALIB_FIX_K? are specified.\n'
    '\n'
    '-   Estimate the initial camera pose as if the intrinsic parameters have '
    'been already known. This is\n'
    'done using solvePnP .\n'
    '\n'
    '-   Run the global Levenberg-Marquardt optimization algorithm to minimize '
    'the reprojection error,\n'
    'that is, the total sum of squared distances between the observed feature '
    'points imagePoints and\n'
    'the projected (using the current estimates for camera parameters and the '
    'poses) object points\n'
    'objectPoints. See projectPoints for details.\n'
    '\n'
    '@note\n'
    'If you use a non-square (=non-NxN) grid and findChessboardCorners for '
    'calibration, and\n'
    'calibrateCamera returns bad values (zero distortion coefficients, an '
    'image center very far from\n'
    '(w/2-0.5,h/2-0.5), and/or large differences between \\f$f_x\\f$ and '
    '\\f$f_y\\f$ (ratios of 10:1 or more)),\n'
    'then you have probably used patternSize=cvSize(rows,cols) instead of '
    'using\n'
    'patternSize=cvSize(cols,rows) in findChessboardCorners .\n'
    '\n'
    '@sa\n'
    'calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, '
    'stereoCalibrate, undistort']
parse_name: cv.calibrateCamera with ['cv', 'cv::fisheye'] -> fullname:cv::calibrateCamera namespace:cv classpath: classname: name:calibrateCamera
register (function) calibrateCamera (cv_calibrateCamera__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
[   'cv.calibrateCamera',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['InputOutputArray', 'cameraMatrix', '', []],
        ['InputOutputArray', 'distCoeffs', '', []],
        ['OutputArrayOfArrays', 'rvecs', '', []],
        ['OutputArrayOfArrays', 'tvecs', '', []],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    None,
    '@overload']
parse_name: cv.calibrateCamera with ['cv', 'cv::fisheye'] -> fullname:cv::calibrateCamera namespace:cv classpath: classname: name:calibrateCamera
register (function) calibrateCamera (cv_calibrateCamera__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
[   'cv.calibrateCameraRO',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['int', 'iFixedPoint', '', []],
        ['InputOutputArray', 'cameraMatrix', '', []],
        ['InputOutputArray', 'distCoeffs', '', []],
        ['OutputArrayOfArrays', 'rvecs', '', []],
        ['OutputArrayOfArrays', 'tvecs', '', []],
        ['OutputArray', 'newObjPoints', '', []],
        ['OutputArray', 'stdDeviationsIntrinsics', '', []],
        ['OutputArray', 'stdDeviationsExtrinsics', '', []],
        ['OutputArray', 'stdDeviationsObjPoints', '', []],
        ['OutputArray', 'perViewErrors', '', []],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    None,
    '@brief Finds the camera intrinsic and extrinsic parameters from several '
    'views of a calibration pattern.\n'
    '\n'
    'This function is an extension of calibrateCamera() with the method of '
    'releasing object which was\n'
    'proposed in @cite strobl2011iccv. In many common cases with inaccurate, '
    'unmeasured, roughly planar\n'
    'targets (calibration plates), this method can dramatically improve the '
    'precision of the estimated\n'
    'camera parameters. Both the object-releasing method and standard method '
    'are supported by this\n'
    'function. Use the parameter **iFixedPoint** for method selection. In the '
    'internal implementation,\n'
    'calibrateCamera() is a wrapper for this function.\n'
    '\n'
    '@param objectPoints Vector of vectors of calibration pattern points in '
    'the calibration pattern\n'
    'coordinate space. See calibrateCamera() for details. If the method of '
    'releasing object to be used,\n'
    'the identical calibration board must be used in each view and it must be '
    'fully visible, and all\n'
    'objectPoints[i] must be the same and all points should be roughly close '
    'to a plane. **The calibration\n'
    'target has to be rigid, or at least static if the camera (rather than the '
    'calibration target) is\n'
    'shifted for grabbing images.**\n'
    '@param imagePoints Vector of vectors of the projections of calibration '
    'pattern points. See\n'
    'calibrateCamera() for details.\n'
    '@param imageSize Size of the image used only to initialize the intrinsic '
    'camera matrix.\n'
    '@param iFixedPoint The index of the 3D object point in objectPoints[0] to '
    'be fixed. It also acts as\n'
    'a switch for calibration method selection. If object-releasing method to '
    'be used, pass in the\n'
    'parameter in the range of [1, objectPoints[0].size()-2], otherwise a '
    'value out of this range will\n'
    'make standard calibration method selected. Usually the top-right corner '
    'point of the calibration\n'
    'board grid is recommended to be fixed when object-releasing method being '
    'utilized. According to\n'
    '\\cite strobl2011iccv, two other points are also fixed. In this '
    'implementation, objectPoints[0].front\n'
    'and objectPoints[0].back.z are used. With object-releasing method, '
    'accurate rvecs, tvecs and\n'
    'newObjPoints are only possible if coordinates of these three fixed points '
    'are accurate enough.\n'
    '@param cameraMatrix Output 3x3 floating-point camera matrix. See '
    'calibrateCamera() for details.\n'
    '@param distCoeffs Output vector of distortion coefficients. See '
    'calibrateCamera() for details.\n'
    '@param rvecs Output vector of rotation vectors estimated for each pattern '
    'view. See calibrateCamera()\n'
    'for details.\n'
    '@param tvecs Output vector of translation vectors estimated for each '
    'pattern view.\n'
    '@param newObjPoints The updated output vector of calibration pattern '
    'points. The coordinates might\n'
    'be scaled based on three fixed points. The returned coordinates are '
    'accurate only if the above\n'
    'mentioned three fixed points are accurate. If not needed, noArray() can '
    'be passed in. This parameter\n'
    'is ignored with standard calibration method.\n'
    '@param stdDeviationsIntrinsics Output vector of standard deviations '
    'estimated for intrinsic parameters.\n'
    'See calibrateCamera() for details.\n'
    '@param stdDeviationsExtrinsics Output vector of standard deviations '
    'estimated for extrinsic parameters.\n'
    'See calibrateCamera() for details.\n'
    '@param stdDeviationsObjPoints Output vector of standard deviations '
    'estimated for refined coordinates\n'
    'of calibration pattern points. It has the same size and order as '
    'objectPoints[0] vector. This\n'
    'parameter is ignored with standard calibration method.\n'
    '@param perViewErrors Output vector of the RMS re-projection error '
    'estimated for each pattern view.\n'
    '@param flags Different flags that may be zero or a combination of some '
    'predefined values. See\n'
    'calibrateCamera() for details. If the method of releasing object is used, '
    'the calibration time may\n'
    'be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster '
    'calibration with potentially\n'
    'less precise and less stable in some rare cases.\n'
    '@param criteria Termination criteria for the iterative optimization '
    'algorithm.\n'
    '\n'
    '@return the overall RMS re-projection error.\n'
    '\n'
    'The function estimates the intrinsic camera parameters and extrinsic '
    'parameters for each of the\n'
    'views. The algorithm is based on @cite Zhang2000, @cite BouguetMCT and '
    '@cite strobl2011iccv. See\n'
    'calibrateCamera() for other detailed explanations.\n'
    '@sa\n'
    'calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, '
    'stereoCalibrate, undistort']
parse_name: cv.calibrateCameraRO with ['cv', 'cv::fisheye'] -> fullname:cv::calibrateCameraRO namespace:cv classpath: classname: name:calibrateCameraRO
register (function) calibrateCameraRO (cv_calibrateCameraRO__InputArray__InputArray_Size_int__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
[   'cv.calibrateCameraRO',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['int', 'iFixedPoint', '', []],
        ['InputOutputArray', 'cameraMatrix', '', []],
        ['InputOutputArray', 'distCoeffs', '', []],
        ['OutputArrayOfArrays', 'rvecs', '', []],
        ['OutputArrayOfArrays', 'tvecs', '', []],
        ['OutputArray', 'newObjPoints', '', []],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    None,
    '@overload']
parse_name: cv.calibrateCameraRO with ['cv', 'cv::fisheye'] -> fullname:cv::calibrateCameraRO namespace:cv classpath: classname: name:calibrateCameraRO
register (function) calibrateCameraRO (cv_calibrateCameraRO__InputArray__InputArray_Size_int__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
[   'cv.calibrationMatrixValues',
    'void',
    [],
    [   ['InputArray', 'cameraMatrix', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'apertureWidth', '', []],
        ['double', 'apertureHeight', '', []],
        ['double&', 'fovx', '', []],
        ['double&', 'fovy', '', []],
        ['double&', 'focalLength', '', []],
        ['Point2d&', 'principalPoint', '', []],
        ['double&', 'aspectRatio', '', []]],
    None,
    '@brief Computes useful camera characteristics from the camera matrix.\n'
    '\n'
    '@param cameraMatrix Input camera matrix that can be estimated by '
    'calibrateCamera or\n'
    'stereoCalibrate .\n'
    '@param imageSize Input image size in pixels.\n'
    '@param apertureWidth Physical width in mm of the sensor.\n'
    '@param apertureHeight Physical height in mm of the sensor.\n'
    '@param fovx Output field of view in degrees along the horizontal sensor '
    'axis.\n'
    '@param fovy Output field of view in degrees along the vertical sensor '
    'axis.\n'
    '@param focalLength Focal length of the lens in mm.\n'
    '@param principalPoint Principal point in mm.\n'
    '@param aspectRatio \\f$f_y/f_x\\f$\n'
    '\n'
    'The function computes various useful camera characteristics from the '
    'previously estimated camera\n'
    'matrix.\n'
    '\n'
    '@note\n'
    "Do keep in mind that the unity measure 'mm' stands for whatever unit of "
    'measure one chooses for\n'
    'the chessboard pitch (it can thus be any value).']
parse_name: cv.calibrationMatrixValues with ['cv', 'cv::fisheye'] -> fullname:cv::calibrationMatrixValues namespace:cv classpath: classname: name:calibrationMatrixValues
register (function) calibrationMatrixValues (cv_calibrationMatrixValues__InputArray_Size_double_double_double_double_double_Point2d_double)

--- Incoming ---
[   'cv.stereoCalibrate',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints1', '', []],
        ['InputArrayOfArrays', 'imagePoints2', '', []],
        ['InputOutputArray', 'cameraMatrix1', '', []],
        ['InputOutputArray', 'distCoeffs1', '', []],
        ['InputOutputArray', 'cameraMatrix2', '', []],
        ['InputOutputArray', 'distCoeffs2', '', []],
        ['Size', 'imageSize', '', []],
        ['InputOutputArray', 'R', '', []],
        ['InputOutputArray', 'T', '', []],
        ['OutputArray', 'E', '', []],
        ['OutputArray', 'F', '', []],
        ['OutputArray', 'perViewErrors', '', []],
        ['int', 'flags', 'CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    None,
    '@brief Calibrates the stereo camera.\n'
    '\n'
    '@param objectPoints Vector of vectors of the calibration pattern points.\n'
    '@param imagePoints1 Vector of vectors of the projections of the '
    'calibration pattern points,\n'
    'observed by the first camera.\n'
    '@param imagePoints2 Vector of vectors of the projections of the '
    'calibration pattern points,\n'
    'observed by the second camera.\n'
    '@param cameraMatrix1 Input/output first camera matrix:\n'
    '\\f$\\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\\f$ '
    ', \\f$j = 0,\\, 1\\f$ . If\n'
    'any of CALIB_USE_INTRINSIC_GUESS , CALIB_FIX_ASPECT_RATIO ,\n'
    'CALIB_FIX_INTRINSIC , or CALIB_FIX_FOCAL_LENGTH are specified, some or '
    'all of the\n'
    'matrix components must be initialized. See the flags description for '
    'details.\n'
    '@param distCoeffs1 Input/output vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. The output vector length depends on the '
    'flags.\n'
    '@param cameraMatrix2 Input/output second camera matrix. The parameter is '
    'similar to cameraMatrix1\n'
    '@param distCoeffs2 Input/output lens distortion coefficients for the '
    'second camera. The parameter\n'
    'is similar to distCoeffs1 .\n'
    '@param imageSize Size of the image used only to initialize intrinsic '
    'camera matrix.\n'
    '@param R Output rotation matrix between the 1st and the 2nd camera '
    'coordinate systems.\n'
    '@param T Output translation vector between the coordinate systems of the '
    'cameras.\n'
    '@param E Output essential matrix.\n'
    '@param F Output fundamental matrix.\n'
    '@param perViewErrors Output vector of the RMS re-projection error '
    'estimated for each pattern view.\n'
    '@param flags Different flags that may be zero or a combination of the '
    'following values:\n'
    '-   **CALIB_FIX_INTRINSIC** Fix cameraMatrix? and distCoeffs? so that '
    'only R, T, E , and F\n'
    'matrices are estimated.\n'
    '-   **CALIB_USE_INTRINSIC_GUESS** Optimize some or all of the intrinsic '
    'parameters\n'
    'according to the specified flags. Initial values are provided by the '
    'user.\n'
    '-   **CALIB_USE_EXTRINSIC_GUESS** R, T contain valid initial values that '
    'are optimized further.\n'
    'Otherwise R, T are initialized to the median value of the pattern views '
    '(each dimension separately).\n'
    '-   **CALIB_FIX_PRINCIPAL_POINT** Fix the principal points during the '
    'optimization.\n'
    '-   **CALIB_FIX_FOCAL_LENGTH** Fix \\f$f^{(j)}_x\\f$ and '
    '\\f$f^{(j)}_y\\f$ .\n'
    '-   **CALIB_FIX_ASPECT_RATIO** Optimize \\f$f^{(j)}_y\\f$ . Fix the ratio '
    '\\f$f^{(j)}_x/f^{(j)}_y\\f$\n'
    '.\n'
    '-   **CALIB_SAME_FOCAL_LENGTH** Enforce \\f$f^{(0)}_x=f^{(1)}_x\\f$ and '
    '\\f$f^{(0)}_y=f^{(1)}_y\\f$ .\n'
    '-   **CALIB_ZERO_TANGENT_DIST** Set tangential distortion coefficients '
    'for each camera to\n'
    'zeros and fix there.\n'
    '-   **CALIB_FIX_K1,...,CALIB_FIX_K6** Do not change the corresponding '
    'radial\n'
    'distortion coefficient during the optimization. If '
    'CALIB_USE_INTRINSIC_GUESS is set,\n'
    'the coefficient from the supplied distCoeffs matrix is used. Otherwise, '
    'it is set to 0.\n'
    '-   **CALIB_RATIONAL_MODEL** Enable coefficients k4, k5, and k6. To '
    'provide the backward\n'
    'compatibility, this extra flag should be explicitly specified to make the '
    'calibration\n'
    'function use the rational model and return 8 coefficients. If the flag is '
    'not set, the\n'
    'function computes and returns only 5 distortion coefficients.\n'
    '-   **CALIB_THIN_PRISM_MODEL** Coefficients s1, s2, s3 and s4 are '
    'enabled. To provide the\n'
    'backward compatibility, this extra flag should be explicitly specified to '
    'make the\n'
    'calibration function use the thin prism model and return 12 coefficients. '
    'If the flag is not\n'
    'set, the function computes and returns only 5 distortion coefficients.\n'
    '-   **CALIB_FIX_S1_S2_S3_S4** The thin prism distortion coefficients are '
    'not changed during\n'
    'the optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient '
    'from the\n'
    'supplied distCoeffs matrix is used. Otherwise, it is set to 0.\n'
    '-   **CALIB_TILTED_MODEL** Coefficients tauX and tauY are enabled. To '
    'provide the\n'
    'backward compatibility, this extra flag should be explicitly specified to '
    'make the\n'
    'calibration function use the tilted sensor model and return 14 '
    'coefficients. If the flag is not\n'
    'set, the function computes and returns only 5 distortion coefficients.\n'
    '-   **CALIB_FIX_TAUX_TAUY** The coefficients of the tilted sensor model '
    'are not changed during\n'
    'the optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient '
    'from the\n'
    'supplied distCoeffs matrix is used. Otherwise, it is set to 0.\n'
    '@param criteria Termination criteria for the iterative optimization '
    'algorithm.\n'
    '\n'
    'The function estimates transformation between two cameras making a stereo '
    'pair. If you have a stereo\n'
    'camera where the relative position and orientation of two cameras is '
    'fixed, and if you computed\n'
    'poses of an object relative to the first camera and to the second camera, '
    '(R1, T1) and (R2, T2),\n'
    'respectively (this can be done with solvePnP ), then those poses '
    'definitely relate to each other.\n'
    'This means that, given ( \\f$R_1\\f$,\\f$T_1\\f$ ), it should be possible '
    'to compute ( \\f$R_2\\f$,\\f$T_2\\f$ ). You only\n'
    'need to know the position and orientation of the second camera relative '
    'to the first camera. This is\n'
    'what the described function does. It computes ( \\f$R\\f$,\\f$T\\f$ ) so '
    'that:\n'
    '\n'
    '\\f[R_2=R*R_1\\f]\n'
    '\\f[T_2=R*T_1 + T,\\f]\n'
    '\n'
    'Optionally, it computes the essential matrix E:\n'
    '\n'
    '\\f[E= \\vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} *R\\f]\n'
    '\n'
    'where \\f$T_i\\f$ are components of the translation vector \\f$T\\f$ : '
    '\\f$T=[T_0, T_1, T_2]^T\\f$ . And the function\n'
    'can also compute the fundamental matrix F:\n'
    '\n'
    '\\f[F = cameraMatrix2^{-T} E cameraMatrix1^{-1}\\f]\n'
    '\n'
    'Besides the stereo-related information, the function can also perform a '
    'full calibration of each of\n'
    'two cameras. However, due to the high dimensionality of the parameter '
    'space and noise in the input\n'
    'data, the function can diverge from the correct solution. If the '
    'intrinsic parameters can be\n'
    'estimated with high accuracy for each of the cameras individually (for '
    'example, using\n'
    'calibrateCamera ), you are recommended to do so and then pass '
    'CALIB_FIX_INTRINSIC flag to the\n'
    'function along with the computed intrinsic parameters. Otherwise, if all '
    'the parameters are\n'
    'estimated at once, it makes sense to restrict some parameters, for '
    'example, pass\n'
    'CALIB_SAME_FOCAL_LENGTH and CALIB_ZERO_TANGENT_DIST flags, which is '
    'usually a\n'
    'reasonable assumption.\n'
    '\n'
    'Similarly to calibrateCamera , the function minimizes the total '
    're-projection error for all the\n'
    'points in all the available views from both cameras. The function returns '
    'the final value of the\n'
    're-projection error.']
parse_name: cv.stereoCalibrate with ['cv', 'cv::fisheye'] -> fullname:cv::stereoCalibrate namespace:cv classpath: classname: name:stereoCalibrate
register (function) stereoCalibrate (cv_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
[   'cv.stereoCalibrate',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints1', '', []],
        ['InputArrayOfArrays', 'imagePoints2', '', []],
        ['InputOutputArray', 'cameraMatrix1', '', []],
        ['InputOutputArray', 'distCoeffs1', '', []],
        ['InputOutputArray', 'cameraMatrix2', '', []],
        ['InputOutputArray', 'distCoeffs2', '', []],
        ['Size', 'imageSize', '', []],
        ['OutputArray', 'R', '', []],
        ['OutputArray', 'T', '', []],
        ['OutputArray', 'E', '', []],
        ['OutputArray', 'F', '', []],
        ['int', 'flags', 'CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    None,
    '']
parse_name: cv.stereoCalibrate with ['cv', 'cv::fisheye'] -> fullname:cv::stereoCalibrate namespace:cv classpath: classname: name:stereoCalibrate
register (function) stereoCalibrate (cv_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
[   'cv.stereoRectify',
    'void',
    [],
    [   ['InputArray', 'cameraMatrix1', '', []],
        ['InputArray', 'distCoeffs1', '', []],
        ['InputArray', 'cameraMatrix2', '', []],
        ['InputArray', 'distCoeffs2', '', []],
        ['Size', 'imageSize', '', []],
        ['InputArray', 'R', '', []],
        ['InputArray', 'T', '', []],
        ['OutputArray', 'R1', '', []],
        ['OutputArray', 'R2', '', []],
        ['OutputArray', 'P1', '', []],
        ['OutputArray', 'P2', '', []],
        ['OutputArray', 'Q', '', []],
        ['int', 'flags', 'CALIB_ZERO_DISPARITY', []],
        ['double', 'alpha', '-1', []],
        ['Size', 'newImageSize', 'Size()', []],
        ['Rect*', 'validPixROI1', '0', []],
        ['Rect*', 'validPixROI2', '0', []]],
    None,
    '@brief Computes rectification transforms for each head of a calibrated '
    'stereo camera.\n'
    '\n'
    '@param cameraMatrix1 First camera matrix.\n'
    '@param distCoeffs1 First camera distortion parameters.\n'
    '@param cameraMatrix2 Second camera matrix.\n'
    '@param distCoeffs2 Second camera distortion parameters.\n'
    '@param imageSize Size of the image used for stereo calibration.\n'
    '@param R Rotation matrix between the coordinate systems of the first and '
    'the second cameras.\n'
    '@param T Translation vector between coordinate systems of the cameras.\n'
    '@param R1 Output 3x3 rectification transform (rotation matrix) for the '
    'first camera.\n'
    '@param R2 Output 3x3 rectification transform (rotation matrix) for the '
    'second camera.\n'
    '@param P1 Output 3x4 projection matrix in the new (rectified) coordinate '
    'systems for the first\n'
    'camera.\n'
    '@param P2 Output 3x4 projection matrix in the new (rectified) coordinate '
    'systems for the second\n'
    'camera.\n'
    '@param Q Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix '
    '(see reprojectImageTo3D ).\n'
    '@param flags Operation flags that may be zero or CALIB_ZERO_DISPARITY . '
    'If the flag is set,\n'
    'the function makes the principal points of each camera have the same '
    'pixel coordinates in the\n'
    'rectified views. And if the flag is not set, the function may still shift '
    'the images in the\n'
    'horizontal or vertical direction (depending on the orientation of '
    'epipolar lines) to maximize the\n'
    'useful image area.\n'
    '@param alpha Free scaling parameter. If it is -1 or absent, the function '
    'performs the default\n'
    'scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 '
    'means that the rectified\n'
    'images are zoomed and shifted so that only valid pixels are visible (no '
    'black areas after\n'
    'rectification). alpha=1 means that the rectified image is decimated and '
    'shifted so that all the\n'
    'pixels from the original images from the cameras are retained in the '
    'rectified images (no source\n'
    'image pixels are lost). Obviously, any intermediate value yields an '
    'intermediate result between\n'
    'those two extreme cases.\n'
    '@param newImageSize New image resolution after rectification. The same '
    'size should be passed to\n'
    'initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV '
    'samples directory). When (0,0)\n'
    'is passed (default), it is set to the original imageSize . Setting it to '
    'larger value can help you\n'
    'preserve details in the original image, especially when there is a big '
    'radial distortion.\n'
    '@param validPixROI1 Optional output rectangles inside the rectified '
    'images where all the pixels\n'
    'are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they '
    'are likely to be smaller\n'
    '(see the picture below).\n'
    '@param validPixROI2 Optional output rectangles inside the rectified '
    'images where all the pixels\n'
    'are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they '
    'are likely to be smaller\n'
    '(see the picture below).\n'
    '\n'
    'The function computes the rotation matrices for each camera that '
    '(virtually) make both camera image\n'
    'planes the same plane. Consequently, this makes all the epipolar lines '
    'parallel and thus simplifies\n'
    'the dense stereo correspondence problem. The function takes the matrices '
    'computed by stereoCalibrate\n'
    'as input. As output, it provides two rotation matrices and also two '
    'projection matrices in the new\n'
    'coordinates. The function distinguishes the following two cases:\n'
    '\n'
    '-   **Horizontal stereo**: the first and the second camera views are '
    'shifted relative to each other\n'
    'mainly along the x axis (with possible small vertical shift). In the '
    'rectified images, the\n'
    'corresponding epipolar lines in the left and right cameras are horizontal '
    'and have the same\n'
    'y-coordinate. P1 and P2 look like:\n'
    '\n'
    '\\f[\\texttt{P1} = \\begin{bmatrix} f & 0 & cx_1 & 0 \\\\ 0 & f & cy & 0 '
    '\\\\ 0 & 0 & 1 & 0 \\end{bmatrix}\\f]\n'
    '\n'
    '\\f[\\texttt{P2} = \\begin{bmatrix} f & 0 & cx_2 & T_x*f \\\\ 0 & f & cy '
    '& 0 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix} ,\\f]\n'
    '\n'
    'where \\f$T_x\\f$ is a horizontal shift between the cameras and '
    '\\f$cx_1=cx_2\\f$ if\n'
    'CALIB_ZERO_DISPARITY is set.\n'
    '\n'
    '-   **Vertical stereo**: the first and the second camera views are '
    'shifted relative to each other\n'
    'mainly in vertical direction (and probably a bit in the horizontal '
    'direction too). The epipolar\n'
    'lines in the rectified images are vertical and have the same '
    'x-coordinate. P1 and P2 look like:\n'
    '\n'
    '\\f[\\texttt{P1} = \\begin{bmatrix} f & 0 & cx & 0 \\\\ 0 & f & cy_1 & 0 '
    '\\\\ 0 & 0 & 1 & 0 \\end{bmatrix}\\f]\n'
    '\n'
    '\\f[\\texttt{P2} = \\begin{bmatrix} f & 0 & cx & 0 \\\\ 0 & f & cy_2 & '
    'T_y*f \\\\ 0 & 0 & 1 & 0 \\end{bmatrix} ,\\f]\n'
    '\n'
    'where \\f$T_y\\f$ is a vertical shift between the cameras and '
    '\\f$cy_1=cy_2\\f$ if CALIB_ZERO_DISPARITY is\n'
    'set.\n'
    '\n'
    'As you can see, the first three columns of P1 and P2 will effectively be '
    'the new "rectified" camera\n'
    'matrices. The matrices, together with R1 and R2 , can then be passed to '
    'initUndistortRectifyMap to\n'
    'initialize the rectification map for each camera.\n'
    '\n'
    'See below the screenshot from the stereo_calib.cpp sample. Some red '
    'horizontal lines pass through\n'
    'the corresponding image regions. This means that the images are well '
    'rectified, which is what most\n'
    'stereo correspondence algorithms rely on. The green rectangles are roi1 '
    'and roi2 . You see that\n'
    'their interiors are all valid pixels.\n'
    '\n'
    '![image](pics/stereo_undistort.jpg)']
parse_name: cv.stereoRectify with ['cv', 'cv::fisheye'] -> fullname:cv::stereoRectify namespace:cv classpath: classname: name:stereoRectify
register (function) stereoRectify (cv_stereoRectify__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_double_Size_Rect_X_Rect_X)

--- Incoming ---
[   'cv.stereoRectifyUncalibrated',
    'bool',
    [],
    [   ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['InputArray', 'F', '', []],
        ['Size', 'imgSize', '', []],
        ['OutputArray', 'H1', '', []],
        ['OutputArray', 'H2', '', []],
        ['double', 'threshold', '5', []]],
    None,
    '@brief Computes a rectification transform for an uncalibrated stereo '
    'camera.\n'
    '\n'
    '@param points1 Array of feature points in the first image.\n'
    '@param points2 The corresponding points in the second image. The same '
    'formats as in\n'
    'findFundamentalMat are supported.\n'
    '@param F Input fundamental matrix. It can be computed from the same set '
    'of point pairs using\n'
    'findFundamentalMat .\n'
    '@param imgSize Size of the image.\n'
    '@param H1 Output rectification homography matrix for the first image.\n'
    '@param H2 Output rectification homography matrix for the second image.\n'
    '@param threshold Optional threshold used to filter out the outliers. If '
    'the parameter is greater\n'
    'than zero, all the point pairs that do not comply with the epipolar '
    'geometry (that is, the points\n'
    'for which '
    '\\f$|\\texttt{points2[i]}^T*\\texttt{F}*\\texttt{points1[i]}|>\\texttt{threshold}\\f$ '
    ') are\n'
    'rejected prior to computing the homographies. Otherwise, all the points '
    'are considered inliers.\n'
    '\n'
    'The function computes the rectification transformations without knowing '
    'intrinsic parameters of the\n'
    'cameras and their relative position in the space, which explains the '
    'suffix "uncalibrated". Another\n'
    'related difference from stereoRectify is that the function outputs not '
    'the rectification\n'
    'transformations in the object (3D) space, but the planar perspective '
    'transformations encoded by the\n'
    'homography matrices H1 and H2 . The function implements the algorithm '
    '@cite Hartley99 .\n'
    '\n'
    '@note\n'
    'While the algorithm does not need to know the intrinsic parameters of the '
    'cameras, it heavily\n'
    'depends on the epipolar geometry. Therefore, if the camera lenses have a '
    'significant distortion,\n'
    'it would be better to correct it before computing the fundamental matrix '
    'and calling this\n'
    'function. For example, distortion coefficients can be estimated for each '
    'head of stereo camera\n'
    'separately by using calibrateCamera . Then, the images can be corrected '
    'using undistort , or\n'
    'just the point coordinates can be corrected with undistortPoints .']
parse_name: cv.stereoRectifyUncalibrated with ['cv', 'cv::fisheye'] -> fullname:cv::stereoRectifyUncalibrated namespace:cv classpath: classname: name:stereoRectifyUncalibrated
register (function) stereoRectifyUncalibrated (cv_stereoRectifyUncalibrated__InputArray__InputArray__InputArray_Size__OutputArray__OutputArray_double)

--- Incoming ---
[   'cv.rectify3Collinear',
    'float',
    [],
    [   ['InputArray', 'cameraMatrix1', '', []],
        ['InputArray', 'distCoeffs1', '', []],
        ['InputArray', 'cameraMatrix2', '', []],
        ['InputArray', 'distCoeffs2', '', []],
        ['InputArray', 'cameraMatrix3', '', []],
        ['InputArray', 'distCoeffs3', '', []],
        ['InputArrayOfArrays', 'imgpt1', '', []],
        ['InputArrayOfArrays', 'imgpt3', '', []],
        ['Size', 'imageSize', '', []],
        ['InputArray', 'R12', '', []],
        ['InputArray', 'T12', '', []],
        ['InputArray', 'R13', '', []],
        ['InputArray', 'T13', '', []],
        ['OutputArray', 'R1', '', []],
        ['OutputArray', 'R2', '', []],
        ['OutputArray', 'R3', '', []],
        ['OutputArray', 'P1', '', []],
        ['OutputArray', 'P2', '', []],
        ['OutputArray', 'P3', '', []],
        ['OutputArray', 'Q', '', []],
        ['double', 'alpha', '', []],
        ['Size', 'newImgSize', '', []],
        ['Rect*', 'roi1', '', []],
        ['Rect*', 'roi2', '', []],
        ['int', 'flags', '', []]],
    None,
    'computes the rectification transformations for 3-head camera, where all '
    'the heads are on the same line.']
parse_name: cv.rectify3Collinear with ['cv', 'cv::fisheye'] -> fullname:cv::rectify3Collinear namespace:cv classpath: classname: name:rectify3Collinear
register (function) rectify3Collinear (cv_rectify3Collinear__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_double_Size_Rect_X_Rect_X_int)

--- Incoming ---
[   'cv.getOptimalNewCameraMatrix',
    'Mat',
    [],
    [   ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'alpha', '', []],
        ['Size', 'newImgSize', 'Size()', []],
        ['Rect*', 'validPixROI', '0', []],
        ['bool', 'centerPrincipalPoint', 'false', []]],
    None,
    '@brief Returns the new camera matrix based on the free scaling '
    'parameter.\n'
    '\n'
    '@param cameraMatrix Input camera matrix.\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$ of\n'
    '4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are\n'
    'assumed.\n'
    '@param imageSize Original image size.\n'
    '@param alpha Free scaling parameter between 0 (when all the pixels in the '
    'undistorted image are\n'
    'valid) and 1 (when all the source image pixels are retained in the '
    'undistorted image). See\n'
    'stereoRectify for details.\n'
    '@param newImgSize Image size after rectification. By default, it is set '
    'to imageSize .\n'
    '@param validPixROI Optional output rectangle that outlines '
    'all-good-pixels region in the\n'
    'undistorted image. See roi1, roi2 description in stereoRectify .\n'
    '@param centerPrincipalPoint Optional flag that indicates whether in the '
    'new camera matrix the\n'
    'principal point should be at the image center or not. By default, the '
    'principal point is chosen to\n'
    'best fit a subset of the source image (determined by alpha) to the '
    'corrected image.\n'
    '@return new_camera_matrix Output new camera matrix.\n'
    '\n'
    'The function computes and returns the optimal new camera matrix based on '
    'the free scaling parameter.\n'
    'By varying this parameter, you may retrieve only sensible pixels alpha=0 '
    ', keep all the original\n'
    'image pixels if there is valuable information in the corners alpha=1 , or '
    'get something in between.\n'
    'When alpha\\>0 , the undistorted result is likely to have some black '
    'pixels corresponding to\n'
    '"virtual" pixels outside of the captured distorted image. The original '
    'camera matrix, distortion\n'
    'coefficients, the computed new camera matrix, and newImageSize should be '
    'passed to\n'
    'initUndistortRectifyMap to produce the maps for remap .']
parse_name: cv.getOptimalNewCameraMatrix with ['cv', 'cv::fisheye'] -> fullname:cv::getOptimalNewCameraMatrix namespace:cv classpath: classname: name:getOptimalNewCameraMatrix
register (function) getOptimalNewCameraMatrix (cv_getOptimalNewCameraMatrix__InputArray__InputArray_Size_double_Size_Rect_X_bool)

--- Incoming ---
[   'cv.calibrateHandEye',
    'void',
    [],
    [   ['InputArrayOfArrays', 'R_gripper2base', '', []],
        ['InputArrayOfArrays', 't_gripper2base', '', []],
        ['InputArrayOfArrays', 'R_target2cam', '', []],
        ['InputArrayOfArrays', 't_target2cam', '', []],
        ['OutputArray', 'R_cam2gripper', '', []],
        ['OutputArray', 't_cam2gripper', '', []],
        ['HandEyeCalibrationMethod', 'method', 'CALIB_HAND_EYE_TSAI', []]],
    None,
    '@brief Computes Hand-Eye calibration: \\f$_{}^{g}\\textrm{T}_c\\f$\n'
    '\n'
    '@param[in] R_gripper2base Rotation part extracted from the homogeneous '
    'matrix that transforms a point\n'
    'expressed in the gripper frame to the robot base frame '
    '(\\f$_{}^{b}\\textrm{T}_g\\f$).\n'
    'This is a vector (`vector<Mat>`) that contains the rotation matrices for '
    'all the transformations\n'
    'from gripper frame to robot base frame.\n'
    '@param[in] t_gripper2base Translation part extracted from the homogeneous '
    'matrix that transforms a point\n'
    'expressed in the gripper frame to the robot base frame '
    '(\\f$_{}^{b}\\textrm{T}_g\\f$).\n'
    'This is a vector (`vector<Mat>`) that contains the translation vectors '
    'for all the transformations\n'
    'from gripper frame to robot base frame.\n'
    '@param[in] R_target2cam Rotation part extracted from the homogeneous '
    'matrix that transforms a point\n'
    'expressed in the target frame to the camera frame '
    '(\\f$_{}^{c}\\textrm{T}_t\\f$).\n'
    'This is a vector (`vector<Mat>`) that contains the rotation matrices for '
    'all the transformations\n'
    'from calibration target frame to camera frame.\n'
    '@param[in] t_target2cam Rotation part extracted from the homogeneous '
    'matrix that transforms a point\n'
    'expressed in the target frame to the camera frame '
    '(\\f$_{}^{c}\\textrm{T}_t\\f$).\n'
    'This is a vector (`vector<Mat>`) that contains the translation vectors '
    'for all the transformations\n'
    'from calibration target frame to camera frame.\n'
    '@param[out] R_cam2gripper Estimated rotation part extracted from the '
    'homogeneous matrix that transforms a point\n'
    'expressed in the camera frame to the gripper frame '
    '(\\f$_{}^{g}\\textrm{T}_c\\f$).\n'
    '@param[out] t_cam2gripper Estimated translation part extracted from the '
    'homogeneous matrix that transforms a point\n'
    'expressed in the camera frame to the gripper frame '
    '(\\f$_{}^{g}\\textrm{T}_c\\f$).\n'
    '@param[in] method One of the implemented Hand-Eye calibration method, see '
    'cv::HandEyeCalibrationMethod\n'
    '\n'
    'The function performs the Hand-Eye calibration using various methods. One '
    'approach consists in estimating the\n'
    'rotation then the translation (separable solutions) and the following '
    'methods are implemented:\n'
    '- R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D '
    'Robotics Hand/EyeCalibration \\cite Tsai89\n'
    '- F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the '
    'Euclidean Group \\cite Park94\n'
    '- R. Horaud, F. Dornaika Hand-Eye Calibration \\cite Horaud95\n'
    '\n'
    'Another approach consists in estimating simultaneously the rotation and '
    'the translation (simultaneous solutions),\n'
    'with the following implemented method:\n'
    '- N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \\cite '
    'Andreff99\n'
    '- K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \\cite '
    'Daniilidis98\n'
    '\n'
    'The following picture describes the Hand-Eye calibration problem where '
    'the transformation between a camera ("eye")\n'
    'mounted on a robot gripper ("hand") has to be estimated.\n'
    '\n'
    '![](pics/hand-eye_figure.png)\n'
    '\n'
    'The calibration procedure is the following:\n'
    '- a static calibration pattern is used to estimate the transformation '
    'between the target frame\n'
    'and the camera frame\n'
    '- the robot gripper is moved in order to acquire several poses\n'
    '- for each pose, the homogeneous transformation between the gripper frame '
    'and the robot base frame is recorded using for\n'
    'instance the robot kinematics\n'
    '\\f[\n'
    '\\begin{bmatrix}\n'
    'X_b\\\\\n'
    'Y_b\\\\\n'
    'Z_b\\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '=\n'
    '\\begin{bmatrix}\n'
    '_{}^{b}\\textrm{R}_g & _{}^{b}\\textrm{t}_g \\\\\n'
    '0_{1 \\times 3} & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X_g\\\\\n'
    'Y_g\\\\\n'
    'Z_g\\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '\\f]\n'
    '- for each pose, the homogeneous transformation between the calibration '
    'target frame and the camera frame is recorded using\n'
    'for instance a pose estimation method (PnP) from 2D-3D point '
    'correspondences\n'
    '\\f[\n'
    '\\begin{bmatrix}\n'
    'X_c\\\\\n'
    'Y_c\\\\\n'
    'Z_c\\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '=\n'
    '\\begin{bmatrix}\n'
    '_{}^{c}\\textrm{R}_t & _{}^{c}\\textrm{t}_t \\\\\n'
    '0_{1 \\times 3} & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X_t\\\\\n'
    'Y_t\\\\\n'
    'Z_t\\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '\\f]\n'
    '\n'
    'The Hand-Eye calibration procedure returns the following homogeneous '
    'transformation\n'
    '\\f[\n'
    '\\begin{bmatrix}\n'
    'X_g\\\\\n'
    'Y_g\\\\\n'
    'Z_g\\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '=\n'
    '\\begin{bmatrix}\n'
    '_{}^{g}\\textrm{R}_c & _{}^{g}\\textrm{t}_c \\\\\n'
    '0_{1 \\times 3} & 1\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X_c\\\\\n'
    'Y_c\\\\\n'
    'Z_c\\\\\n'
    '1\n'
    '\\end{bmatrix}\n'
    '\\f]\n'
    '\n'
    'This problem is also known as solving the '
    '\\f$\\mathbf{A}\\mathbf{X}=\\mathbf{X}\\mathbf{B}\\f$ equation:\n'
    '\\f[\n'
    '\\begin{align*}\n'
    '^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c '
    '\\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(1)} &=\n'
    '\\hspace{0.1em} ^{b}{\\textrm{T}_g}^{(2)} \\hspace{0.2em} '
    '^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} \\\\\n'
    '\n'
    '(^{b}{\\textrm{T}_g}^{(2)})^{-1} \\hspace{0.2em} '
    '^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c &=\n'
    '\\hspace{0.1em} ^{g}\\textrm{T}_c \\hspace{0.2em} '
    '^{c}{\\textrm{T}_t}^{(2)} (^{c}{\\textrm{T}_t}^{(1)})^{-1} \\\\\n'
    '\n'
    '\\textrm{A}_i \\textrm{X} &= \\textrm{X} \\textrm{B}_i \\\\\n'
    '\\end{align*}\n'
    '\\f]\n'
    '\n'
    '\\note\n'
    'Additional information can be found on this '
    '[website](http://campar.in.tum.de/Chair/HandEyeCalibration).\n'
    '\\note\n'
    'A minimum of 2 motions with non parallel rotation axes are necessary to '
    'determine the hand-eye transformation.\n'
    'So at least 3 different poses are required, but it is strongly '
    'recommended to use many more poses.']
parse_name: cv.calibrateHandEye with ['cv', 'cv::fisheye'] -> fullname:cv::calibrateHandEye namespace:cv classpath: classname: name:calibrateHandEye
register (function) calibrateHandEye (cv_calibrateHandEye__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_HandEyeCalibrationMethod)

--- Incoming ---
[   'cv.convertPointsToHomogeneous',
    'void',
    [],
    [['InputArray', 'src', '', []], ['OutputArray', 'dst', '', []]],
    None,
    '@brief Converts points from Euclidean to homogeneous space.\n'
    '\n'
    '@param src Input vector of N-dimensional points.\n'
    '@param dst Output vector of N+1-dimensional points.\n'
    '\n'
    'The function converts points from Euclidean to homogeneous space by '
    "appending 1's to the tuple of\n"
    'point coordinates. That is, each point (x1, x2, ..., xn) is converted to '
    '(x1, x2, ..., xn, 1).']
parse_name: cv.convertPointsToHomogeneous with ['cv', 'cv::fisheye'] -> fullname:cv::convertPointsToHomogeneous namespace:cv classpath: classname: name:convertPointsToHomogeneous
register (function) convertPointsToHomogeneous (cv_convertPointsToHomogeneous__InputArray__OutputArray)

--- Incoming ---
[   'cv.convertPointsFromHomogeneous',
    'void',
    [],
    [['InputArray', 'src', '', []], ['OutputArray', 'dst', '', []]],
    None,
    '@brief Converts points from homogeneous to Euclidean space.\n'
    '\n'
    '@param src Input vector of N-dimensional points.\n'
    '@param dst Output vector of N-1-dimensional points.\n'
    '\n'
    'The function converts points homogeneous to Euclidean space using '
    'perspective projection. That is,\n'
    'each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., '
    'x(n-1)/xn). When xn=0, the\n'
    'output point coordinates will be (0,0,0,...).']
parse_name: cv.convertPointsFromHomogeneous with ['cv', 'cv::fisheye'] -> fullname:cv::convertPointsFromHomogeneous namespace:cv classpath: classname: name:convertPointsFromHomogeneous
register (function) convertPointsFromHomogeneous (cv_convertPointsFromHomogeneous__InputArray__OutputArray)

--- Incoming ---
[   'cv.convertPointsHomogeneous',
    'void',
    [],
    [['InputArray', 'src', '', []], ['OutputArray', 'dst', '', []]],
    None,
    '@brief Converts points to/from homogeneous coordinates.\n'
    '\n'
    '@param src Input array or vector of 2D, 3D, or 4D points.\n'
    '@param dst Output vector of 2D, 3D, or 4D points.\n'
    '\n'
    'The function converts 2D or 3D points from/to homogeneous coordinates by '
    'calling either\n'
    'convertPointsToHomogeneous or convertPointsFromHomogeneous.\n'
    '\n'
    '@note The function is obsolete. Use one of the previous two functions '
    'instead.']
parse_name: cv.convertPointsHomogeneous with ['cv', 'cv::fisheye'] -> fullname:cv::convertPointsHomogeneous namespace:cv classpath: classname: name:convertPointsHomogeneous
register (function) convertPointsHomogeneous (cv_convertPointsHomogeneous__InputArray__OutputArray)

--- Incoming ---
[   'cv.findFundamentalMat',
    'Mat',
    [],
    [   ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['int', 'method', 'FM_RANSAC', []],
        ['double', 'ransacReprojThreshold', '3.', []],
        ['double', 'confidence', '0.99', []],
        ['OutputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Calculates a fundamental matrix from the corresponding points in '
    'two images.\n'
    '\n'
    '@param points1 Array of N points from the first image. The point '
    'coordinates should be\n'
    'floating-point (single or double precision).\n'
    '@param points2 Array of the second image points of the same size and '
    'format as points1 .\n'
    '@param method Method for computing a fundamental matrix.\n'
    '-   **CV_FM_7POINT** for a 7-point algorithm. \\f$N = 7\\f$\n'
    '-   **CV_FM_8POINT** for an 8-point algorithm. \\f$N \\ge 8\\f$\n'
    '-   **CV_FM_RANSAC** for the RANSAC algorithm. \\f$N \\ge 8\\f$\n'
    '-   **CV_FM_LMEDS** for the LMedS algorithm. \\f$N \\ge 8\\f$\n'
    '@param ransacReprojThreshold Parameter used only for RANSAC. It is the '
    'maximum distance from a point to an epipolar\n'
    'line in pixels, beyond which the point is considered an outlier and is '
    'not used for computing the\n'
    'final fundamental matrix. It can be set to something like 1-3, depending '
    'on the accuracy of the\n'
    'point localization, image resolution, and the image noise.\n'
    '@param confidence Parameter used for the RANSAC and LMedS methods only. '
    'It specifies a desirable level\n'
    'of confidence (probability) that the estimated matrix is correct.\n'
    '@param mask\n'
    '\n'
    'The epipolar geometry is described by the following equation:\n'
    '\n'
    '\\f[[p_2; 1]^T F [p_1; 1] = 0\\f]\n'
    '\n'
    'where \\f$F\\f$ is a fundamental matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are '
    'corresponding points in the first and the\n'
    'second images, respectively.\n'
    '\n'
    'The function calculates the fundamental matrix using one of four methods '
    'listed above and returns\n'
    'the found fundamental matrix. Normally just one matrix is found. But in '
    'case of the 7-point\n'
    'algorithm, the function may return up to 3 solutions ( \\f$9 \\times '
    '3\\f$ matrix that stores all 3\n'
    'matrices sequentially).\n'
    '\n'
    'The calculated fundamental matrix may be passed further to '
    'computeCorrespondEpilines that finds the\n'
    'epipolar lines corresponding to the specified points. It can also be '
    'passed to\n'
    'stereoRectifyUncalibrated to compute the rectification transformation. :\n'
    '@code\n'
    '// Example. Estimation of fundamental matrix using the RANSAC algorithm\n'
    'int point_count = 100;\n'
    'vector<Point2f> points1(point_count);\n'
    'vector<Point2f> points2(point_count);\n'
    '\n'
    '// initialize the points here ...\n'
    'for( int i = 0; i < point_count; i++ )\n'
    '{\n'
    'points1[i] = ...;\n'
    'points2[i] = ...;\n'
    '}\n'
    '\n'
    'Mat fundamental_matrix =\n'
    'findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);\n'
    '@endcode']
parse_name: cv.findFundamentalMat with ['cv', 'cv::fisheye'] -> fullname:cv::findFundamentalMat namespace:cv classpath: classname: name:findFundamentalMat
register (function) findFundamentalMat (cv_findFundamentalMat__InputArray__InputArray_int_double_double__OutputArray)

--- Incoming ---
[   'cv.findFundamentalMat',
    'Mat',
    [],
    [   ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['OutputArray', 'mask', '', []],
        ['int', 'method', 'FM_RANSAC', []],
        ['double', 'ransacReprojThreshold', '3.', []],
        ['double', 'confidence', '0.99', []]],
    None,
    '@overload']
parse_name: cv.findFundamentalMat with ['cv', 'cv::fisheye'] -> fullname:cv::findFundamentalMat namespace:cv classpath: classname: name:findFundamentalMat
register (function) findFundamentalMat (cv_findFundamentalMat__InputArray__InputArray__OutputArray_int_double_double)

--- Incoming ---
[   'cv.findEssentialMat',
    'Mat',
    [],
    [   ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'prob', '0.999', []],
        ['double', 'threshold', '1.0', []],
        ['OutputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Calculates an essential matrix from the corresponding points in '
    'two images.\n'
    '\n'
    '@param points1 Array of N (N \\>= 5) 2D points from the first image. The '
    'point coordinates should\n'
    'be floating-point (single or double precision).\n'
    '@param points2 Array of the second image points of the same size and '
    'format as points1 .\n'
    '@param cameraMatrix Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n'
    'Note that this function assumes that points1 and points2 are feature '
    'points from cameras with the\n'
    'same camera matrix.\n'
    '@param method Method for computing an essential matrix.\n'
    '-   **RANSAC** for the RANSAC algorithm.\n'
    '-   **LMEDS** for the LMedS algorithm.\n'
    '@param prob Parameter used for the RANSAC or LMedS methods only. It '
    'specifies a desirable level of\n'
    'confidence (probability) that the estimated matrix is correct.\n'
    '@param threshold Parameter used for RANSAC. It is the maximum distance '
    'from a point to an epipolar\n'
    'line in pixels, beyond which the point is considered an outlier and is '
    'not used for computing the\n'
    'final fundamental matrix. It can be set to something like 1-3, depending '
    'on the accuracy of the\n'
    'point localization, image resolution, and the image noise.\n'
    '@param mask Output array of N elements, every element of which is set to '
    '0 for outliers and to 1\n'
    'for the other points. The array is computed only in the RANSAC and LMedS '
    'methods.\n'
    '\n'
    'This function estimates essential matrix based on the five-point '
    'algorithm solver in @cite Nister03 .\n'
    '@cite SteweniusCFS is also a related. The epipolar geometry is described '
    'by the following equation:\n'
    '\n'
    '\\f[[p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\\f]\n'
    '\n'
    'where \\f$E\\f$ is an essential matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are '
    'corresponding points in the first and the\n'
    'second images, respectively. The result of this function may be passed '
    'further to\n'
    'decomposeEssentialMat or recoverPose to recover the relative pose between '
    'cameras.']
parse_name: cv.findEssentialMat with ['cv', 'cv::fisheye'] -> fullname:cv::findEssentialMat namespace:cv classpath: classname: name:findEssentialMat
register (function) findEssentialMat (cv_findEssentialMat__InputArray__InputArray__InputArray_int_double_double__OutputArray)

--- Incoming ---
[   'cv.findEssentialMat',
    'Mat',
    [],
    [   ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['double', 'focal', '1.0', []],
        ['Point2d', 'pp', 'Point2d(0, 0)', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'prob', '0.999', []],
        ['double', 'threshold', '1.0', []],
        ['OutputArray', 'mask', 'noArray()', []]],
    None,
    '@overload\n'
    '@param points1 Array of N (N \\>= 5) 2D points from the first image. The '
    'point coordinates should\n'
    'be floating-point (single or double precision).\n'
    '@param points2 Array of the second image points of the same size and '
    'format as points1 .\n'
    '@param focal focal length of the camera. Note that this function assumes '
    'that points1 and points2\n'
    'are feature points from cameras with same focal length and principal '
    'point.\n'
    '@param pp principal point of the camera.\n'
    '@param method Method for computing a fundamental matrix.\n'
    '-   **RANSAC** for the RANSAC algorithm.\n'
    '-   **LMEDS** for the LMedS algorithm.\n'
    '@param threshold Parameter used for RANSAC. It is the maximum distance '
    'from a point to an epipolar\n'
    'line in pixels, beyond which the point is considered an outlier and is '
    'not used for computing the\n'
    'final fundamental matrix. It can be set to something like 1-3, depending '
    'on the accuracy of the\n'
    'point localization, image resolution, and the image noise.\n'
    '@param prob Parameter used for the RANSAC or LMedS methods only. It '
    'specifies a desirable level of\n'
    'confidence (probability) that the estimated matrix is correct.\n'
    '@param mask Output array of N elements, every element of which is set to '
    '0 for outliers and to 1\n'
    'for the other points. The array is computed only in the RANSAC and LMedS '
    'methods.\n'
    '\n'
    'This function differs from the one above that it computes camera matrix '
    'from focal length and\n'
    'principal point:\n'
    '\n'
    '\\f[K =\n'
    '\\begin{bmatrix}\n'
    'f & 0 & x_{pp}  \\\\\n'
    '0 & f & y_{pp}  \\\\\n'
    '0 & 0 & 1\n'
    '\\end{bmatrix}\\f]']
parse_name: cv.findEssentialMat with ['cv', 'cv::fisheye'] -> fullname:cv::findEssentialMat namespace:cv classpath: classname: name:findEssentialMat
register (function) findEssentialMat (cv_findEssentialMat__InputArray__InputArray_double_Point2d_int_double_double__OutputArray)

--- Incoming ---
[   'cv.decomposeEssentialMat',
    'void',
    [],
    [   ['InputArray', 'E', '', []],
        ['OutputArray', 'R1', '', []],
        ['OutputArray', 'R2', '', []],
        ['OutputArray', 't', '', []]],
    None,
    '@brief Decompose an essential matrix to possible rotations and '
    'translation.\n'
    '\n'
    '@param E The input essential matrix.\n'
    '@param R1 One possible rotation matrix.\n'
    '@param R2 Another possible rotation matrix.\n'
    '@param t One possible translation.\n'
    '\n'
    'This function decompose an essential matrix E using svd decomposition '
    '@cite HartleyZ00 . Generally 4\n'
    'possible poses exists for a given E. They are \\f$[R_1, t]\\f$, \\f$[R_1, '
    '-t]\\f$, \\f$[R_2, t]\\f$, \\f$[R_2, -t]\\f$. By\n'
    'decomposing E, you can only get the direction of the translation, so the '
    'function returns unit t.']
parse_name: cv.decomposeEssentialMat with ['cv', 'cv::fisheye'] -> fullname:cv::decomposeEssentialMat namespace:cv classpath: classname: name:decomposeEssentialMat
register (function) decomposeEssentialMat (cv_decomposeEssentialMat__InputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['InputArray', 'E', '', []],
        ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['OutputArray', 'R', '', []],
        ['OutputArray', 't', '', []],
        ['InputOutputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Recover relative camera rotation and translation from an estimated '
    'essential matrix and the\n'
    'corresponding points in two images, using cheirality check. Returns the '
    'number of inliers which pass\n'
    'the check.\n'
    '\n'
    '@param E The input essential matrix.\n'
    '@param points1 Array of N 2D points from the first image. The point '
    'coordinates should be\n'
    'floating-point (single or double precision).\n'
    '@param points2 Array of the second image points of the same size and '
    'format as points1 .\n'
    '@param cameraMatrix Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n'
    'Note that this function assumes that points1 and points2 are feature '
    'points from cameras with the\n'
    'same camera matrix.\n'
    '@param R Recovered relative rotation.\n'
    '@param t Recovered relative translation.\n'
    '@param mask Input/output mask for inliers in points1 and points2.\n'
    ':   If it is not empty, then it marks inliers in points1 and points2 for '
    'then given essential\n'
    'matrix E. Only these inliers will be used to recover pose. In the output '
    'mask only inliers\n'
    'which pass the cheirality check.\n'
    'This function decomposes an essential matrix using decomposeEssentialMat '
    'and then verifies possible\n'
    'pose hypotheses by doing cheirality check. The cheirality check basically '
    'means that the\n'
    'triangulated 3D points should have positive depth. Some details can be '
    'found in @cite Nister03 .\n'
    '\n'
    'This function can be used to process output E and mask from '
    'findEssentialMat. In this scenario,\n'
    'points1 and points2 are the same input for findEssentialMat. :\n'
    '@code\n'
    '// Example. Estimation of fundamental matrix using the RANSAC algorithm\n'
    'int point_count = 100;\n'
    'vector<Point2f> points1(point_count);\n'
    'vector<Point2f> points2(point_count);\n'
    '\n'
    '// initialize the points here ...\n'
    'for( int i = 0; i < point_count; i++ )\n'
    '{\n'
    'points1[i] = ...;\n'
    'points2[i] = ...;\n'
    '}\n'
    '\n'
    '// cametra matrix with both focal lengths = 1, and principal point = (0, '
    '0)\n'
    'Mat cameraMatrix = Mat::eye(3, 3, CV_64F);\n'
    '\n'
    'Mat E, R, t, mask;\n'
    '\n'
    'E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, '
    'mask);\n'
    'recoverPose(E, points1, points2, cameraMatrix, R, t, mask);\n'
    '@endcode']
parse_name: cv.recoverPose with ['cv', 'cv::fisheye'] -> fullname:cv::recoverPose namespace:cv classpath: classname: name:recoverPose
register (function) recoverPose (cv_recoverPose__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__InputOutputArray)

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['InputArray', 'E', '', []],
        ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['OutputArray', 'R', '', []],
        ['OutputArray', 't', '', []],
        ['double', 'focal', '1.0', []],
        ['Point2d', 'pp', 'Point2d(0, 0)', []],
        ['InputOutputArray', 'mask', 'noArray()', []]],
    None,
    '@overload\n'
    '@param E The input essential matrix.\n'
    '@param points1 Array of N 2D points from the first image. The point '
    'coordinates should be\n'
    'floating-point (single or double precision).\n'
    '@param points2 Array of the second image points of the same size and '
    'format as points1 .\n'
    '@param R Recovered relative rotation.\n'
    '@param t Recovered relative translation.\n'
    '@param focal Focal length of the camera. Note that this function assumes '
    'that points1 and points2\n'
    'are feature points from cameras with same focal length and principal '
    'point.\n'
    '@param pp principal point of the camera.\n'
    '@param mask Input/output mask for inliers in points1 and points2.\n'
    ':   If it is not empty, then it marks inliers in points1 and points2 for '
    'then given essential\n'
    'matrix E. Only these inliers will be used to recover pose. In the output '
    'mask only inliers\n'
    'which pass the cheirality check.\n'
    '\n'
    'This function differs from the one above that it computes camera matrix '
    'from focal length and\n'
    'principal point:\n'
    '\n'
    '\\f[K =\n'
    '\\begin{bmatrix}\n'
    'f & 0 & x_{pp}  \\\\\n'
    '0 & f & y_{pp}  \\\\\n'
    '0 & 0 & 1\n'
    '\\end{bmatrix}\\f]']
parse_name: cv.recoverPose with ['cv', 'cv::fisheye'] -> fullname:cv::recoverPose namespace:cv classpath: classname: name:recoverPose
register (function) recoverPose (cv_recoverPose__InputArray__InputArray__InputArray__OutputArray__OutputArray_double_Point2d__InputOutputArray)

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['InputArray', 'E', '', []],
        ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['OutputArray', 'R', '', []],
        ['OutputArray', 't', '', []],
        ['double', 'distanceThresh', '', []],
        ['InputOutputArray', 'mask', 'noArray()', []],
        ['OutputArray', 'triangulatedPoints', 'noArray()', []]],
    None,
    '@overload\n'
    '@param E The input essential matrix.\n'
    '@param points1 Array of N 2D points from the first image. The point '
    'coordinates should be\n'
    'floating-point (single or double precision).\n'
    '@param points2 Array of the second image points of the same size and '
    'format as points1.\n'
    '@param cameraMatrix Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n'
    'Note that this function assumes that points1 and points2 are feature '
    'points from cameras with the\n'
    'same camera matrix.\n'
    '@param R Recovered relative rotation.\n'
    '@param t Recovered relative translation.\n'
    '@param distanceThresh threshold distance which is used to filter out far '
    'away points (i.e. infinite points).\n'
    '@param mask Input/output mask for inliers in points1 and points2.\n'
    ':   If it is not empty, then it marks inliers in points1 and points2 for '
    'then given essential\n'
    'matrix E. Only these inliers will be used to recover pose. In the output '
    'mask only inliers\n'
    'which pass the cheirality check.\n'
    '@param triangulatedPoints 3d points which were reconstructed by '
    'triangulation.']
parse_name: cv.recoverPose with ['cv', 'cv::fisheye'] -> fullname:cv::recoverPose namespace:cv classpath: classname: name:recoverPose
register (function) recoverPose (cv_recoverPose__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_double__InputOutputArray__OutputArray)

--- Incoming ---
[   'cv.computeCorrespondEpilines',
    'void',
    [],
    [   ['InputArray', 'points', '', []],
        ['int', 'whichImage', '', []],
        ['InputArray', 'F', '', []],
        ['OutputArray', 'lines', '', []]],
    None,
    '@brief For points in an image of a stereo pair, computes the '
    'corresponding epilines in the other image.\n'
    '\n'
    '@param points Input points. \\f$N \\times 1\\f$ or \\f$1 \\times N\\f$ '
    'matrix of type CV_32FC2 or\n'
    'vector\\<Point2f\\> .\n'
    '@param whichImage Index of the image (1 or 2) that contains the points .\n'
    '@param F Fundamental matrix that can be estimated using '
    'findFundamentalMat or stereoRectify .\n'
    '@param lines Output vector of the epipolar lines corresponding to the '
    'points in the other image.\n'
    'Each line \\f$ax + by + c=0\\f$ is encoded by 3 numbers \\f$(a, b, c)\\f$ '
    '.\n'
    '\n'
    'For every point in one of the two images of a stereo pair, the function '
    'finds the equation of the\n'
    'corresponding epipolar line in the other image.\n'
    '\n'
    'From the fundamental matrix definition (see findFundamentalMat ), line '
    '\\f$l^{(2)}_i\\f$ in the second\n'
    'image for the point \\f$p^{(1)}_i\\f$ in the first image (when '
    'whichImage=1 ) is computed as:\n'
    '\n'
    '\\f[l^{(2)}_i = F p^{(1)}_i\\f]\n'
    '\n'
    'And vice versa, when whichImage=2, \\f$l^{(1)}_i\\f$ is computed from '
    '\\f$p^{(2)}_i\\f$ as:\n'
    '\n'
    '\\f[l^{(1)}_i = F^T p^{(2)}_i\\f]\n'
    '\n'
    'Line coefficients are defined up to a scale. They are normalized so that '
    '\\f$a_i^2+b_i^2=1\\f$ .']
parse_name: cv.computeCorrespondEpilines with ['cv', 'cv::fisheye'] -> fullname:cv::computeCorrespondEpilines namespace:cv classpath: classname: name:computeCorrespondEpilines
register (function) computeCorrespondEpilines (cv_computeCorrespondEpilines__InputArray_int__InputArray__OutputArray)

--- Incoming ---
[   'cv.triangulatePoints',
    'void',
    [],
    [   ['InputArray', 'projMatr1', '', []],
        ['InputArray', 'projMatr2', '', []],
        ['InputArray', 'projPoints1', '', []],
        ['InputArray', 'projPoints2', '', []],
        ['OutputArray', 'points4D', '', []]],
    None,
    '@brief Reconstructs points by triangulation.\n'
    '\n'
    '@param projMatr1 3x4 projection matrix of the first camera.\n'
    '@param projMatr2 3x4 projection matrix of the second camera.\n'
    '@param projPoints1 2xN array of feature points in the first image. In '
    'case of c++ version it can\n'
    'be also a vector of feature points or two-channel matrix of size 1xN or '
    'Nx1.\n'
    '@param projPoints2 2xN array of corresponding points in the second image. '
    'In case of c++ version\n'
    'it can be also a vector of feature points or two-channel matrix of size '
    '1xN or Nx1.\n'
    '@param points4D 4xN array of reconstructed points in homogeneous '
    'coordinates.\n'
    '\n'
    'The function reconstructs 3-dimensional points (in homogeneous '
    'coordinates) by using their\n'
    'observations with a stereo camera. Projections matrices can be obtained '
    'from stereoRectify.\n'
    '\n'
    '@note\n'
    'Keep in mind that all input data should be of float type in order for '
    'this function to work.\n'
    '\n'
    '@sa\n'
    'reprojectImageTo3D']
parse_name: cv.triangulatePoints with ['cv', 'cv::fisheye'] -> fullname:cv::triangulatePoints namespace:cv classpath: classname: name:triangulatePoints
register (function) triangulatePoints (cv_triangulatePoints__InputArray__InputArray__InputArray__InputArray__OutputArray)

--- Incoming ---
[   'cv.correctMatches',
    'void',
    [],
    [   ['InputArray', 'F', '', []],
        ['InputArray', 'points1', '', []],
        ['InputArray', 'points2', '', []],
        ['OutputArray', 'newPoints1', '', []],
        ['OutputArray', 'newPoints2', '', []]],
    None,
    '@brief Refines coordinates of corresponding points.\n'
    '\n'
    '@param F 3x3 fundamental matrix.\n'
    '@param points1 1xN array containing the first set of points.\n'
    '@param points2 1xN array containing the second set of points.\n'
    '@param newPoints1 The optimized points1.\n'
    '@param newPoints2 The optimized points2.\n'
    '\n'
    'The function implements the Optimal Triangulation Method (see Multiple '
    'View Geometry for details).\n'
    'For each given point correspondence points1[i] \\<-\\> points2[i], and a '
    'fundamental matrix F, it\n'
    'computes the corrected correspondences newPoints1[i] \\<-\\> '
    'newPoints2[i] that minimize the geometric\n'
    'error \\f$d(points1[i], newPoints1[i])^2 + '
    'd(points2[i],newPoints2[i])^2\\f$ (where \\f$d(a,b)\\f$ is the\n'
    'geometric distance between points \\f$a\\f$ and \\f$b\\f$ ) subject to '
    'the epipolar constraint\n'
    '\\f$newPoints2^T * F * newPoints1 = 0\\f$ .']
parse_name: cv.correctMatches with ['cv', 'cv::fisheye'] -> fullname:cv::correctMatches namespace:cv classpath: classname: name:correctMatches
register (function) correctMatches (cv_correctMatches__InputArray__InputArray__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.filterSpeckles',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['double', 'newVal', '', []],
        ['int', 'maxSpeckleSize', '', []],
        ['double', 'maxDiff', '', []],
        ['InputOutputArray', 'buf', 'noArray()', []]],
    None,
    '@brief Filters off small noise blobs (speckles) in the disparity map\n'
    '\n'
    '@param img The input 16-bit signed disparity image\n'
    '@param newVal The disparity value used to paint-off the speckles\n'
    '@param maxSpeckleSize The maximum speckle size to consider it a speckle. '
    'Larger blobs are not\n'
    'affected by the algorithm\n'
    '@param maxDiff Maximum difference between neighbor disparity pixels to '
    'put them into the same\n'
    'blob. Note that since StereoBM, StereoSGBM and may be other algorithms '
    'return a fixed-point\n'
    'disparity map, where disparity values are multiplied by 16, this scale '
    'factor should be taken into\n'
    'account when specifying this parameter value.\n'
    '@param buf The optional temporary buffer to avoid memory allocation '
    'within the function.']
parse_name: cv.filterSpeckles with ['cv', 'cv::fisheye'] -> fullname:cv::filterSpeckles namespace:cv classpath: classname: name:filterSpeckles
register (function) filterSpeckles (cv_filterSpeckles__InputOutputArray_double_int_double__InputOutputArray)

--- Incoming ---
[   'cv.getValidDisparityROI',
    'Rect',
    [],
    [   ['Rect', 'roi1', '', []],
        ['Rect', 'roi2', '', []],
        ['int', 'minDisparity', '', []],
        ['int', 'numberOfDisparities', '', []],
        ['int', 'SADWindowSize', '', []]],
    None,
    'computes valid disparity ROI from the valid ROIs of the rectified images '
    '(that are returned by cv::stereoRectify())']
parse_name: cv.getValidDisparityROI with ['cv', 'cv::fisheye'] -> fullname:cv::getValidDisparityROI namespace:cv classpath: classname: name:getValidDisparityROI
register (function) getValidDisparityROI (cv_getValidDisparityROI_Rect_Rect_int_int_int)

--- Incoming ---
[   'cv.validateDisparity',
    'void',
    [],
    [   ['InputOutputArray', 'disparity', '', []],
        ['InputArray', 'cost', '', []],
        ['int', 'minDisparity', '', []],
        ['int', 'numberOfDisparities', '', []],
        ['int', 'disp12MaxDisp', '1', []]],
    None,
    'validates disparity using the left-right check. The matrix "cost" should '
    'be computed by the stereo correspondence algorithm']
parse_name: cv.validateDisparity with ['cv', 'cv::fisheye'] -> fullname:cv::validateDisparity namespace:cv classpath: classname: name:validateDisparity
register (function) validateDisparity (cv_validateDisparity__InputOutputArray__InputArray_int_int_int)

--- Incoming ---
[   'cv.reprojectImageTo3D',
    'void',
    [],
    [   ['InputArray', 'disparity', '', []],
        ['OutputArray', '_3dImage', '', []],
        ['InputArray', 'Q', '', []],
        ['bool', 'handleMissingValues', 'false', []],
        ['int', 'ddepth', '-1', []]],
    None,
    '@brief Reprojects a disparity image to 3D space.\n'
    '\n'
    '@param disparity Input single-channel 8-bit unsigned, 16-bit signed, '
    '32-bit signed or 32-bit\n'
    'floating-point disparity image. If 16-bit signed format is used, the '
    'values are assumed to have no\n'
    'fractional bits.\n'
    '@param _3dImage Output 3-channel floating-point image of the same size as '
    'disparity . Each\n'
    'element of _3dImage(x,y) contains 3D coordinates of the point (x,y) '
    'computed from the disparity\n'
    'map.\n'
    '@param Q \\f$4 \\times 4\\f$ perspective transformation matrix that can '
    'be obtained with stereoRectify.\n'
    '@param handleMissingValues Indicates, whether the function should handle '
    'missing values (i.e.\n'
    'points where the disparity was not computed). If '
    'handleMissingValues=true, then pixels with the\n'
    'minimal disparity that corresponds to the outliers (see '
    'StereoMatcher::compute ) are transformed\n'
    'to 3D points with a very large Z value (currently set to 10000).\n'
    '@param ddepth The optional output array depth. If it is -1, the output '
    'image will have CV_32F\n'
    'depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.\n'
    '\n'
    'The function transforms a single-channel disparity map to a 3-channel '
    'image representing a 3D\n'
    'surface. That is, for each pixel (x,y) and the corresponding disparity '
    'd=disparity(x,y) , it\n'
    'computes:\n'
    '\n'
    '\\f[\\begin{array}{l} [X \\; Y \\; Z \\; W]^T =  \\texttt{Q} *[x \\; y '
    '\\; \\texttt{disparity} (x,y) \\; 1]^T  \\\\ \\texttt{\\_3dImage} (x,y) = '
    '(X/W, \\; Y/W, \\; Z/W) \\end{array}\\f]\n'
    '\n'
    'The matrix Q can be an arbitrary \\f$4 \\times 4\\f$ matrix (for example, '
    'the one computed by\n'
    'stereoRectify). To reproject a sparse set of points {(x,y,d),...} to 3D '
    'space, use\n'
    'perspectiveTransform .']
parse_name: cv.reprojectImageTo3D with ['cv', 'cv::fisheye'] -> fullname:cv::reprojectImageTo3D namespace:cv classpath: classname: name:reprojectImageTo3D
register (function) reprojectImageTo3D (cv_reprojectImageTo3D__InputArray__OutputArray__InputArray_bool_int)

--- Incoming ---
[   'cv.sampsonDistance',
    'double',
    [],
    [   ['InputArray', 'pt1', '', []],
        ['InputArray', 'pt2', '', []],
        ['InputArray', 'F', '', []]],
    None,
    '@brief Calculates the Sampson Distance between two points.\n'
    '\n'
    'The function cv::sampsonDistance calculates and returns the first order '
    'approximation of the geometric error as:\n'
    '\\f[\n'
    'sd( \\texttt{pt1} , \\texttt{pt2} )=\n'
    '\\frac{(\\texttt{pt2}^t \\cdot \\texttt{F} \\cdot \\texttt{pt1})^2}\n'
    '{((\\texttt{F} \\cdot \\texttt{pt1})(0))^2 +\n'
    '((\\texttt{F} \\cdot \\texttt{pt1})(1))^2 +\n'
    '((\\texttt{F}^t \\cdot \\texttt{pt2})(0))^2 +\n'
    '((\\texttt{F}^t \\cdot \\texttt{pt2})(1))^2}\n'
    '\\f]\n'
    'The fundamental matrix may be calculated using the cv::findFundamentalMat '
    'function. See @cite HartleyZ00 11.4.3 for details.\n'
    '@param pt1 first homogeneous 2d point\n'
    '@param pt2 second homogeneous 2d point\n'
    '@param F fundamental matrix\n'
    '@return The computed Sampson distance.']
parse_name: cv.sampsonDistance with ['cv', 'cv::fisheye'] -> fullname:cv::sampsonDistance namespace:cv classpath: classname: name:sampsonDistance
register (function) sampsonDistance (cv_sampsonDistance__InputArray__InputArray__InputArray)

--- Incoming ---
[   'cv.estimateAffine3D',
    'int',
    [],
    [   ['InputArray', 'src', '', []],
        ['InputArray', 'dst', '', []],
        ['OutputArray', 'out', '', []],
        ['OutputArray', 'inliers', '', []],
        ['double', 'ransacThreshold', '3', []],
        ['double', 'confidence', '0.99', []]],
    None,
    '@brief Computes an optimal affine transformation between two 3D point '
    'sets.\n'
    '\n'
    'It computes\n'
    '\\f[\n'
    '\\begin{bmatrix}\n'
    'x\\\\\n'
    'y\\\\\n'
    'z\\\\\n'
    '\\end{bmatrix}\n'
    '=\n'
    '\\begin{bmatrix}\n'
    'a_{11} & a_{12} & a_{13}\\\\\n'
    'a_{21} & a_{22} & a_{23}\\\\\n'
    'a_{31} & a_{32} & a_{33}\\\\\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X\\\\\n'
    'Y\\\\\n'
    'Z\\\\\n'
    '\\end{bmatrix}\n'
    '+\n'
    '\\begin{bmatrix}\n'
    'b_1\\\\\n'
    'b_2\\\\\n'
    'b_3\\\\\n'
    '\\end{bmatrix}\n'
    '\\f]\n'
    '\n'
    '@param src First input 3D point set containing \\f$(X,Y,Z)\\f$.\n'
    '@param dst Second input 3D point set containing \\f$(x,y,z)\\f$.\n'
    '@param out Output 3D affine transformation matrix \\f$3 \\times 4\\f$ of '
    'the form\n'
    '\\f[\n'
    '\\begin{bmatrix}\n'
    'a_{11} & a_{12} & a_{13} & b_1\\\\\n'
    'a_{21} & a_{22} & a_{23} & b_2\\\\\n'
    'a_{31} & a_{32} & a_{33} & b_3\\\\\n'
    '\\end{bmatrix}\n'
    '\\f]\n'
    '@param inliers Output vector indicating which points are inliers '
    '(1-inlier, 0-outlier).\n'
    '@param ransacThreshold Maximum reprojection error in the RANSAC algorithm '
    'to consider a point as\n'
    'an inlier.\n'
    '@param confidence Confidence level, between 0 and 1, for the estimated '
    'transformation. Anything\n'
    'between 0.95 and 0.99 is usually good enough. Values too close to 1 can '
    'slow down the estimation\n'
    'significantly. Values lower than 0.8-0.9 can result in an incorrectly '
    'estimated transformation.\n'
    '\n'
    'The function estimates an optimal 3D affine transformation between two 3D '
    'point sets using the\n'
    'RANSAC algorithm.']
parse_name: cv.estimateAffine3D with ['cv', 'cv::fisheye'] -> fullname:cv::estimateAffine3D namespace:cv classpath: classname: name:estimateAffine3D
register (function) estimateAffine3D (cv_estimateAffine3D__InputArray__InputArray__OutputArray__OutputArray_double_double)

--- Incoming ---
[   'cv.estimateAffine2D',
    'cv::Mat',
    [],
    [   ['InputArray', 'from', '', []],
        ['InputArray', 'to', '', []],
        ['OutputArray', 'inliers', 'noArray()', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'ransacReprojThreshold', '3', []],
        ['size_t', 'maxIters', '2000', []],
        ['double', 'confidence', '0.99', []],
        ['size_t', 'refineIters', '10', []]],
    None,
    '@brief Computes an optimal affine transformation between two 2D point '
    'sets.\n'
    '\n'
    'It computes\n'
    '\\f[\n'
    '\\begin{bmatrix}\n'
    'x\\\\\n'
    'y\\\\\n'
    '\\end{bmatrix}\n'
    '=\n'
    '\\begin{bmatrix}\n'
    'a_{11} & a_{12}\\\\\n'
    'a_{21} & a_{22}\\\\\n'
    '\\end{bmatrix}\n'
    '\\begin{bmatrix}\n'
    'X\\\\\n'
    'Y\\\\\n'
    '\\end{bmatrix}\n'
    '+\n'
    '\\begin{bmatrix}\n'
    'b_1\\\\\n'
    'b_2\\\\\n'
    '\\end{bmatrix}\n'
    '\\f]\n'
    '\n'
    '@param from First input 2D point set containing \\f$(X,Y)\\f$.\n'
    '@param to Second input 2D point set containing \\f$(x,y)\\f$.\n'
    '@param inliers Output vector indicating which points are inliers '
    '(1-inlier, 0-outlier).\n'
    '@param method Robust method used to compute transformation. The following '
    'methods are possible:\n'
    '-   cv::RANSAC - RANSAC-based robust method\n'
    '-   cv::LMEDS - Least-Median robust method\n'
    'RANSAC is the default method.\n'
    '@param ransacReprojThreshold Maximum reprojection error in the RANSAC '
    'algorithm to consider\n'
    'a point as an inlier. Applies only to RANSAC.\n'
    '@param maxIters The maximum number of robust method iterations.\n'
    '@param confidence Confidence level, between 0 and 1, for the estimated '
    'transformation. Anything\n'
    'between 0.95 and 0.99 is usually good enough. Values too close to 1 can '
    'slow down the estimation\n'
    'significantly. Values lower than 0.8-0.9 can result in an incorrectly '
    'estimated transformation.\n'
    '@param refineIters Maximum number of iterations of refining algorithm '
    '(Levenberg-Marquardt).\n'
    'Passing 0 will disable refining, so the output matrix will be output of '
    'robust method.\n'
    '\n'
    '@return Output 2D affine transformation matrix \\f$2 \\times 3\\f$ or '
    'empty matrix if transformation\n'
    'could not be estimated. The returned matrix has the following form:\n'
    '\\f[\n'
    '\\begin{bmatrix}\n'
    'a_{11} & a_{12} & b_1\\\\\n'
    'a_{21} & a_{22} & b_2\\\\\n'
    '\\end{bmatrix}\n'
    '\\f]\n'
    '\n'
    'The function estimates an optimal 2D affine transformation between two 2D '
    'point sets using the\n'
    'selected robust algorithm.\n'
    '\n'
    'The computed transformation is then refined further (using only inliers) '
    'with the\n'
    'Levenberg-Marquardt method to reduce the re-projection error even more.\n'
    '\n'
    '@note\n'
    'The RANSAC method can handle practically any ratio of outliers but needs '
    'a threshold to\n'
    'distinguish inliers from outliers. The method LMeDS does not need any '
    'threshold but it works\n'
    'correctly only when there are more than 50% of inliers.\n'
    '\n'
    '@sa estimateAffinePartial2D, getAffineTransform']
parse_name: cv.estimateAffine2D with ['cv', 'cv::fisheye'] -> fullname:cv::estimateAffine2D namespace:cv classpath: classname: name:estimateAffine2D
register (function) estimateAffine2D (cv_estimateAffine2D__InputArray__InputArray__OutputArray_int_double_size_t_double_size_t)

--- Incoming ---
[   'cv.estimateAffinePartial2D',
    'cv::Mat',
    [],
    [   ['InputArray', 'from', '', []],
        ['InputArray', 'to', '', []],
        ['OutputArray', 'inliers', 'noArray()', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'ransacReprojThreshold', '3', []],
        ['size_t', 'maxIters', '2000', []],
        ['double', 'confidence', '0.99', []],
        ['size_t', 'refineIters', '10', []]],
    None,
    '@brief Computes an optimal limited affine transformation with 4 degrees '
    'of freedom between\n'
    'two 2D point sets.\n'
    '\n'
    '@param from First input 2D point set.\n'
    '@param to Second input 2D point set.\n'
    '@param inliers Output vector indicating which points are inliers.\n'
    '@param method Robust method used to compute transformation. The following '
    'methods are possible:\n'
    '-   cv::RANSAC - RANSAC-based robust method\n'
    '-   cv::LMEDS - Least-Median robust method\n'
    'RANSAC is the default method.\n'
    '@param ransacReprojThreshold Maximum reprojection error in the RANSAC '
    'algorithm to consider\n'
    'a point as an inlier. Applies only to RANSAC.\n'
    '@param maxIters The maximum number of robust method iterations.\n'
    '@param confidence Confidence level, between 0 and 1, for the estimated '
    'transformation. Anything\n'
    'between 0.95 and 0.99 is usually good enough. Values too close to 1 can '
    'slow down the estimation\n'
    'significantly. Values lower than 0.8-0.9 can result in an incorrectly '
    'estimated transformation.\n'
    '@param refineIters Maximum number of iterations of refining algorithm '
    '(Levenberg-Marquardt).\n'
    'Passing 0 will disable refining, so the output matrix will be output of '
    'robust method.\n'
    '\n'
    '@return Output 2D affine transformation (4 degrees of freedom) matrix '
    '\\f$2 \\times 3\\f$ or\n'
    'empty matrix if transformation could not be estimated.\n'
    '\n'
    'The function estimates an optimal 2D affine transformation with 4 degrees '
    'of freedom limited to\n'
    'combinations of translation, rotation, and uniform scaling. Uses the '
    'selected algorithm for robust\n'
    'estimation.\n'
    '\n'
    'The computed transformation is then refined further (using only inliers) '
    'with the\n'
    'Levenberg-Marquardt method to reduce the re-projection error even more.\n'
    '\n'
    'Estimated transformation matrix is:\n'
    '\\f[ \\begin{bmatrix} \\cos(\\theta) \\cdot s & -\\sin(\\theta) \\cdot s '
    '& t_x \\\\\n'
    '\\sin(\\theta) \\cdot s & \\cos(\\theta) \\cdot s & t_y\n'
    '\\end{bmatrix} \\f]\n'
    'Where \\f$ \\theta \\f$ is the rotation angle, \\f$ s \\f$ the scaling '
    'factor and \\f$ t_x, t_y \\f$ are\n'
    'translations in \\f$ x, y \\f$ axes respectively.\n'
    '\n'
    '@note\n'
    'The RANSAC method can handle practically any ratio of outliers but need a '
    'threshold to\n'
    'distinguish inliers from outliers. The method LMeDS does not need any '
    'threshold but it works\n'
    'correctly only when there are more than 50% of inliers.\n'
    '\n'
    '@sa estimateAffine2D, getAffineTransform']
parse_name: cv.estimateAffinePartial2D with ['cv', 'cv::fisheye'] -> fullname:cv::estimateAffinePartial2D namespace:cv classpath: classname: name:estimateAffinePartial2D
register (function) estimateAffinePartial2D (cv_estimateAffinePartial2D__InputArray__InputArray__OutputArray_int_double_size_t_double_size_t)

--- Incoming ---
[   'cv.decomposeHomographyMat',
    'int',
    [],
    [   ['InputArray', 'H', '', []],
        ['InputArray', 'K', '', []],
        ['OutputArrayOfArrays', 'rotations', '', []],
        ['OutputArrayOfArrays', 'translations', '', []],
        ['OutputArrayOfArrays', 'normals', '', []]],
    None,
    '@brief Decompose a homography matrix to rotation(s), translation(s) and '
    'plane normal(s).\n'
    '\n'
    '@param H The input homography matrix between two images.\n'
    '@param K The input intrinsic camera calibration matrix.\n'
    '@param rotations Array of rotation matrices.\n'
    '@param translations Array of translation matrices.\n'
    '@param normals Array of plane normal matrices.\n'
    '\n'
    'This function extracts relative camera motion between two views observing '
    'a planar object from the\n'
    'homography H induced by the plane. The intrinsic camera matrix K must '
    'also be provided. The function\n'
    'may return up to four mathematical solution sets. At least two of the '
    'solutions may further be\n'
    'invalidated if point correspondences are available by applying positive '
    'depth constraint (all points\n'
    'must be in front of the camera). The decomposition method is described in '
    'detail in @cite Malis .']
parse_name: cv.decomposeHomographyMat with ['cv', 'cv::fisheye'] -> fullname:cv::decomposeHomographyMat namespace:cv classpath: classname: name:decomposeHomographyMat
register (function) decomposeHomographyMat (cv_decomposeHomographyMat__InputArray__InputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.filterHomographyDecompByVisibleRefpoints',
    'void',
    [],
    [   ['InputArrayOfArrays', 'rotations', '', []],
        ['InputArrayOfArrays', 'normals', '', []],
        ['InputArray', 'beforePoints', '', []],
        ['InputArray', 'afterPoints', '', []],
        ['OutputArray', 'possibleSolutions', '', []],
        ['InputArray', 'pointsMask', 'noArray()', []]],
    None,
    '@brief Filters homography decompositions based on additional '
    'information.\n'
    '\n'
    '@param rotations Vector of rotation matrices.\n'
    '@param normals Vector of plane normal matrices.\n'
    '@param beforePoints Vector of (rectified) visible reference points before '
    'the homography is applied\n'
    '@param afterPoints Vector of (rectified) visible reference points after '
    'the homography is applied\n'
    '@param possibleSolutions Vector of int indices representing the viable '
    'solution set after filtering\n'
    '@param pointsMask optional Mat/Vector of 8u type representing the mask '
    'for the inliers as given by the findHomography function\n'
    '\n'
    'This function is intended to filter the output of the '
    'decomposeHomographyMat based on additional\n'
    'information as described in @cite Malis . The summary of the method: the '
    'decomposeHomographyMat function\n'
    'returns 2 unique solutions and their "opposites" for a total of 4 '
    'solutions. If we have access to the\n'
    'sets of points visible in the camera frame before and after the '
    'homography transformation is applied,\n'
    'we can determine which are the true potential solutions and which are the '
    'opposites by verifying which\n'
    'homographies are consistent with all visible reference points being in '
    'front of the camera. The inputs\n'
    'are left unchanged; the filtered solution set is returned as indices into '
    'the existing one.']
parse_name: cv.filterHomographyDecompByVisibleRefpoints with ['cv', 'cv::fisheye'] -> fullname:cv::filterHomographyDecompByVisibleRefpoints namespace:cv classpath: classname: name:filterHomographyDecompByVisibleRefpoints
register (function) filterHomographyDecompByVisibleRefpoints (cv_filterHomographyDecompByVisibleRefpoints__InputArray__InputArray__InputArray__InputArray__OutputArray__InputArray)

--- Incoming ---
[   'class cv.StereoMatcher',
    ': cv::Algorithm',
    [],
    [],
    None,
    '@brief The base class for stereo correspondence algorithms.']
parse_name: class cv.StereoMatcher with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher namespace:cv classpath: classname: name:StereoMatcher
register class cv::StereoMatcher (['class cv.StereoMatcher', ': cv::Algorithm', [], [], None, '@brief The base class for stereo correspondence algorithms.']) impl:cv::Algorithm

--- Incoming ---
[   'enum cv.StereoMatcher.<unnamed>',
    '',
    [],
    [   ['const cv.StereoMatcher.DISP_SHIFT', '4', [], [], None, ''],
        [   'const cv.StereoMatcher.DISP_SCALE',
            '(1 << DISP_SHIFT)',
            [],
            [],
            None,
            '']],
    None,
    '']
parse_name: const cv.StereoMatcher.DISP_SHIFT with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::DISP_SHIFT namespace:cv classpath:StereoMatcher classname:StereoMatcher name:DISP_SHIFT
parse_name: const cv.StereoMatcher.DISP_SCALE with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::DISP_SCALE namespace:cv classpath:StereoMatcher classname:StereoMatcher name:DISP_SCALE

--- Incoming ---
[   'cv.StereoMatcher.compute',
    'void',
    ['/A'],
    [   ['InputArray', 'left', '', []],
        ['InputArray', 'right', '', []],
        ['OutputArray', 'disparity', '', []]],
    None,
    '@brief Computes disparity map for the specified stereo pair\n'
    '\n'
    '@param left Left 8-bit single-channel image.\n'
    '@param right Right image of the same size and the same type as the left '
    'one.\n'
    '@param disparity Output disparity map. It has the same size as the input '
    'images. Some algorithms,\n'
    'like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map '
    '(where each disparity value\n'
    'has 4 fractional bits), whereas other algorithms output 32-bit '
    'floating-point disparity map.']
parse_name: cv.StereoMatcher.compute with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::compute namespace:cv classpath:StereoMatcher classname:StereoMatcher name:compute
register (method) compute in cv::StereoMatcher (trait) (cv_StereoMatcher_compute__InputArray__InputArray__OutputArray)

--- Incoming ---
['cv.StereoMatcher.getMinDisparity', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoMatcher.getMinDisparity with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::getMinDisparity namespace:cv classpath:StereoMatcher classname:StereoMatcher name:getMinDisparity
register (method) getMinDisparity in cv::StereoMatcher (trait) (cv_StereoMatcher_getMinDisparity_const)

--- Incoming ---
[   'cv.StereoMatcher.setMinDisparity',
    'void',
    ['/A'],
    [['int', 'minDisparity', '', []]],
    None,
    '']
parse_name: cv.StereoMatcher.setMinDisparity with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::setMinDisparity namespace:cv classpath:StereoMatcher classname:StereoMatcher name:setMinDisparity
register (method) setMinDisparity in cv::StereoMatcher (trait) (cv_StereoMatcher_setMinDisparity_int)

--- Incoming ---
['cv.StereoMatcher.getNumDisparities', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoMatcher.getNumDisparities with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::getNumDisparities namespace:cv classpath:StereoMatcher classname:StereoMatcher name:getNumDisparities
register (method) getNumDisparities in cv::StereoMatcher (trait) (cv_StereoMatcher_getNumDisparities_const)

--- Incoming ---
[   'cv.StereoMatcher.setNumDisparities',
    'void',
    ['/A'],
    [['int', 'numDisparities', '', []]],
    None,
    '']
parse_name: cv.StereoMatcher.setNumDisparities with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::setNumDisparities namespace:cv classpath:StereoMatcher classname:StereoMatcher name:setNumDisparities
register (method) setNumDisparities in cv::StereoMatcher (trait) (cv_StereoMatcher_setNumDisparities_int)

--- Incoming ---
['cv.StereoMatcher.getBlockSize', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoMatcher.getBlockSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::getBlockSize namespace:cv classpath:StereoMatcher classname:StereoMatcher name:getBlockSize
register (method) getBlockSize in cv::StereoMatcher (trait) (cv_StereoMatcher_getBlockSize_const)

--- Incoming ---
[   'cv.StereoMatcher.setBlockSize',
    'void',
    ['/A'],
    [['int', 'blockSize', '', []]],
    None,
    '']
parse_name: cv.StereoMatcher.setBlockSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::setBlockSize namespace:cv classpath:StereoMatcher classname:StereoMatcher name:setBlockSize
register (method) setBlockSize in cv::StereoMatcher (trait) (cv_StereoMatcher_setBlockSize_int)

--- Incoming ---
['cv.StereoMatcher.getSpeckleWindowSize', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoMatcher.getSpeckleWindowSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::getSpeckleWindowSize namespace:cv classpath:StereoMatcher classname:StereoMatcher name:getSpeckleWindowSize
register (method) getSpeckleWindowSize in cv::StereoMatcher (trait) (cv_StereoMatcher_getSpeckleWindowSize_const)

--- Incoming ---
[   'cv.StereoMatcher.setSpeckleWindowSize',
    'void',
    ['/A'],
    [['int', 'speckleWindowSize', '', []]],
    None,
    '']
parse_name: cv.StereoMatcher.setSpeckleWindowSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::setSpeckleWindowSize namespace:cv classpath:StereoMatcher classname:StereoMatcher name:setSpeckleWindowSize
register (method) setSpeckleWindowSize in cv::StereoMatcher (trait) (cv_StereoMatcher_setSpeckleWindowSize_int)

--- Incoming ---
['cv.StereoMatcher.getSpeckleRange', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoMatcher.getSpeckleRange with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::getSpeckleRange namespace:cv classpath:StereoMatcher classname:StereoMatcher name:getSpeckleRange
register (method) getSpeckleRange in cv::StereoMatcher (trait) (cv_StereoMatcher_getSpeckleRange_const)

--- Incoming ---
[   'cv.StereoMatcher.setSpeckleRange',
    'void',
    ['/A'],
    [['int', 'speckleRange', '', []]],
    None,
    '']
parse_name: cv.StereoMatcher.setSpeckleRange with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::setSpeckleRange namespace:cv classpath:StereoMatcher classname:StereoMatcher name:setSpeckleRange
register (method) setSpeckleRange in cv::StereoMatcher (trait) (cv_StereoMatcher_setSpeckleRange_int)

--- Incoming ---
['cv.StereoMatcher.getDisp12MaxDiff', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoMatcher.getDisp12MaxDiff with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::getDisp12MaxDiff namespace:cv classpath:StereoMatcher classname:StereoMatcher name:getDisp12MaxDiff
register (method) getDisp12MaxDiff in cv::StereoMatcher (trait) (cv_StereoMatcher_getDisp12MaxDiff_const)

--- Incoming ---
[   'cv.StereoMatcher.setDisp12MaxDiff',
    'void',
    ['/A'],
    [['int', 'disp12MaxDiff', '', []]],
    None,
    '']
parse_name: cv.StereoMatcher.setDisp12MaxDiff with ['cv', 'cv::fisheye'] -> fullname:cv::StereoMatcher::setDisp12MaxDiff namespace:cv classpath:StereoMatcher classname:StereoMatcher name:setDisp12MaxDiff
register (method) setDisp12MaxDiff in cv::StereoMatcher (trait) (cv_StereoMatcher_setDisp12MaxDiff_int)

--- Incoming ---
[   'class cv.StereoBM',
    ': cv::StereoMatcher',
    [],
    [],
    None,
    '@brief Class for computing stereo correspondence using the block matching '
    'algorithm, introduced and\n'
    'contributed to OpenCV by K. Konolige.']
parse_name: class cv.StereoBM with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM namespace:cv classpath: classname: name:StereoBM
register class cv::StereoBM (['class cv.StereoBM', ': cv::StereoMatcher', [], [], None, '@brief Class for computing stereo correspondence using the block matching algorithm, introduced and\ncontributed to OpenCV by K. Konolige.']) impl:cv::StereoMatcher

--- Incoming ---
[   'enum cv.StereoBM.<unnamed>',
    '',
    [],
    [   [   'const cv.StereoBM.PREFILTER_NORMALIZED_RESPONSE',
            '0',
            [],
            [],
            None,
            ''],
        ['const cv.StereoBM.PREFILTER_XSOBEL', '1', [], [], None, '']],
    None,
    '']
parse_name: const cv.StereoBM.PREFILTER_NORMALIZED_RESPONSE with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::PREFILTER_NORMALIZED_RESPONSE namespace:cv classpath:StereoBM classname:StereoBM name:PREFILTER_NORMALIZED_RESPONSE
parse_name: const cv.StereoBM.PREFILTER_XSOBEL with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::PREFILTER_XSOBEL namespace:cv classpath:StereoBM classname:StereoBM name:PREFILTER_XSOBEL

--- Incoming ---
['cv.StereoBM.getPreFilterType', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getPreFilterType with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getPreFilterType namespace:cv classpath:StereoBM classname:StereoBM name:getPreFilterType
register (method) getPreFilterType in cv::StereoBM (trait) (cv_StereoBM_getPreFilterType_const)

--- Incoming ---
[   'cv.StereoBM.setPreFilterType',
    'void',
    ['/A'],
    [['int', 'preFilterType', '', []]],
    None,
    '']
parse_name: cv.StereoBM.setPreFilterType with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setPreFilterType namespace:cv classpath:StereoBM classname:StereoBM name:setPreFilterType
register (method) setPreFilterType in cv::StereoBM (trait) (cv_StereoBM_setPreFilterType_int)

--- Incoming ---
['cv.StereoBM.getPreFilterSize', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getPreFilterSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getPreFilterSize namespace:cv classpath:StereoBM classname:StereoBM name:getPreFilterSize
register (method) getPreFilterSize in cv::StereoBM (trait) (cv_StereoBM_getPreFilterSize_const)

--- Incoming ---
[   'cv.StereoBM.setPreFilterSize',
    'void',
    ['/A'],
    [['int', 'preFilterSize', '', []]],
    None,
    '']
parse_name: cv.StereoBM.setPreFilterSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setPreFilterSize namespace:cv classpath:StereoBM classname:StereoBM name:setPreFilterSize
register (method) setPreFilterSize in cv::StereoBM (trait) (cv_StereoBM_setPreFilterSize_int)

--- Incoming ---
['cv.StereoBM.getPreFilterCap', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getPreFilterCap with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getPreFilterCap namespace:cv classpath:StereoBM classname:StereoBM name:getPreFilterCap
register (method) getPreFilterCap in cv::StereoBM (trait) (cv_StereoBM_getPreFilterCap_const)

--- Incoming ---
[   'cv.StereoBM.setPreFilterCap',
    'void',
    ['/A'],
    [['int', 'preFilterCap', '', []]],
    None,
    '']
parse_name: cv.StereoBM.setPreFilterCap with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setPreFilterCap namespace:cv classpath:StereoBM classname:StereoBM name:setPreFilterCap
register (method) setPreFilterCap in cv::StereoBM (trait) (cv_StereoBM_setPreFilterCap_int)

--- Incoming ---
['cv.StereoBM.getTextureThreshold', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getTextureThreshold with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getTextureThreshold namespace:cv classpath:StereoBM classname:StereoBM name:getTextureThreshold
register (method) getTextureThreshold in cv::StereoBM (trait) (cv_StereoBM_getTextureThreshold_const)

--- Incoming ---
[   'cv.StereoBM.setTextureThreshold',
    'void',
    ['/A'],
    [['int', 'textureThreshold', '', []]],
    None,
    '']
parse_name: cv.StereoBM.setTextureThreshold with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setTextureThreshold namespace:cv classpath:StereoBM classname:StereoBM name:setTextureThreshold
register (method) setTextureThreshold in cv::StereoBM (trait) (cv_StereoBM_setTextureThreshold_int)

--- Incoming ---
['cv.StereoBM.getUniquenessRatio', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getUniquenessRatio with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getUniquenessRatio namespace:cv classpath:StereoBM classname:StereoBM name:getUniquenessRatio
register (method) getUniquenessRatio in cv::StereoBM (trait) (cv_StereoBM_getUniquenessRatio_const)

--- Incoming ---
[   'cv.StereoBM.setUniquenessRatio',
    'void',
    ['/A'],
    [['int', 'uniquenessRatio', '', []]],
    None,
    '']
parse_name: cv.StereoBM.setUniquenessRatio with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setUniquenessRatio namespace:cv classpath:StereoBM classname:StereoBM name:setUniquenessRatio
register (method) setUniquenessRatio in cv::StereoBM (trait) (cv_StereoBM_setUniquenessRatio_int)

--- Incoming ---
['cv.StereoBM.getSmallerBlockSize', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getSmallerBlockSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getSmallerBlockSize namespace:cv classpath:StereoBM classname:StereoBM name:getSmallerBlockSize
register (method) getSmallerBlockSize in cv::StereoBM (trait) (cv_StereoBM_getSmallerBlockSize_const)

--- Incoming ---
[   'cv.StereoBM.setSmallerBlockSize',
    'void',
    ['/A'],
    [['int', 'blockSize', '', []]],
    None,
    '']
parse_name: cv.StereoBM.setSmallerBlockSize with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setSmallerBlockSize namespace:cv classpath:StereoBM classname:StereoBM name:setSmallerBlockSize
register (method) setSmallerBlockSize in cv::StereoBM (trait) (cv_StereoBM_setSmallerBlockSize_int)

--- Incoming ---
['cv.StereoBM.getROI1', 'Rect', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getROI1 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getROI1 namespace:cv classpath:StereoBM classname:StereoBM name:getROI1
register (method) getROI1 in cv::StereoBM (trait) (cv_StereoBM_getROI1_const)

--- Incoming ---
['cv.StereoBM.setROI1', 'void', ['/A'], [['Rect', 'roi1', '', []]], None, '']
parse_name: cv.StereoBM.setROI1 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setROI1 namespace:cv classpath:StereoBM classname:StereoBM name:setROI1
register (method) setROI1 in cv::StereoBM (trait) (cv_StereoBM_setROI1_Rect)

--- Incoming ---
['cv.StereoBM.getROI2', 'Rect', ['/A', '/C'], [], None, '']
parse_name: cv.StereoBM.getROI2 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::getROI2 namespace:cv classpath:StereoBM classname:StereoBM name:getROI2
register (method) getROI2 in cv::StereoBM (trait) (cv_StereoBM_getROI2_const)

--- Incoming ---
['cv.StereoBM.setROI2', 'void', ['/A'], [['Rect', 'roi2', '', []]], None, '']
parse_name: cv.StereoBM.setROI2 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::setROI2 namespace:cv classpath:StereoBM classname:StereoBM name:setROI2
register (method) setROI2 in cv::StereoBM (trait) (cv_StereoBM_setROI2_Rect)

--- Incoming ---
[   'cv.StereoBM.create',
    'Ptr<StereoBM>',
    ['/S'],
    [['int', 'numDisparities', '0', []], ['int', 'blockSize', '21', []]],
    None,
    '@brief Creates StereoBM object\n'
    '\n'
    '@param numDisparities the disparity search range. For each pixel '
    'algorithm will find the best\n'
    'disparity from 0 (default minimum disparity) to numDisparities. The '
    'search range can then be\n'
    'shifted by changing the minimum disparity.\n'
    '@param blockSize the linear size of the blocks compared by the algorithm. '
    'The size should be odd\n'
    '(as the block is centered at the current pixel). Larger block size '
    'implies smoother, though less\n'
    'accurate disparity map. Smaller block size gives more detailed disparity '
    'map, but there is higher\n'
    'chance for algorithm to find a wrong correspondence.\n'
    '\n'
    'The function create StereoBM object. You can then call '
    'StereoBM::compute() to compute disparity for\n'
    'a specific stereo pair.']
parse_name: cv.StereoBM.create with ['cv', 'cv::fisheye'] -> fullname:cv::StereoBM::create namespace:cv classpath:StereoBM classname:StereoBM name:create
register (method) create in cv::StereoBM (trait) (cv_StereoBM_create_int_int)

--- Incoming ---
[   'class cv.StereoSGBM',
    ': cv::StereoMatcher',
    [],
    [],
    None,
    '@brief The class implements the modified H. Hirschmuller algorithm @cite '
    'HH08 that differs from the original\n'
    'one as follows:\n'
    '\n'
    '-   By default, the algorithm is single-pass, which means that you '
    'consider only 5 directions\n'
    'instead of 8. Set mode=StereoSGBM::MODE_HH in createStereoSGBM to run the '
    'full variant of the\n'
    'algorithm but beware that it may consume a lot of memory.\n'
    '-   The algorithm matches blocks, not individual pixels. Though, setting '
    'blockSize=1 reduces the\n'
    'blocks to single pixels.\n'
    '-   Mutual information cost function is not implemented. Instead, a '
    'simpler Birchfield-Tomasi\n'
    'sub-pixel metric from @cite BT98 is used. Though, the color images are '
    'supported as well.\n'
    '-   Some pre- and post- processing steps from K. Konolige algorithm '
    'StereoBM are included, for\n'
    'example: pre-filtering (StereoBM::PREFILTER_XSOBEL type) and '
    'post-filtering (uniqueness\n'
    'check, quadratic interpolation and speckle filtering).\n'
    '\n'
    '@note\n'
    '-   (Python) An example illustrating the use of the StereoSGBM matching '
    'algorithm can be found\n'
    'at opencv_source_code/samples/python/stereo_match.py']
parse_name: class cv.StereoSGBM with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM namespace:cv classpath: classname: name:StereoSGBM
register class cv::StereoSGBM (['class cv.StereoSGBM', ': cv::StereoMatcher', [], [], None, '@brief The class implements the modified H. Hirschmuller algorithm @cite HH08 that differs from the original\none as follows:\n\n-   By default, the algorithm is single-pass, which means that you consider only 5 directions\ninstead of 8. Set mode=StereoSGBM::MODE_HH in createStereoSGBM to run the full variant of the\nalgorithm but beware that it may consume a lot of memory.\n-   The algorithm matches blocks, not individual pixels. Though, setting blockSize=1 reduces the\nblocks to single pixels.\n-   Mutual information cost function is not implemented. Instead, a simpler Birchfield-Tomasi\nsub-pixel metric from @cite BT98 is used. Though, the color images are supported as well.\n-   Some pre- and post- processing steps from K. Konolige algorithm StereoBM are included, for\nexample: pre-filtering (StereoBM::PREFILTER_XSOBEL type) and post-filtering (uniqueness\ncheck, quadratic interpolation and speckle filtering).\n\n@note\n-   (Python) An example illustrating the use of the StereoSGBM matching algorithm can be found\nat opencv_source_code/samples/python/stereo_match.py']) impl:cv::StereoMatcher

--- Incoming ---
[   'enum cv.StereoSGBM.<unnamed>',
    '',
    [],
    [   ['const cv.StereoSGBM.MODE_SGBM', '0', [], [], None, ''],
        ['const cv.StereoSGBM.MODE_HH', '1', [], [], None, ''],
        ['const cv.StereoSGBM.MODE_SGBM_3WAY', '2', [], [], None, ''],
        ['const cv.StereoSGBM.MODE_HH4', '3', [], [], None, '']],
    None,
    '']
parse_name: const cv.StereoSGBM.MODE_SGBM with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::MODE_SGBM namespace:cv classpath:StereoSGBM classname:StereoSGBM name:MODE_SGBM
parse_name: const cv.StereoSGBM.MODE_HH with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::MODE_HH namespace:cv classpath:StereoSGBM classname:StereoSGBM name:MODE_HH
parse_name: const cv.StereoSGBM.MODE_SGBM_3WAY with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::MODE_SGBM_3WAY namespace:cv classpath:StereoSGBM classname:StereoSGBM name:MODE_SGBM_3WAY
parse_name: const cv.StereoSGBM.MODE_HH4 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::MODE_HH4 namespace:cv classpath:StereoSGBM classname:StereoSGBM name:MODE_HH4

--- Incoming ---
['cv.StereoSGBM.getPreFilterCap', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoSGBM.getPreFilterCap with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::getPreFilterCap namespace:cv classpath:StereoSGBM classname:StereoSGBM name:getPreFilterCap
register (method) getPreFilterCap in cv::StereoSGBM (trait) (cv_StereoSGBM_getPreFilterCap_const)

--- Incoming ---
[   'cv.StereoSGBM.setPreFilterCap',
    'void',
    ['/A'],
    [['int', 'preFilterCap', '', []]],
    None,
    '']
parse_name: cv.StereoSGBM.setPreFilterCap with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::setPreFilterCap namespace:cv classpath:StereoSGBM classname:StereoSGBM name:setPreFilterCap
register (method) setPreFilterCap in cv::StereoSGBM (trait) (cv_StereoSGBM_setPreFilterCap_int)

--- Incoming ---
['cv.StereoSGBM.getUniquenessRatio', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoSGBM.getUniquenessRatio with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::getUniquenessRatio namespace:cv classpath:StereoSGBM classname:StereoSGBM name:getUniquenessRatio
register (method) getUniquenessRatio in cv::StereoSGBM (trait) (cv_StereoSGBM_getUniquenessRatio_const)

--- Incoming ---
[   'cv.StereoSGBM.setUniquenessRatio',
    'void',
    ['/A'],
    [['int', 'uniquenessRatio', '', []]],
    None,
    '']
parse_name: cv.StereoSGBM.setUniquenessRatio with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::setUniquenessRatio namespace:cv classpath:StereoSGBM classname:StereoSGBM name:setUniquenessRatio
register (method) setUniquenessRatio in cv::StereoSGBM (trait) (cv_StereoSGBM_setUniquenessRatio_int)

--- Incoming ---
['cv.StereoSGBM.getP1', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoSGBM.getP1 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::getP1 namespace:cv classpath:StereoSGBM classname:StereoSGBM name:getP1
register (method) getP1 in cv::StereoSGBM (trait) (cv_StereoSGBM_getP1_const)

--- Incoming ---
['cv.StereoSGBM.setP1', 'void', ['/A'], [['int', 'P1', '', []]], None, '']
parse_name: cv.StereoSGBM.setP1 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::setP1 namespace:cv classpath:StereoSGBM classname:StereoSGBM name:setP1
register (method) setP1 in cv::StereoSGBM (trait) (cv_StereoSGBM_setP1_int)

--- Incoming ---
['cv.StereoSGBM.getP2', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoSGBM.getP2 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::getP2 namespace:cv classpath:StereoSGBM classname:StereoSGBM name:getP2
register (method) getP2 in cv::StereoSGBM (trait) (cv_StereoSGBM_getP2_const)

--- Incoming ---
['cv.StereoSGBM.setP2', 'void', ['/A'], [['int', 'P2', '', []]], None, '']
parse_name: cv.StereoSGBM.setP2 with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::setP2 namespace:cv classpath:StereoSGBM classname:StereoSGBM name:setP2
register (method) setP2 in cv::StereoSGBM (trait) (cv_StereoSGBM_setP2_int)

--- Incoming ---
['cv.StereoSGBM.getMode', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.StereoSGBM.getMode with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::getMode namespace:cv classpath:StereoSGBM classname:StereoSGBM name:getMode
register (method) getMode in cv::StereoSGBM (trait) (cv_StereoSGBM_getMode_const)

--- Incoming ---
['cv.StereoSGBM.setMode', 'void', ['/A'], [['int', 'mode', '', []]], None, '']
parse_name: cv.StereoSGBM.setMode with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::setMode namespace:cv classpath:StereoSGBM classname:StereoSGBM name:setMode
register (method) setMode in cv::StereoSGBM (trait) (cv_StereoSGBM_setMode_int)

--- Incoming ---
[   'cv.StereoSGBM.create',
    'Ptr<StereoSGBM>',
    ['/S'],
    [   ['int', 'minDisparity', '0', []],
        ['int', 'numDisparities', '16', []],
        ['int', 'blockSize', '3', []],
        ['int', 'P1', '0', []],
        ['int', 'P2', '0', []],
        ['int', 'disp12MaxDiff', '0', []],
        ['int', 'preFilterCap', '0', []],
        ['int', 'uniquenessRatio', '0', []],
        ['int', 'speckleWindowSize', '0', []],
        ['int', 'speckleRange', '0', []],
        ['int', 'mode', 'StereoSGBM::MODE_SGBM', []]],
    None,
    '@brief Creates StereoSGBM object\n'
    '\n'
    '@param minDisparity Minimum possible disparity value. Normally, it is '
    'zero but sometimes\n'
    'rectification algorithms can shift images, so this parameter needs to be '
    'adjusted accordingly.\n'
    '@param numDisparities Maximum disparity minus minimum disparity. The '
    'value is always greater than\n'
    'zero. In the current implementation, this parameter must be divisible by '
    '16.\n'
    '@param blockSize Matched block size. It must be an odd number \\>=1 . '
    'Normally, it should be\n'
    'somewhere in the 3..11 range.\n'
    '@param P1 The first parameter controlling the disparity smoothness. See '
    'below.\n'
    '@param P2 The second parameter controlling the disparity smoothness. The '
    'larger the values are,\n'
    'the smoother the disparity is. P1 is the penalty on the disparity change '
    'by plus or minus 1\n'
    'between neighbor pixels. P2 is the penalty on the disparity change by '
    'more than 1 between neighbor\n'
    'pixels. The algorithm requires P2 \\> P1 . See stereo_match.cpp sample '
    'where some reasonably good\n'
    'P1 and P2 values are shown (like '
    '8\\*number_of_image_channels\\*SADWindowSize\\*SADWindowSize and\n'
    '32\\*number_of_image_channels\\*SADWindowSize\\*SADWindowSize , '
    'respectively).\n'
    '@param disp12MaxDiff Maximum allowed difference (in integer pixel units) '
    'in the left-right\n'
    'disparity check. Set it to a non-positive value to disable the check.\n'
    '@param preFilterCap Truncation value for the prefiltered image pixels. '
    'The algorithm first\n'
    'computes x-derivative at each pixel and clips its value by '
    '[-preFilterCap, preFilterCap] interval.\n'
    'The result values are passed to the Birchfield-Tomasi pixel cost '
    'function.\n'
    '@param uniquenessRatio Margin in percentage by which the best (minimum) '
    'computed cost function\n'
    'value should "win" the second best value to consider the found match '
    'correct. Normally, a value\n'
    'within the 5-15 range is good enough.\n'
    '@param speckleWindowSize Maximum size of smooth disparity regions to '
    'consider their noise speckles\n'
    'and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set '
    'it somewhere in the\n'
    '50-200 range.\n'
    '@param speckleRange Maximum disparity variation within each connected '
    'component. If you do speckle\n'
    'filtering, set the parameter to a positive value, it will be implicitly '
    'multiplied by 16.\n'
    'Normally, 1 or 2 is good enough.\n'
    '@param mode Set it to StereoSGBM::MODE_HH to run the full-scale two-pass '
    'dynamic programming\n'
    'algorithm. It will consume O(W\\*H\\*numDisparities) bytes, which is '
    'large for 640x480 stereo and\n'
    'huge for HD-size pictures. By default, it is set to false .\n'
    '\n'
    'The first constructor initializes StereoSGBM with all the default '
    'parameters. So, you only have to\n'
    'set StereoSGBM::numDisparities at minimum. The second constructor enables '
    'you to set each parameter\n'
    'to a custom value.']
parse_name: cv.StereoSGBM.create with ['cv', 'cv::fisheye'] -> fullname:cv::StereoSGBM::create namespace:cv classpath:StereoSGBM classname:StereoSGBM name:create
register (method) create in cv::StereoSGBM (trait) (cv_StereoSGBM_create_int_int_int_int_int_int_int_int_int_int_int)

--- Incoming ---
[   'enum cv.UndistortTypes',
    '',
    [],
    [   ['const cv.PROJ_SPHERICAL_ORTHO', '0', [], [], None, ''],
        ['const cv.PROJ_SPHERICAL_EQRECT', '1', [], [], None, '']],
    None,
    'cv::undistort mode']
parse_name: const cv.PROJ_SPHERICAL_ORTHO with ['cv', 'cv::fisheye'] -> fullname:cv::PROJ_SPHERICAL_ORTHO namespace:cv classpath: classname: name:PROJ_SPHERICAL_ORTHO
parse_name: const cv.PROJ_SPHERICAL_EQRECT with ['cv', 'cv::fisheye'] -> fullname:cv::PROJ_SPHERICAL_EQRECT namespace:cv classpath: classname: name:PROJ_SPHERICAL_EQRECT
parse_name: enum cv.UndistortTypes with ['cv', 'cv::fisheye'] -> fullname:cv::UndistortTypes namespace:cv classpath: classname: name:UndistortTypes
parse_name: const cv.PROJ_SPHERICAL_ORTHO with ['cv', 'cv::fisheye'] -> fullname:cv::PROJ_SPHERICAL_ORTHO namespace:cv classpath: classname: name:PROJ_SPHERICAL_ORTHO
parse_name: const cv.PROJ_SPHERICAL_EQRECT with ['cv', 'cv::fisheye'] -> fullname:cv::PROJ_SPHERICAL_EQRECT namespace:cv classpath: classname: name:PROJ_SPHERICAL_EQRECT

--- Incoming ---
[   'cv.undistort',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['InputArray', 'newCameraMatrix', 'noArray()', []]],
    None,
    '@brief Transforms an image to compensate for lens distortion.\n'
    '\n'
    'The function transforms an image to compensate radial and tangential lens '
    'distortion.\n'
    '\n'
    'The function is simply a combination of #initUndistortRectifyMap (with '
    'unity R ) and #remap\n'
    '(with bilinear interpolation). See the former function for details of the '
    'transformation being\n'
    'performed.\n'
    '\n'
    'Those pixels in the destination image, for which there is no '
    'correspondent pixels in the source\n'
    'image, are filled with zeros (black color).\n'
    '\n'
    'A particular subset of the source image that will be visible in the '
    'corrected image can be regulated\n'
    'by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the '
    'appropriate\n'
    'newCameraMatrix depending on your requirements.\n'
    '\n'
    'The camera matrix and the distortion parameters can be determined using '
    '#calibrateCamera. If\n'
    'the resolution of images is different from the resolution used at the '
    'calibration stage, \\f$f_x,\n'
    'f_y, c_x\\f$ and \\f$c_y\\f$ need to be scaled accordingly, while the '
    'distortion coefficients remain\n'
    'the same.\n'
    '\n'
    '@param src Input (distorted) image.\n'
    '@param dst Output (corrected) image that has the same size and type as '
    'src .\n'
    '@param cameraMatrix Input camera matrix \\f$A = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$\n'
    'of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are assumed.\n'
    '@param newCameraMatrix Camera matrix of the distorted image. By default, '
    'it is the same as\n'
    'cameraMatrix but you may additionally scale and shift the result by using '
    'a different matrix.']
parse_name: cv.undistort with ['cv', 'cv::fisheye'] -> fullname:cv::undistort namespace:cv classpath: classname: name:undistort
register (function) undistort (cv_undistort__InputArray__OutputArray__InputArray__InputArray__InputArray)

--- Incoming ---
[   'cv.initUndistortRectifyMap',
    'void',
    [],
    [   ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['InputArray', 'R', '', []],
        ['InputArray', 'newCameraMatrix', '', []],
        ['Size', 'size', '', []],
        ['int', 'm1type', '', []],
        ['OutputArray', 'map1', '', []],
        ['OutputArray', 'map2', '', []]],
    None,
    '@brief Computes the undistortion and rectification transformation map.\n'
    '\n'
    'The function computes the joint undistortion and rectification '
    'transformation and represents the\n'
    'result in the form of maps for remap. The undistorted image looks like '
    'original, as if it is\n'
    'captured with a camera using the camera matrix =newCameraMatrix and zero '
    'distortion. In case of a\n'
    'monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it '
    'can be computed by\n'
    '#getOptimalNewCameraMatrix for a better control over scaling. In case of '
    'a stereo camera,\n'
    'newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .\n'
    '\n'
    'Also, this new camera is oriented differently in the coordinate space, '
    'according to R. That, for\n'
    'example, helps to align two heads of a stereo camera so that the epipolar '
    'lines on both images\n'
    'become horizontal and have the same y- coordinate (in case of a '
    'horizontally aligned stereo camera).\n'
    '\n'
    'The function actually builds the maps for the inverse mapping algorithm '
    'that is used by remap. That\n'
    'is, for each pixel \\f$(u, v)\\f$ in the destination (corrected and '
    'rectified) image, the function\n'
    'computes the corresponding coordinates in the source image (that is, in '
    'the original image from\n'
    'camera). The following process is applied:\n'
    '\\f[\n'
    '\\begin{array}{l}\n'
    "x  \\leftarrow (u - {c'}_x)/{f'}_x  \\\\\n"
    "y  \\leftarrow (v - {c'}_y)/{f'}_y  \\\\\n"
    '{[X\\,Y\\,W]} ^T  \\leftarrow R^{-1}*[x \\, y \\, 1]^T  \\\\\n'
    "x'  \\leftarrow X/W  \\\\\n"
    "y'  \\leftarrow Y/W  \\\\\n"
    "r^2  \\leftarrow x'^2 + y'^2 \\\\\n"
    "x''  \\leftarrow x' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + "
    'k_5 r^4 + k_6 r^6}\n'
    "+ 2p_1 x' y' + p_2(r^2 + 2 x'^2)  + s_1 r^2 + s_2 r^4\\\\\n"
    "y''  \\leftarrow y' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + "
    'k_5 r^4 + k_6 r^6}\n'
    "+ p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\\\\n"
    "s\\vecthree{x'''}{y'''}{1} =\n"
    '\\vecthreethree{R_{33}(\\tau_x, \\tau_y)}{0}{-R_{13}((\\tau_x, \\tau_y)}\n'
    '{0}{R_{33}(\\tau_x, \\tau_y)}{-R_{23}(\\tau_x, \\tau_y)}\n'
    "{0}{0}{1} R(\\tau_x, \\tau_y) \\vecthree{x''}{y''}{1}\\\\\n"
    "map_x(u,v)  \\leftarrow x''' f_x + c_x  \\\\\n"
    "map_y(u,v)  \\leftarrow y''' f_y + c_y\n"
    '\\end{array}\n'
    '\\f]\n'
    'where \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, '
    's_4[, \\tau_x, \\tau_y]]]])\\f$\n'
    'are the distortion coefficients.\n'
    '\n'
    'In case of a stereo camera, this function is called twice: once for each '
    'camera head, after\n'
    'stereoRectify, which in its turn is called after #stereoCalibrate. But if '
    'the stereo camera\n'
    'was not calibrated, it is still possible to compute the rectification '
    'transformations directly from\n'
    'the fundamental matrix using #stereoRectifyUncalibrated. For each camera, '
    'the function computes\n'
    'homography H as the rectification transformation in a pixel domain, not a '
    'rotation matrix R in 3D\n'
    'space. R can be computed from H as\n'
    '\\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot '
    '\\texttt{cameraMatrix}\\f]\n'
    'where cameraMatrix can be chosen arbitrarily.\n'
    '\n'
    '@param cameraMatrix Input camera matrix '
    '\\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$\n'
    'of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are assumed.\n'
    '@param R Optional rectification transformation in the object space (3x3 '
    'matrix). R1 or R2 ,\n'
    'computed by #stereoRectify can be passed here. If the matrix is empty, '
    'the identity transformation\n'
    'is assumed. In cvInitUndistortMap R assumed to be an identity matrix.\n'
    '@param newCameraMatrix New camera matrix '
    "\\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$.\n"
    '@param size Undistorted image size.\n'
    '@param m1type Type of the first output map that can be CV_32FC1, CV_32FC2 '
    'or CV_16SC2, see #convertMaps\n'
    '@param map1 The first output map.\n'
    '@param map2 The second output map.']
parse_name: cv.initUndistortRectifyMap with ['cv', 'cv::fisheye'] -> fullname:cv::initUndistortRectifyMap namespace:cv classpath: classname: name:initUndistortRectifyMap
register (function) initUndistortRectifyMap (cv_initUndistortRectifyMap__InputArray__InputArray__InputArray__InputArray_Size_int__OutputArray__OutputArray)

--- Incoming ---
[   'cv.initWideAngleProjMap',
    'float',
    [],
    [   ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['Size', 'imageSize', '', []],
        ['int', 'destImageWidth', '', []],
        ['int', 'm1type', '', []],
        ['OutputArray', 'map1', '', []],
        ['OutputArray', 'map2', '', []],
        ['enum UndistortTypes', 'projType', 'PROJ_SPHERICAL_EQRECT', []],
        ['double', 'alpha', '0', []]],
    None,
    'initializes maps for #remap for wide-angle']
parse_name: cv.initWideAngleProjMap with ['cv', 'cv::fisheye'] -> fullname:cv::initWideAngleProjMap namespace:cv classpath: classname: name:initWideAngleProjMap
register (function) initWideAngleProjMap (cv_initWideAngleProjMap__InputArray__InputArray_Size_int_int__OutputArray__OutputArray_UndistortTypes_double)

--- Incoming ---
[   'cv.initWideAngleProjMap',
    'float',
    [],
    [   ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['Size', 'imageSize', '', []],
        ['int', 'destImageWidth', '', []],
        ['int', 'm1type', '', []],
        ['OutputArray', 'map1', '', []],
        ['OutputArray', 'map2', '', []],
        ['int', 'projType', '', []],
        ['double', 'alpha', '0', []]],
    None,
    '']
parse_name: cv.initWideAngleProjMap with ['cv', 'cv::fisheye'] -> fullname:cv::initWideAngleProjMap namespace:cv classpath: classname: name:initWideAngleProjMap
register (function) initWideAngleProjMap (cv_initWideAngleProjMap__InputArray__InputArray_Size_int_int__OutputArray__OutputArray_int_double)

--- Incoming ---
[   'cv.getDefaultNewCameraMatrix',
    'Mat',
    [],
    [   ['InputArray', 'cameraMatrix', '', []],
        ['Size', 'imgsize', 'Size()', []],
        ['bool', 'centerPrincipalPoint', 'false', []]],
    None,
    '@brief Returns the default new camera matrix.\n'
    '\n'
    'The function returns the camera matrix that is either an exact copy of '
    'the input cameraMatrix (when\n'
    'centerPrinicipalPoint=false ), or the modified one (when '
    'centerPrincipalPoint=true).\n'
    '\n'
    'In the latter case, the new camera matrix will be:\n'
    '\n'
    '\\f[\\begin{bmatrix} f_x && 0 && ( \\texttt{imgSize.width} -1)*0.5  \\\\ '
    '0 && f_y && ( \\texttt{imgSize.height} -1)*0.5  \\\\ 0 && 0 && 1 '
    '\\end{bmatrix} ,\\f]\n'
    '\n'
    'where \\f$f_x\\f$ and \\f$f_y\\f$ are \\f$(0,0)\\f$ and \\f$(1,1)\\f$ '
    'elements of cameraMatrix, respectively.\n'
    '\n'
    'By default, the undistortion functions in OpenCV (see '
    '#initUndistortRectifyMap, #undistort) do not\n'
    'move the principal point. However, when you work with stereo, it is '
    'important to move the principal\n'
    'points in both views to the same y-coordinate (which is required by most '
    'of stereo correspondence\n'
    'algorithms), and may be to the same x-coordinate too. So, you can form '
    'the new camera matrix for\n'
    'each view where the principal points are located at the center.\n'
    '\n'
    '@param cameraMatrix Input camera matrix.\n'
    '@param imgsize Camera view image size in pixels.\n'
    '@param centerPrincipalPoint Location of the principal point in the new '
    'camera matrix. The\n'
    'parameter indicates whether this location should be at the image center '
    'or not.']
parse_name: cv.getDefaultNewCameraMatrix with ['cv', 'cv::fisheye'] -> fullname:cv::getDefaultNewCameraMatrix namespace:cv classpath: classname: name:getDefaultNewCameraMatrix
register (function) getDefaultNewCameraMatrix (cv_getDefaultNewCameraMatrix__InputArray_Size_bool)

--- Incoming ---
[   'cv.undistortPoints',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['InputArray', 'R', 'noArray()', []],
        ['InputArray', 'P', 'noArray()', []]],
    None,
    '@brief Computes the ideal point coordinates from the observed point '
    'coordinates.\n'
    '\n'
    'The function is similar to #undistort and #initUndistortRectifyMap but it '
    'operates on a\n'
    'sparse set of points instead of a raster image. Also the function '
    'performs a reverse transformation\n'
    'to projectPoints. In case of a 3D object, it does not reconstruct its 3D '
    'coordinates, but for a\n'
    'planar object, it does, up to a translation vector, if the proper R is '
    'specified.\n'
    '\n'
    'For each observed point coordinate \\f$(u, v)\\f$ the function computes:\n'
    '\\f[\n'
    '\\begin{array}{l}\n'
    'x^{"}  \\leftarrow (u - c_x)/f_x  \\\\\n'
    'y^{"}  \\leftarrow (v - c_y)/f_y  \\\\\n'
    '(x\',y\') = undistort(x^{"},y^{"}, \\texttt{distCoeffs}) \\\\\n'
    "{[X\\,Y\\,W]} ^T  \\leftarrow R*[x' \\, y' \\, 1]^T  \\\\\n"
    'x  \\leftarrow X/W  \\\\\n'
    'y  \\leftarrow Y/W  \\\\\n'
    '\\text{only performed if P is specified:} \\\\\n'
    "u'  \\leftarrow x {f'}_x + {c'}_x  \\\\\n"
    "v'  \\leftarrow y {f'}_y + {c'}_y\n"
    '\\end{array}\n'
    '\\f]\n'
    '\n'
    'where *undistort* is an approximate iterative algorithm that estimates '
    'the normalized original\n'
    'point coordinates out of the normalized distorted point coordinates '
    '("normalized" means that the\n'
    'coordinates do not depend on the camera matrix).\n'
    '\n'
    'The function can be used for both a stereo camera head or a monocular '
    'camera (when R is empty).\n'
    '@param src Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 '
    '2-channel (CV_32FC2 or CV_64FC2) (or\n'
    'vector\\<Point2f\\> ).\n'
    '@param dst Output ideal point coordinates (1xN/Nx1 2-channel or '
    'vector\\<Point2f\\> ) after undistortion and reverse perspective\n'
    'transformation. If matrix P is identity or omitted, dst will contain '
    'normalized point coordinates.\n'
    '@param cameraMatrix Camera matrix '
    '\\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n'
    '@param distCoeffs Input vector of distortion coefficients\n'
    '\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, '
    '\\tau_x, \\tau_y]]]])\\f$\n'
    'of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero '
    'distortion coefficients are assumed.\n'
    '@param R Rectification transformation in the object space (3x3 matrix). '
    'R1 or R2 computed by\n'
    '#stereoRectify can be passed here. If the matrix is empty, the identity '
    'transformation is used.\n'
    '@param P New camera matrix (3x3) or new projection matrix (3x4) '
    "\\f$\\begin{bmatrix} {f'}_x & 0 & {c'}_x & t_x \\\\ 0 & {f'}_y & {c'}_y & "
    't_y \\\\ 0 & 0 & 1 & t_z \\end{bmatrix}\\f$. P1 or P2 computed by\n'
    '#stereoRectify can be passed here. If the matrix is empty, the identity '
    'new camera matrix is used.']
parse_name: cv.undistortPoints with ['cv', 'cv::fisheye'] -> fullname:cv::undistortPoints namespace:cv classpath: classname: name:undistortPoints
register (function) undistortPoints (cv_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray)

--- Incoming ---
[   'cv.undistortPoints',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'cameraMatrix', '', []],
        ['InputArray', 'distCoeffs', '', []],
        ['InputArray', 'R', '', []],
        ['InputArray', 'P', '', []],
        ['TermCriteria', 'criteria', '', []]],
    None,
    '@overload\n'
    '@note Default version of #undistortPoints does 5 iterations to compute '
    'undistorted points.']
parse_name: cv.undistortPoints with ['cv', 'cv::fisheye'] -> fullname:cv::undistortPoints namespace:cv classpath: classname: name:undistortPoints
register (function) undistortPoints (cv_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray_TermCriteria)

--- Incoming ---
[   'enum cv.fisheye.<unnamed>',
    '',
    [],
    [   [   'const cv.fisheye.CALIB_USE_INTRINSIC_GUESS',
            '1 << 0',
            [],
            [],
            None,
            ''],
        [   'const cv.fisheye.CALIB_RECOMPUTE_EXTRINSIC',
            '1 << 1',
            [],
            [],
            None,
            ''],
        ['const cv.fisheye.CALIB_CHECK_COND', '1 << 2', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_SKEW', '1 << 3', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K1', '1 << 4', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K2', '1 << 5', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K3', '1 << 6', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K4', '1 << 7', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_INTRINSIC', '1 << 8', [], [], None, ''],
        [   'const cv.fisheye.CALIB_FIX_PRINCIPAL_POINT',
            '1 << 9',
            [],
            [],
            None,
            '']],
    None,
    '@addtogroup calib3d_fisheye\n@{']
parse_name: const cv.fisheye.CALIB_USE_INTRINSIC_GUESS with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_USE_INTRINSIC_GUESS namespace:cv::fisheye classpath: classname: name:CALIB_USE_INTRINSIC_GUESS
parse_name: const cv.fisheye.CALIB_RECOMPUTE_EXTRINSIC with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_RECOMPUTE_EXTRINSIC namespace:cv::fisheye classpath: classname: name:CALIB_RECOMPUTE_EXTRINSIC
parse_name: const cv.fisheye.CALIB_CHECK_COND with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_CHECK_COND namespace:cv::fisheye classpath: classname: name:CALIB_CHECK_COND
parse_name: const cv.fisheye.CALIB_FIX_SKEW with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_FIX_SKEW namespace:cv::fisheye classpath: classname: name:CALIB_FIX_SKEW
parse_name: const cv.fisheye.CALIB_FIX_K1 with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_FIX_K1 namespace:cv::fisheye classpath: classname: name:CALIB_FIX_K1
parse_name: const cv.fisheye.CALIB_FIX_K2 with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_FIX_K2 namespace:cv::fisheye classpath: classname: name:CALIB_FIX_K2
parse_name: const cv.fisheye.CALIB_FIX_K3 with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_FIX_K3 namespace:cv::fisheye classpath: classname: name:CALIB_FIX_K3
parse_name: const cv.fisheye.CALIB_FIX_K4 with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_FIX_K4 namespace:cv::fisheye classpath: classname: name:CALIB_FIX_K4
parse_name: const cv.fisheye.CALIB_FIX_INTRINSIC with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_FIX_INTRINSIC namespace:cv::fisheye classpath: classname: name:CALIB_FIX_INTRINSIC
parse_name: const cv.fisheye.CALIB_FIX_PRINCIPAL_POINT with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::CALIB_FIX_PRINCIPAL_POINT namespace:cv::fisheye classpath: classname: name:CALIB_FIX_PRINCIPAL_POINT

--- Incoming ---
[   'cv.fisheye.projectPoints',
    'void',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['OutputArray', 'imagePoints', '', []],
        ['const Affine3d&', 'affine', '', []],
        ['InputArray', 'K', '', []],
        ['InputArray', 'D', '', []],
        ['double', 'alpha', '0', []],
        ['OutputArray', 'jacobian', 'noArray()', []]],
    None,
    '@brief Projects points using fisheye model\n'
    '\n'
    '@param objectPoints Array of object points, 1xN/Nx1 3-channel (or '
    'vector\\<Point3f\\> ), where N is\n'
    'the number of points in the view.\n'
    '@param imagePoints Output array of image points, 2xN/Nx2 1-channel or '
    '1xN/Nx1 2-channel, or\n'
    'vector\\<Point2f\\>.\n'
    '@param affine\n'
    '@param K Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n'
    '@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, '
    'k_4)\\f$.\n'
    '@param alpha The skew coefficient.\n'
    '@param jacobian Optional output 2Nx15 jacobian matrix of derivatives of '
    'image points with respect\n'
    'to components of the focal lengths, coordinates of the principal point, '
    'distortion coefficients,\n'
    'rotation vector, translation vector, and the skew. In the old interface '
    'different components of\n'
    'the jacobian are returned via different output parameters.\n'
    '\n'
    'The function computes projections of 3D points to the image plane given '
    'intrinsic and extrinsic\n'
    'camera parameters. Optionally, the function computes Jacobians - matrices '
    'of partial derivatives of\n'
    'image points coordinates (as functions of all the input parameters) with '
    'respect to the particular\n'
    'parameters, intrinsic and/or extrinsic.']
parse_name: cv.fisheye.projectPoints with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::projectPoints namespace:cv::fisheye classpath: classname: name:projectPoints
Registering an unknown type: Affine3d
register (function) projectPoints (cv_fisheye_projectPoints__InputArray__OutputArray_Affine3d__InputArray__InputArray_double__OutputArray)

--- Incoming ---
[   'cv.fisheye.projectPoints',
    'void',
    [],
    [   ['InputArray', 'objectPoints', '', []],
        ['OutputArray', 'imagePoints', '', []],
        ['InputArray', 'rvec', '', []],
        ['InputArray', 'tvec', '', []],
        ['InputArray', 'K', '', []],
        ['InputArray', 'D', '', []],
        ['double', 'alpha', '0', []],
        ['OutputArray', 'jacobian', 'noArray()', []]],
    None,
    '@overload']
parse_name: cv.fisheye.projectPoints with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::projectPoints namespace:cv::fisheye classpath: classname: name:projectPoints
register (function) projectPoints (cv_fisheye_projectPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray_double__OutputArray)

--- Incoming ---
[   'cv.fisheye.distortPoints',
    'void',
    [],
    [   ['InputArray', 'undistorted', '', []],
        ['OutputArray', 'distorted', '', []],
        ['InputArray', 'K', '', []],
        ['InputArray', 'D', '', []],
        ['double', 'alpha', '0', []]],
    None,
    '@brief Distorts 2D points using fisheye model.\n'
    '\n'
    '@param undistorted Array of object points, 1xN/Nx1 2-channel (or '
    'vector\\<Point2f\\> ), where N is\n'
    'the number of points in the view.\n'
    '@param K Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n'
    '@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, '
    'k_4)\\f$.\n'
    '@param alpha The skew coefficient.\n'
    '@param distorted Output array of image points, 1xN/Nx1 2-channel, or '
    'vector\\<Point2f\\> .\n'
    '\n'
    'Note that the function assumes the camera matrix of the undistorted '
    'points to be identity.\n'
    'This means if you want to transform back points undistorted with '
    'undistortPoints() you have to\n'
    'multiply them with \\f$P^{-1}\\f$.']
parse_name: cv.fisheye.distortPoints with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::distortPoints namespace:cv::fisheye classpath: classname: name:distortPoints
register (function) distortPoints (cv_fisheye_distortPoints__InputArray__OutputArray__InputArray__InputArray_double)

--- Incoming ---
[   'cv.fisheye.undistortPoints',
    'void',
    [],
    [   ['InputArray', 'distorted', '', []],
        ['OutputArray', 'undistorted', '', []],
        ['InputArray', 'K', '', []],
        ['InputArray', 'D', '', []],
        ['InputArray', 'R', 'noArray()', []],
        ['InputArray', 'P', 'noArray()', []]],
    None,
    '@brief Undistorts 2D points using fisheye model\n'
    '\n'
    '@param distorted Array of object points, 1xN/Nx1 2-channel (or '
    'vector\\<Point2f\\> ), where N is the\n'
    'number of points in the view.\n'
    '@param K Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n'
    '@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, '
    'k_4)\\f$.\n'
    '@param R Rectification transformation in the object space: 3x3 1-channel, '
    'or vector: 3x1/1x3\n'
    '1-channel or 1x1 3-channel\n'
    '@param P New camera matrix (3x3) or new projection matrix (3x4)\n'
    '@param undistorted Output array of image points, 1xN/Nx1 2-channel, or '
    'vector\\<Point2f\\> .']
parse_name: cv.fisheye.undistortPoints with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::undistortPoints namespace:cv::fisheye classpath: classname: name:undistortPoints
register (function) undistortPoints (cv_fisheye_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray)

--- Incoming ---
[   'cv.fisheye.initUndistortRectifyMap',
    'void',
    [],
    [   ['InputArray', 'K', '', []],
        ['InputArray', 'D', '', []],
        ['InputArray', 'R', '', []],
        ['InputArray', 'P', '', []],
        ['const cv::Size&', 'size', '', []],
        ['int', 'm1type', '', []],
        ['OutputArray', 'map1', '', []],
        ['OutputArray', 'map2', '', []]],
    None,
    '@brief Computes undistortion and rectification maps for image transform '
    'by cv::remap(). If D is empty zero\n'
    'distortion is used, if R or P is empty identity matrixes are used.\n'
    '\n'
    '@param K Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n'
    '@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, '
    'k_4)\\f$.\n'
    '@param R Rectification transformation in the object space: 3x3 1-channel, '
    'or vector: 3x1/1x3\n'
    '1-channel or 1x1 3-channel\n'
    '@param P New camera matrix (3x3) or new projection matrix (3x4)\n'
    '@param size Undistorted image size.\n'
    '@param m1type Type of the first output map that can be CV_32FC1 or '
    'CV_16SC2 . See convertMaps()\n'
    'for details.\n'
    '@param map1 The first output map.\n'
    '@param map2 The second output map.']
parse_name: cv.fisheye.initUndistortRectifyMap with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::initUndistortRectifyMap namespace:cv::fisheye classpath: classname: name:initUndistortRectifyMap
register (function) initUndistortRectifyMap (cv_fisheye_initUndistortRectifyMap__InputArray__InputArray__InputArray__InputArray_Size_int__OutputArray__OutputArray)

--- Incoming ---
[   'cv.fisheye.undistortImage',
    'void',
    [],
    [   ['InputArray', 'distorted', '', []],
        ['OutputArray', 'undistorted', '', []],
        ['InputArray', 'K', '', []],
        ['InputArray', 'D', '', []],
        ['InputArray', 'Knew', 'cv::noArray()', []],
        ['const Size&', 'new_size', 'Size()', []]],
    None,
    '@brief Transforms an image to compensate for fisheye lens distortion.\n'
    '\n'
    '@param distorted image with fisheye lens distortion.\n'
    '@param undistorted Output image with compensated fisheye lens '
    'distortion.\n'
    '@param K Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n'
    '@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, '
    'k_4)\\f$.\n'
    '@param Knew Camera matrix of the distorted image. By default, it is the '
    'identity matrix but you\n'
    'may additionally scale and shift the result by using a different matrix.\n'
    '@param new_size the new size\n'
    '\n'
    'The function transforms an image to compensate radial and tangential lens '
    'distortion.\n'
    '\n'
    'The function is simply a combination of fisheye::initUndistortRectifyMap '
    '(with unity R ) and remap\n'
    '(with bilinear interpolation). See the former function for details of the '
    'transformation being\n'
    'performed.\n'
    '\n'
    'See below the results of undistortImage.\n'
    '-   a\\) result of undistort of perspective camera model (all possible '
    'coefficients (k_1, k_2, k_3,\n'
    'k_4, k_5, k_6) of distortion were optimized under calibration)\n'
    '-   b\\) result of fisheye::undistortImage of fisheye camera model (all '
    'possible coefficients (k_1, k_2,\n'
    'k_3, k_4) of fisheye distortion were optimized under calibration)\n'
    '-   c\\) original image was captured with fisheye lens\n'
    '\n'
    'Pictures a) and b) almost the same. But if we consider points of image '
    'located far from the center\n'
    'of image, we can notice that on image a) these points are distorted.\n'
    '\n'
    '![image](pics/fisheye_undistorted.jpg)']
parse_name: cv.fisheye.undistortImage with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::undistortImage namespace:cv::fisheye classpath: classname: name:undistortImage
register (function) undistortImage (cv_fisheye_undistortImage__InputArray__OutputArray__InputArray__InputArray__InputArray_Size)

--- Incoming ---
[   'cv.fisheye.estimateNewCameraMatrixForUndistortRectify',
    'void',
    [],
    [   ['InputArray', 'K', '', []],
        ['InputArray', 'D', '', []],
        ['const Size &', 'image_size', '', []],
        ['InputArray', 'R', '', []],
        ['OutputArray', 'P', '', []],
        ['double', 'balance', '0.0', []],
        ['const Size&', 'new_size', 'Size()', []],
        ['double', 'fov_scale', '1.0', []]],
    None,
    '@brief Estimates new camera matrix for undistortion or rectification.\n'
    '\n'
    '@param K Camera matrix \\f$K = '
    '\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n'
    '@param image_size Size of the image\n'
    '@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, '
    'k_4)\\f$.\n'
    '@param R Rectification transformation in the object space: 3x3 1-channel, '
    'or vector: 3x1/1x3\n'
    '1-channel or 1x1 3-channel\n'
    '@param P New camera matrix (3x3) or new projection matrix (3x4)\n'
    '@param balance Sets the new focal length in range between the min focal '
    'length and the max focal\n'
    'length. Balance is in range of [0, 1].\n'
    '@param new_size the new size\n'
    '@param fov_scale Divisor for new focal length.']
parse_name: cv.fisheye.estimateNewCameraMatrixForUndistortRectify with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::estimateNewCameraMatrixForUndistortRectify namespace:cv::fisheye classpath: classname: name:estimateNewCameraMatrixForUndistortRectify
register (function) estimateNewCameraMatrixForUndistortRectify (cv_fisheye_estimateNewCameraMatrixForUndistortRectify__InputArray__InputArray_Size__InputArray__OutputArray_double_Size_double)

--- Incoming ---
[   'cv.fisheye.calibrate',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints', '', []],
        ['const Size&', 'image_size', '', []],
        ['InputOutputArray', 'K', '', []],
        ['InputOutputArray', 'D', '', []],
        ['OutputArrayOfArrays', 'rvecs', '', []],
        ['OutputArrayOfArrays', 'tvecs', '', []],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, '
            'DBL_EPSILON)',
            []]],
    None,
    '@brief Performs camera calibaration\n'
    '\n'
    '@param objectPoints vector of vectors of calibration pattern points in '
    'the calibration pattern\n'
    'coordinate space.\n'
    '@param imagePoints vector of vectors of the projections of calibration '
    'pattern points.\n'
    'imagePoints.size() and objectPoints.size() and imagePoints[i].size() must '
    'be equal to\n'
    'objectPoints[i].size() for each i.\n'
    '@param image_size Size of the image used only to initialize the intrinsic '
    'camera matrix.\n'
    '@param K Output 3x3 floating-point camera matrix\n'
    '\\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . If\n'
    'fisheye::CALIB_USE_INTRINSIC_GUESS/ is specified, some or all of fx, fy, '
    'cx, cy must be\n'
    'initialized before calling the function.\n'
    '@param D Output vector of distortion coefficients \\f$(k_1, k_2, k_3, '
    'k_4)\\f$.\n'
    '@param rvecs Output vector of rotation vectors (see Rodrigues ) estimated '
    'for each pattern view.\n'
    'That is, each k-th rotation vector together with the corresponding k-th '
    'translation vector (see\n'
    'the next output parameter description) brings the calibration pattern '
    'from the model coordinate\n'
    'space (in which object points are specified) to the world coordinate '
    'space, that is, a real\n'
    'position of the calibration pattern in the k-th pattern view (k=0.. *M* '
    '-1).\n'
    '@param tvecs Output vector of translation vectors estimated for each '
    'pattern view.\n'
    '@param flags Different flags that may be zero or a combination of the '
    'following values:\n'
    '-   **fisheye::CALIB_USE_INTRINSIC_GUESS** cameraMatrix contains valid '
    'initial values of\n'
    'fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is '
    'initially set to the image\n'
    'center ( imageSize is used), and focal distances are computed in a '
    'least-squares fashion.\n'
    '-   **fisheye::CALIB_RECOMPUTE_EXTRINSIC** Extrinsic will be recomputed '
    'after each iteration\n'
    'of intrinsic optimization.\n'
    '-   **fisheye::CALIB_CHECK_COND** The functions will check validity of '
    'condition number.\n'
    '-   **fisheye::CALIB_FIX_SKEW** Skew coefficient (alpha) is set to zero '
    'and stay zero.\n'
    '-   **fisheye::CALIB_FIX_K1..fisheye::CALIB_FIX_K4** Selected distortion '
    'coefficients\n'
    'are set to zeros and stay zero.\n'
    '-   **fisheye::CALIB_FIX_PRINCIPAL_POINT** The principal point is not '
    'changed during the global\n'
    'optimization. It stays at the center or at a different location specified '
    'when CALIB_USE_INTRINSIC_GUESS is set too.\n'
    '@param criteria Termination criteria for the iterative optimization '
    'algorithm.']
parse_name: cv.fisheye.calibrate with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::calibrate namespace:cv::fisheye classpath: classname: name:calibrate
register (function) calibrate (cv_fisheye_calibrate__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
[   'cv.fisheye.stereoRectify',
    'void',
    [],
    [   ['InputArray', 'K1', '', []],
        ['InputArray', 'D1', '', []],
        ['InputArray', 'K2', '', []],
        ['InputArray', 'D2', '', []],
        ['const Size &', 'imageSize', '', []],
        ['InputArray', 'R', '', []],
        ['InputArray', 'tvec', '', []],
        ['OutputArray', 'R1', '', []],
        ['OutputArray', 'R2', '', []],
        ['OutputArray', 'P1', '', []],
        ['OutputArray', 'P2', '', []],
        ['OutputArray', 'Q', '', []],
        ['int', 'flags', '', []],
        ['const Size &', 'newImageSize', 'Size()', []],
        ['double', 'balance', '0.0', []],
        ['double', 'fov_scale', '1.0', []]],
    None,
    '@brief Stereo rectification for fisheye camera model\n'
    '\n'
    '@param K1 First camera matrix.\n'
    '@param D1 First camera distortion parameters.\n'
    '@param K2 Second camera matrix.\n'
    '@param D2 Second camera distortion parameters.\n'
    '@param imageSize Size of the image used for stereo calibration.\n'
    '@param R Rotation matrix between the coordinate systems of the first and '
    'the second\n'
    'cameras.\n'
    '@param tvec Translation vector between coordinate systems of the '
    'cameras.\n'
    '@param R1 Output 3x3 rectification transform (rotation matrix) for the '
    'first camera.\n'
    '@param R2 Output 3x3 rectification transform (rotation matrix) for the '
    'second camera.\n'
    '@param P1 Output 3x4 projection matrix in the new (rectified) coordinate '
    'systems for the first\n'
    'camera.\n'
    '@param P2 Output 3x4 projection matrix in the new (rectified) coordinate '
    'systems for the second\n'
    'camera.\n'
    '@param Q Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix '
    '(see reprojectImageTo3D ).\n'
    '@param flags Operation flags that may be zero or CALIB_ZERO_DISPARITY . '
    'If the flag is set,\n'
    'the function makes the principal points of each camera have the same '
    'pixel coordinates in the\n'
    'rectified views. And if the flag is not set, the function may still shift '
    'the images in the\n'
    'horizontal or vertical direction (depending on the orientation of '
    'epipolar lines) to maximize the\n'
    'useful image area.\n'
    '@param newImageSize New image resolution after rectification. The same '
    'size should be passed to\n'
    'initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV '
    'samples directory). When (0,0)\n'
    'is passed (default), it is set to the original imageSize . Setting it to '
    'larger value can help you\n'
    'preserve details in the original image, especially when there is a big '
    'radial distortion.\n'
    '@param balance Sets the new focal length in range between the min focal '
    'length and the max focal\n'
    'length. Balance is in range of [0, 1].\n'
    '@param fov_scale Divisor for new focal length.']
parse_name: cv.fisheye.stereoRectify with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::stereoRectify namespace:cv::fisheye classpath: classname: name:stereoRectify
register (function) stereoRectify (cv_fisheye_stereoRectify__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_Size_double_double)

--- Incoming ---
[   'cv.fisheye.stereoCalibrate',
    'double',
    [],
    [   ['InputArrayOfArrays', 'objectPoints', '', []],
        ['InputArrayOfArrays', 'imagePoints1', '', []],
        ['InputArrayOfArrays', 'imagePoints2', '', []],
        ['InputOutputArray', 'K1', '', []],
        ['InputOutputArray', 'D1', '', []],
        ['InputOutputArray', 'K2', '', []],
        ['InputOutputArray', 'D2', '', []],
        ['Size', 'imageSize', '', []],
        ['OutputArray', 'R', '', []],
        ['OutputArray', 'T', '', []],
        ['int', 'flags', 'fisheye::CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, '
            'DBL_EPSILON)',
            []]],
    None,
    '@brief Performs stereo calibration\n'
    '\n'
    '@param objectPoints Vector of vectors of the calibration pattern points.\n'
    '@param imagePoints1 Vector of vectors of the projections of the '
    'calibration pattern points,\n'
    'observed by the first camera.\n'
    '@param imagePoints2 Vector of vectors of the projections of the '
    'calibration pattern points,\n'
    'observed by the second camera.\n'
    '@param K1 Input/output first camera matrix:\n'
    '\\f$\\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\\f$ '
    ', \\f$j = 0,\\, 1\\f$ . If\n'
    'any of fisheye::CALIB_USE_INTRINSIC_GUESS , fisheye::CALIB_FIX_INTRINSIC '
    'are specified,\n'
    'some or all of the matrix components must be initialized.\n'
    '@param D1 Input/output vector of distortion coefficients \\f$(k_1, k_2, '
    'k_3, k_4)\\f$ of 4 elements.\n'
    '@param K2 Input/output second camera matrix. The parameter is similar to '
    'K1 .\n'
    '@param D2 Input/output lens distortion coefficients for the second '
    'camera. The parameter is\n'
    'similar to D1 .\n'
    '@param imageSize Size of the image used only to initialize intrinsic '
    'camera matrix.\n'
    '@param R Output rotation matrix between the 1st and the 2nd camera '
    'coordinate systems.\n'
    '@param T Output translation vector between the coordinate systems of the '
    'cameras.\n'
    '@param flags Different flags that may be zero or a combination of the '
    'following values:\n'
    '-   **fisheye::CALIB_FIX_INTRINSIC** Fix K1, K2? and D1, D2? so that only '
    'R, T matrices\n'
    'are estimated.\n'
    '-   **fisheye::CALIB_USE_INTRINSIC_GUESS** K1, K2 contains valid initial '
    'values of\n'
    'fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is '
    'initially set to the image\n'
    'center (imageSize is used), and focal distances are computed in a '
    'least-squares fashion.\n'
    '-   **fisheye::CALIB_RECOMPUTE_EXTRINSIC** Extrinsic will be recomputed '
    'after each iteration\n'
    'of intrinsic optimization.\n'
    '-   **fisheye::CALIB_CHECK_COND** The functions will check validity of '
    'condition number.\n'
    '-   **fisheye::CALIB_FIX_SKEW** Skew coefficient (alpha) is set to zero '
    'and stay zero.\n'
    '-   **fisheye::CALIB_FIX_K1..4** Selected distortion coefficients are set '
    'to zeros and stay\n'
    'zero.\n'
    '@param criteria Termination criteria for the iterative optimization '
    'algorithm.']
parse_name: cv.fisheye.stereoCalibrate with ['cv', 'cv::fisheye'] -> fullname:cv::fisheye::stereoCalibrate namespace:cv::fisheye classpath: classname: name:stereoCalibrate
register (function) stereoCalibrate (cv_fisheye_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__OutputArray__OutputArray_int_TermCriteria)

--- Incoming ---
['class CvLevMarq', '', [], [], None, '']
parse_name: class CvLevMarq with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq namespace: classpath: classname: name:CvLevMarq
register class CvLevMarq (['class CvLevMarq', '', [], [], None, '']) [ignored]

--- Incoming ---
['CvLevMarq.CvLevMarq', 'C', [], [], None, '']
parse_name: CvLevMarq.CvLevMarq with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::CvLevMarq namespace: classpath:CvLevMarq classname:CvLevMarq name:CvLevMarq
Registering an unknown type: CvLevMarq
register (constructor) default in CvLevMarq (ignored) (CvLevMarq_CvLevMarq)

--- Incoming ---
[   'CvLevMarq.CvLevMarq',
    'C',
    [],
    [   ['int', 'nparams', '', []],
        ['int', 'nerrs', '', []],
        [   'CvTermCriteria',
            'criteria',
            'cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON)',
            []],
        ['bool', 'completeSymmFlag', 'false', []]],
    None,
    '']
parse_name: CvLevMarq.CvLevMarq with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::CvLevMarq namespace: classpath:CvLevMarq classname:CvLevMarq name:CvLevMarq
Registering an unknown type: CvTermCriteria
register (constructor) new in CvLevMarq (ignored) (CvLevMarq_CvLevMarq_int_int_CvTermCriteria_bool)

--- Incoming ---
['CvLevMarq.~CvLevMarq', '~', [], [], None, '']
parse_name: CvLevMarq.~CvLevMarq with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::~CvLevMarq namespace: classpath:CvLevMarq classname:CvLevMarq name:~CvLevMarq
ignore destructor (method) ~CvLevMarq in CvLevMarq (ignored)

--- Incoming ---
[   'CvLevMarq.init',
    'void',
    [],
    [   ['int', 'nparams', '', []],
        ['int', 'nerrs', '', []],
        [   'CvTermCriteria',
            'criteria',
            'cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON)',
            []],
        ['bool', 'completeSymmFlag', 'false', []]],
    None,
    '']
parse_name: CvLevMarq.init with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::init namespace: classpath:CvLevMarq classname:CvLevMarq name:init
register (method) init in CvLevMarq (ignored) (CvLevMarq_init_int_int_CvTermCriteria_bool)

--- Incoming ---
[   'CvLevMarq.update',
    'bool',
    [],
    [   ['const CvMat*&', 'param', '', []],
        ['CvMat*&', 'J', '', []],
        ['CvMat*&', 'err', '', []]],
    None,
    '']
parse_name: CvLevMarq.update with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::update namespace: classpath:CvLevMarq classname:CvLevMarq name:update
Registering an unknown type: CvMat
register (method) update in CvLevMarq (ignored) (CvLevMarq_update_CvMat*_CvMat*_CvMat*)

--- Incoming ---
[   'CvLevMarq.updateAlt',
    'bool',
    [],
    [   ['const CvMat*&', 'param', '', []],
        ['CvMat*&', 'JtJ', '', []],
        ['CvMat*&', 'JtErr', '', []],
        ['double*&', 'errNorm', '', []]],
    None,
    '']
parse_name: CvLevMarq.updateAlt with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::updateAlt namespace: classpath:CvLevMarq classname:CvLevMarq name:updateAlt
register (method) updateAlt in CvLevMarq (ignored) (CvLevMarq_updateAlt_CvMat*_CvMat*_CvMat*_double_X)

--- Incoming ---
['CvLevMarq.clear', 'void', [], [], None, '']
parse_name: CvLevMarq.clear with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::clear namespace: classpath:CvLevMarq classname:CvLevMarq name:clear
register (method) clear in CvLevMarq (ignored) (CvLevMarq_clear)

--- Incoming ---
['CvLevMarq.step', 'void', [], [], None, '']
parse_name: CvLevMarq.step with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::step namespace: classpath:CvLevMarq classname:CvLevMarq name:step
register (method) step in CvLevMarq (ignored) (CvLevMarq_step)

--- Incoming ---
[   'enum CvLevMarq.<unnamed>',
    '',
    [],
    [   ['const CvLevMarq.DONE', '0', [], [], None, ''],
        ['const CvLevMarq.STARTED', '1', [], [], None, ''],
        ['const CvLevMarq.CALC_J', '2', [], [], None, ''],
        ['const CvLevMarq.CHECK_ERR', '3', [], [], None, '']],
    None,
    '']
parse_name: const CvLevMarq.DONE with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::DONE namespace: classpath:CvLevMarq classname:CvLevMarq name:DONE
parse_name: const CvLevMarq.STARTED with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::STARTED namespace: classpath:CvLevMarq classname:CvLevMarq name:STARTED
parse_name: const CvLevMarq.CALC_J with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::CALC_J namespace: classpath:CvLevMarq classname:CvLevMarq name:CALC_J
parse_name: const CvLevMarq.CHECK_ERR with ['cv', 'cv::fisheye'] -> fullname:CvLevMarq::CHECK_ERR namespace: classpath:CvLevMarq classname:CvLevMarq name:CHECK_ERR


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/calib3d/calib3d.hpp ================


Namespaces: ['cv', 'cv.fisheye']
Comment: {'calib3d': '\n@defgroup calib3d Camera Calibration and 3D Reconstruction\n\nThe functions in this section use a so-called pinhole camera model. In this model, a scene view is\nformed by projecting 3D points into the image plane using a perspective transformation.\n\n\\f[s  \\; m\' = A [R|t] M\'\\f]\n\nor\n\n\\f[s  \\vecthree{u}{v}{1} = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\n\\begin{bmatrix}\nr_{11} & r_{12} & r_{13} & t_1  \\\\\nr_{21} & r_{22} & r_{23} & t_2  \\\\\nr_{31} & r_{32} & r_{33} & t_3\n\\end{bmatrix}\n\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n1\n\\end{bmatrix}\\f]\n\nwhere:\n\n-   \\f$(X, Y, Z)\\f$ are the coordinates of a 3D point in the world coordinate space\n-   \\f$(u, v)\\f$ are the coordinates of the projection point in pixels\n-   \\f$A\\f$ is a camera matrix, or a matrix of intrinsic parameters\n-   \\f$(cx, cy)\\f$ is a principal point that is usually at the image center\n-   \\f$fx, fy\\f$ are the focal lengths expressed in pixel units.\n\nThus, if an image from the camera is scaled by a factor, all of these parameters should be scaled\n(multiplied/divided, respectively) by the same factor. The matrix of intrinsic parameters does not\ndepend on the scene viewed. So, once estimated, it can be re-used as long as the focal length is\nfixed (in case of zoom lens). The joint rotation-translation matrix \\f$[R|t]\\f$ is called a matrix of\nextrinsic parameters. It is used to describe the camera motion around a static scene, or vice versa,\nrigid motion of an object in front of a still camera. That is, \\f$[R|t]\\f$ translates coordinates of a\npoint \\f$(X, Y, Z)\\f$ to a coordinate system, fixed with respect to the camera. The transformation above\nis equivalent to the following (when \\f$z \\ne 0\\f$ ):\n\n\\f[\\begin{array}{l}\n\\vecthree{x}{y}{z} = R  \\vecthree{X}{Y}{Z} + t \\\\\nx\' = x/z \\\\\ny\' = y/z \\\\\nu = f_x*x\' + c_x \\\\\nv = f_y*y\' + c_y\n\\end{array}\\f]\n\nThe following figure illustrates the pinhole camera model.\n\n![Pinhole camera model](pics/pinhole_camera_model.png)\n\nReal lenses usually have some distortion, mostly radial distortion and slight tangential distortion.\nSo, the above model is extended as:\n\n\\f[\\begin{array}{l}\n\\vecthree{x}{y}{z} = R  \\vecthree{X}{Y}{Z} + t \\\\\nx\' = x/z \\\\\ny\' = y/z \\\\\nx\'\' = x\'  \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + 2 p_1 x\' y\' + p_2(r^2 + 2 x\'^2) + s_1 r^2 + s_2 r^4 \\\\\ny\'\' = y\'  \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + p_1 (r^2 + 2 y\'^2) + 2 p_2 x\' y\' + s_3 r^2 + s_4 r^4 \\\\\n\\text{where} \\quad r^2 = x\'^2 + y\'^2  \\\\\nu = f_x*x\'\' + c_x \\\\\nv = f_y*y\'\' + c_y\n\\end{array}\\f]\n\n\\f$k_1\\f$, \\f$k_2\\f$, \\f$k_3\\f$, \\f$k_4\\f$, \\f$k_5\\f$, and \\f$k_6\\f$ are radial distortion coefficients. \\f$p_1\\f$ and \\f$p_2\\f$ are\ntangential distortion coefficients. \\f$s_1\\f$, \\f$s_2\\f$, \\f$s_3\\f$, and \\f$s_4\\f$, are the thin prism distortion\ncoefficients. Higher-order coefficients are not considered in OpenCV.\n\nThe next figures show two common types of radial distortion: barrel distortion (typically \\f$ k_1 < 0 \\f$) and pincushion distortion (typically \\f$ k_1 > 0 \\f$).\n\n![](pics/distortion_examples.png)\n![](pics/distortion_examples2.png)\n\nIn some cases the image sensor may be tilted in order to focus an oblique plane in front of the\ncamera (Scheimpfug condition). This can be useful for particle image velocimetry (PIV) or\ntriangulation with a laser fan. The tilt causes a perspective distortion of \\f$x\'\'\\f$ and\n\\f$y\'\'\\f$. This distortion can be modelled in the following way, see e.g. @cite Louhichi07.\n\n\\f[\\begin{array}{l}\ns\\vecthree{x\'\'\'}{y\'\'\'}{1} =\n\\vecthreethree{R_{33}(\\tau_x, \\tau_y)}{0}{-R_{13}(\\tau_x, \\tau_y)}\n{0}{R_{33}(\\tau_x, \\tau_y)}{-R_{23}(\\tau_x, \\tau_y)}\n{0}{0}{1} R(\\tau_x, \\tau_y) \\vecthree{x\'\'}{y\'\'}{1}\\\\\nu = f_x*x\'\'\' + c_x \\\\\nv = f_y*y\'\'\' + c_y\n\\end{array}\\f]\n\nwhere the matrix \\f$R(\\tau_x, \\tau_y)\\f$ is defined by two rotations with angular parameter \\f$\\tau_x\\f$\nand \\f$\\tau_y\\f$, respectively,\n\n\\f[\nR(\\tau_x, \\tau_y) =\n\\vecthreethree{\\cos(\\tau_y)}{0}{-\\sin(\\tau_y)}{0}{1}{0}{\\sin(\\tau_y)}{0}{\\cos(\\tau_y)}\n\\vecthreethree{1}{0}{0}{0}{\\cos(\\tau_x)}{\\sin(\\tau_x)}{0}{-\\sin(\\tau_x)}{\\cos(\\tau_x)} =\n\\vecthreethree{\\cos(\\tau_y)}{\\sin(\\tau_y)\\sin(\\tau_x)}{-\\sin(\\tau_y)\\cos(\\tau_x)}\n{0}{\\cos(\\tau_x)}{\\sin(\\tau_x)}\n{\\sin(\\tau_y)}{-\\cos(\\tau_y)\\sin(\\tau_x)}{\\cos(\\tau_y)\\cos(\\tau_x)}.\n\\f]\n\nIn the functions below the coefficients are passed or returned as\n\n\\f[(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f]\n\nvector. That is, if the vector contains four elements, it means that \\f$k_3=0\\f$ . The distortion\ncoefficients do not depend on the scene viewed. Thus, they also belong to the intrinsic camera\nparameters. And they remain the same regardless of the captured image resolution. If, for example, a\ncamera has been calibrated on images of 320 x 240 resolution, absolutely the same distortion\ncoefficients can be used for 640 x 480 images from the same camera while \\f$f_x\\f$, \\f$f_y\\f$, \\f$c_x\\f$, and\n\\f$c_y\\f$ need to be scaled appropriately.\n\nThe functions below use the above model to do the following:\n\n-   Project 3D points to the image plane given intrinsic and extrinsic parameters.\n-   Compute extrinsic parameters given intrinsic parameters, a few 3D points, and their\nprojections.\n-   Estimate intrinsic and extrinsic camera parameters from several views of a known calibration\npattern (every view is described by several 3D-2D point correspondences).\n-   Estimate the relative position and orientation of the stereo camera "heads" and compute the\n*rectification* transformation that makes the camera optical axes parallel.\n\n@note\n-   A calibration sample for 3 cameras in horizontal position can be found at\nopencv_source_code/samples/cpp/3calibration.cpp\n-   A calibration sample based on a sequence of images can be found at\nopencv_source_code/samples/cpp/calibration.cpp\n-   A calibration sample in order to do 3D reconstruction can be found at\nopencv_source_code/samples/cpp/build3dmodel.cpp\n-   A calibration example on stereo calibration can be found at\nopencv_source_code/samples/cpp/stereo_calib.cpp\n-   A calibration example on stereo matching can be found at\nopencv_source_code/samples/cpp/stereo_match.cpp\n-   (Python) A camera calibration sample can be found at\nopencv_source_code/samples/python/calibrate.py\n\n@{\n@defgroup calib3d_fisheye Fisheye camera model\n\nDefinitions: Let P be a point in 3D of coordinates X in the world reference frame (stored in the\nmatrix X) The coordinate vector of P in the camera reference frame is:\n\n\\f[Xc = R X + T\\f]\n\nwhere R is the rotation matrix corresponding to the rotation vector om: R = rodrigues(om); call x, y\nand z the 3 coordinates of Xc:\n\n\\f[x = Xc_1 \\\\ y = Xc_2 \\\\ z = Xc_3\\f]\n\nThe pinhole projection coordinates of P is [a; b] where\n\n\\f[a = x / z \\ and \\ b = y / z \\\\ r^2 = a^2 + b^2 \\\\ \\theta = atan(r)\\f]\n\nFisheye distortion:\n\n\\f[\\theta_d = \\theta (1 + k_1 \\theta^2 + k_2 \\theta^4 + k_3 \\theta^6 + k_4 \\theta^8)\\f]\n\nThe distorted point coordinates are [x\'; y\'] where\n\n\\f[x\' = (\\theta_d / r) a \\\\ y\' = (\\theta_d / r) b \\f]\n\nFinally, conversion into pixel coordinates: The final pixel coordinates vector [u; v] where:\n\n\\f[u = f_x (x\' + \\alpha y\') + c_x \\\\\nv = f_y y\' + c_y\\f]\n\n@defgroup calib3d_c C API\n\n@}\n\n'}


===== Generating... =====
Generating func cv_RQDecomp3x3__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray
Generating func cv_Rodrigues__InputArray__OutputArray__OutputArray
Generating func cv_calibrateCameraRO__InputArray__InputArray_Size_int__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria
Generating func cv_calibrateCameraRO__InputArray__InputArray_Size_int__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria
Generating func cv_calibrateCamera__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria
Generating func cv_calibrateCamera__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria
Generating func cv_calibrateHandEye__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_HandEyeCalibrationMethod
Generating func cv_calibrationMatrixValues__InputArray_Size_double_double_double_double_double_Point2d_double
Generating func cv_checkChessboard__InputArray_Size
Generating func cv_composeRT__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray
Generating func cv_computeCorrespondEpilines__InputArray_int__InputArray__OutputArray
Generating func cv_convertPointsFromHomogeneous__InputArray__OutputArray
Generating func cv_convertPointsHomogeneous__InputArray__OutputArray
Generating func cv_convertPointsToHomogeneous__InputArray__OutputArray
Generating func cv_correctMatches__InputArray__InputArray__InputArray__OutputArray__OutputArray
Generating func cv_decomposeEssentialMat__InputArray__OutputArray__OutputArray__OutputArray
Generating func cv_decomposeHomographyMat__InputArray__InputArray__OutputArray__OutputArray__OutputArray
Generating func cv_decomposeProjectionMatrix__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray
Generating func cv_drawChessboardCorners__InputOutputArray_Size__InputArray_bool
Generating func cv_drawFrameAxes__InputOutputArray__InputArray__InputArray__InputArray__InputArray_float_int
Generating func cv_estimateAffine2D__InputArray__InputArray__OutputArray_int_double_size_t_double_size_t
Generating func cv_estimateAffine3D__InputArray__InputArray__OutputArray__OutputArray_double_double
Generating func cv_estimateAffinePartial2D__InputArray__InputArray__OutputArray_int_double_size_t_double_size_t
Generating func cv_filterHomographyDecompByVisibleRefpoints__InputArray__InputArray__InputArray__InputArray__OutputArray__InputArray
Generating func cv_filterSpeckles__InputOutputArray_double_int_double__InputOutputArray
Generating func cv_find4QuadCornerSubpix__InputArray__InputOutputArray_Size
Generating func cv_findChessboardCornersSB__InputArray_Size__OutputArray_int
Generating func cv_findChessboardCorners__InputArray_Size__OutputArray_int
Generating func cv_findCirclesGrid__InputArray_Size__OutputArray_int_PtrOfFeature2D
Generating func cv_findCirclesGrid__InputArray_Size__OutputArray_int_PtrOfFeature2D_CirclesGridFinderParameters
Generating func cv_findEssentialMat__InputArray__InputArray__InputArray_int_double_double__OutputArray
Generating func cv_findEssentialMat__InputArray__InputArray_double_Point2d_int_double_double__OutputArray
Generating func cv_findFundamentalMat__InputArray__InputArray__OutputArray_int_double_double
Generating func cv_findFundamentalMat__InputArray__InputArray_int_double_double__OutputArray
  ignored: ignored by rename table
Generating func cv_findHomography__InputArray__InputArray__OutputArray_int_double
Generating func cv_findHomography__InputArray__InputArray_int_double__OutputArray_int_double
Generating func cv_fisheye_calibrate__InputArray__InputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray_int_TermCriteria
Generating func cv_fisheye_distortPoints__InputArray__OutputArray__InputArray__InputArray_double
Generating func cv_fisheye_estimateNewCameraMatrixForUndistortRectify__InputArray__InputArray_Size__InputArray__OutputArray_double_Size_double
Generating func cv_fisheye_initUndistortRectifyMap__InputArray__InputArray__InputArray__InputArray_Size_int__OutputArray__OutputArray
Generating func cv_fisheye_projectPoints__InputArray__OutputArray_Affine3d__InputArray__InputArray_double__OutputArray
  ignored: can not map type Unknown[Affine3d] yet
Generating func cv_fisheye_projectPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray_double__OutputArray
Generating func cv_fisheye_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__OutputArray__OutputArray_int_TermCriteria
Generating func cv_fisheye_stereoRectify__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_Size_double_double
Generating func cv_fisheye_undistortImage__InputArray__OutputArray__InputArray__InputArray__InputArray_Size
Generating func cv_fisheye_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray
Generating func cv_getDefaultNewCameraMatrix__InputArray_Size_bool
Generating func cv_getOptimalNewCameraMatrix__InputArray__InputArray_Size_double_Size_Rect_X_bool
Generating func cv_getValidDisparityROI_Rect_Rect_int_int_int
Generating func cv_initCameraMatrix2D__InputArray__InputArray_Size_double
Generating func cv_initUndistortRectifyMap__InputArray__InputArray__InputArray__InputArray_Size_int__OutputArray__OutputArray
Generating func cv_initWideAngleProjMap__InputArray__InputArray_Size_int_int__OutputArray__OutputArray_UndistortTypes_double
Generating func cv_initWideAngleProjMap__InputArray__InputArray_Size_int_int__OutputArray__OutputArray_int_double
Generating func cv_matMulDeriv__InputArray__InputArray__OutputArray__OutputArray
Generating func cv_projectPoints__InputArray__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_double
Generating func cv_recoverPose__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__InputOutputArray
Generating func cv_recoverPose__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_double__InputOutputArray__OutputArray
Generating func cv_recoverPose__InputArray__InputArray__InputArray__OutputArray__OutputArray_double_Point2d__InputOutputArray
Generating func cv_rectify3Collinear__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_double_Size_Rect_X_Rect_X_int
Generating func cv_reprojectImageTo3D__InputArray__OutputArray__InputArray_bool_int
Generating func cv_sampsonDistance__InputArray__InputArray__InputArray
Generating func cv_solveP3P__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_int
Generating func cv_solvePnPGeneric__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_SolvePnPMethod__InputArray__InputArray__OutputArray
Generating func cv_solvePnPRansac__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int_float_double__OutputArray_int
Generating func cv_solvePnPRefineLM__InputArray__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray_TermCriteria
Generating func cv_solvePnPRefineVVS__InputArray__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray_TermCriteria_double
Generating func cv_solvePnP__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray_bool_int
Generating func cv_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__InputOutputArray__InputOutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria
Generating func cv_stereoCalibrate__InputArray__InputArray__InputArray__InputOutputArray__InputOutputArray__InputOutputArray__InputOutputArray_Size__OutputArray__OutputArray__OutputArray__OutputArray_int_TermCriteria
Generating func cv_stereoRectifyUncalibrated__InputArray__InputArray__InputArray_Size__OutputArray__OutputArray_double
Generating func cv_stereoRectify__InputArray__InputArray__InputArray__InputArray_Size__InputArray__InputArray__OutputArray__OutputArray__OutputArray__OutputArray__OutputArray_int_double_Size_Rect_X_Rect_X
Generating func cv_triangulatePoints__InputArray__InputArray__InputArray__InputArray__OutputArray
Generating func cv_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray
Generating func cv_undistortPoints__InputArray__OutputArray__InputArray__InputArray__InputArray__InputArray_TermCriteria
Generating func cv_undistort__InputArray__OutputArray__InputArray__InputArray__InputArray
Generating func cv_validateDisparity__InputOutputArray__InputArray_int_int_int
Manual ignore class CvLevMarq (ignored)
Ghost class cv::Algorithm (ghost, trait), ignoring
Generating func cv_CirclesGridFinderParameters_CirclesGridFinderParameters
Ghost class cv::DMatch (simple, ghost), ignoring
Ghost class cv::DescriptorMatcher (ghost, trait), ignoring
Ghost class cv::Feature2D (ghost, trait), ignoring
Ghost class cv::FileNode (ghost), ignoring
Ghost class cv::FileStorage (ghost), ignoring
Ghost class cv::KeyPoint (simple, ghost), ignoring
Generating impl for trait cv::LMSolver (trait)
Generating func cv_LMSolver_run_const__InputOutputArray
Generating func cv_LMSolver_setMaxIters_int
Generating func cv_LMSolver_getMaxIters_const
Generating func cv_LMSolver_create_PtrOfCallback_int
Generating func cv_LMSolver_create_PtrOfCallback_int_double
Generating impl for trait cv::LMSolver::Callback (trait)
Generating func cv_LMSolver_Callback_compute_const__InputArray__OutputArray__OutputArray
Ghost class cv::Mat (ghost), ignoring
Ghost class cv::MatExpr (ghost), ignoring
Ghost class cv::Range (ghost), ignoring
Ghost class cv::RotatedRect (ghost), ignoring
Generating impl for trait cv::StereoBM (trait)
Generating func cv_StereoBM_getPreFilterType_const
Generating func cv_StereoBM_setPreFilterType_int
Generating func cv_StereoBM_getPreFilterSize_const
Generating func cv_StereoBM_setPreFilterSize_int
Generating func cv_StereoBM_getPreFilterCap_const
Generating func cv_StereoBM_setPreFilterCap_int
Generating func cv_StereoBM_getTextureThreshold_const
Generating func cv_StereoBM_setTextureThreshold_int
Generating func cv_StereoBM_getUniquenessRatio_const
Generating func cv_StereoBM_setUniquenessRatio_int
Generating func cv_StereoBM_getSmallerBlockSize_const
Generating func cv_StereoBM_setSmallerBlockSize_int
Generating func cv_StereoBM_getROI1_const
Generating func cv_StereoBM_setROI1_Rect
Generating func cv_StereoBM_getROI2_const
Generating func cv_StereoBM_setROI2_Rect
Generating func cv_StereoBM_create_int_int
Generating impl for trait cv::StereoMatcher (trait)
Generating func cv_StereoMatcher_compute__InputArray__InputArray__OutputArray
Generating func cv_StereoMatcher_getMinDisparity_const
Generating func cv_StereoMatcher_setMinDisparity_int
Generating func cv_StereoMatcher_getNumDisparities_const
Generating func cv_StereoMatcher_setNumDisparities_int
Generating func cv_StereoMatcher_getBlockSize_const
Generating func cv_StereoMatcher_setBlockSize_int
Generating func cv_StereoMatcher_getSpeckleWindowSize_const
Generating func cv_StereoMatcher_setSpeckleWindowSize_int
Generating func cv_StereoMatcher_getSpeckleRange_const
Generating func cv_StereoMatcher_setSpeckleRange_int
Generating func cv_StereoMatcher_getDisp12MaxDiff_const
Generating func cv_StereoMatcher_setDisp12MaxDiff_int
Generating impl for trait cv::StereoSGBM (trait)
Generating func cv_StereoSGBM_getPreFilterCap_const
Generating func cv_StereoSGBM_setPreFilterCap_int
Generating func cv_StereoSGBM_getUniquenessRatio_const
Generating func cv_StereoSGBM_setUniquenessRatio_int
Generating func cv_StereoSGBM_getP1_const
Generating func cv_StereoSGBM_setP1_int
Generating func cv_StereoSGBM_getP2_const
Generating func cv_StereoSGBM_setP2_int
Generating func cv_StereoSGBM_getMode_const
Generating func cv_StereoSGBM_setMode_int
Generating func cv_StereoSGBM_create_int_int_int_int_int_int_int_int_int_int_int
Ghost class cv::TermCriteria (ghost), ignoring
Ghost class cv::UMat (ghost), ignoring
Ghost class cv::_InputArray (ghost, trait), ignoring
Ghost class cv::_InputOutputArray (ghost, trait), ignoring
Ghost class cv::_OutputArray (ghost, trait), ignoring
Ghost class cv::dnn::Layer (ghost, trait), ignoring
Ghost class cv::dnn::LayerParams (ghost), ignoring
Ghost class cv::utils::logging::LogTag (ghost), ignoring
