
--- Manual ---
('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']])
parse_name: class cv.Vec8i with ['cv'] -> fullname:cv::Vec8i namespace:cv classpath: classname: name:Vec8i
register class cv::Vec8i (('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']]))

--- Manual ---
('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6d with ['cv'] -> fullname:cv::Vec6d namespace:cv classpath: classname: name:Vec6d
register class cv::Vec6d (('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6f with ['cv'] -> fullname:cv::Vec6f namespace:cv classpath: classname: name:Vec6f
register class cv::Vec6f (('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6i with ['cv'] -> fullname:cv::Vec6i namespace:cv classpath: classname: name:Vec6i
register class cv::Vec6i (('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4d with ['cv'] -> fullname:cv::Vec4d namespace:cv classpath: classname: name:Vec4d
register class cv::Vec4d (('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4f with ['cv'] -> fullname:cv::Vec4f namespace:cv classpath: classname: name:Vec4f
register class cv::Vec4f (('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4i with ['cv'] -> fullname:cv::Vec4i namespace:cv classpath: classname: name:Vec4i
register class cv::Vec4i (('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4w with ['cv'] -> fullname:cv::Vec4w namespace:cv classpath: classname: name:Vec4w
register class cv::Vec4w (('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4s with ['cv'] -> fullname:cv::Vec4s namespace:cv classpath: classname: name:Vec4s
register class cv::Vec4s (('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4b with ['cv'] -> fullname:cv::Vec4b namespace:cv classpath: classname: name:Vec4b
register class cv::Vec4b (('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3d with ['cv'] -> fullname:cv::Vec3d namespace:cv classpath: classname: name:Vec3d
register class cv::Vec3d (('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3f with ['cv'] -> fullname:cv::Vec3f namespace:cv classpath: classname: name:Vec3f
register class cv::Vec3f (('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3i with ['cv'] -> fullname:cv::Vec3i namespace:cv classpath: classname: name:Vec3i
register class cv::Vec3i (('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3w with ['cv'] -> fullname:cv::Vec3w namespace:cv classpath: classname: name:Vec3w
register class cv::Vec3w (('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3s with ['cv'] -> fullname:cv::Vec3s namespace:cv classpath: classname: name:Vec3s
register class cv::Vec3s (('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3b with ['cv'] -> fullname:cv::Vec3b namespace:cv classpath: classname: name:Vec3b
register class cv::Vec3b (('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2d with ['cv'] -> fullname:cv::Vec2d namespace:cv classpath: classname: name:Vec2d
register class cv::Vec2d (('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2d',
    '',
    ['/Simple'],
    [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']])
parse_name: class cv.Size2d with ['cv'] -> fullname:cv::Size2d namespace:cv classpath: classname: name:Size2d
register class cv::Size2d (('class cv.Size2d', '', ['/Simple'], [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2d',
    '',
    ['/Simple'],
    [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']])
parse_name: class cv.Point2d with ['cv'] -> fullname:cv::Point2d namespace:cv classpath: classname: name:Point2d
register class cv::Point2d (('class cv.Point2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2d',
    '',
    ['/Simple'],
    [   ['double', 'x', '', '/RW'],
        ['double', 'y', '', '/RW'],
        ['double', 'width', '', '/RW'],
        ['double', 'height', '', '/RW']])
parse_name: class cv.Rect2d with ['cv'] -> fullname:cv::Rect2d namespace:cv classpath: classname: name:Rect2d
register class cv::Rect2d (('class cv.Rect2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW'], ['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2f with ['cv'] -> fullname:cv::Vec2f namespace:cv classpath: classname: name:Vec2f
register class cv::Vec2f (('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2f',
    '',
    ['/Simple'],
    [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']])
parse_name: class cv.Size2f with ['cv'] -> fullname:cv::Size2f namespace:cv classpath: classname: name:Size2f
register class cv::Size2f (('class cv.Size2f', '', ['/Simple'], [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2f',
    '',
    ['/Simple'],
    [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']])
parse_name: class cv.Point2f with ['cv'] -> fullname:cv::Point2f namespace:cv classpath: classname: name:Point2f
register class cv::Point2f (('class cv.Point2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2f',
    '',
    ['/Simple'],
    [   ['float', 'x', '', '/RW'],
        ['float', 'y', '', '/RW'],
        ['float', 'width', '', '/RW'],
        ['float', 'height', '', '/RW']])
parse_name: class cv.Rect2f with ['cv'] -> fullname:cv::Rect2f namespace:cv classpath: classname: name:Rect2f
register class cv::Rect2f (('class cv.Rect2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW'], ['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size2l',
    '',
    ['/Simple'],
    [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']])
parse_name: class cv.Size2l with ['cv'] -> fullname:cv::Size2l namespace:cv classpath: classname: name:Size2l
register class cv::Size2l (('class cv.Size2l', '', ['/Simple'], [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2l',
    '',
    ['/Simple'],
    [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']])
parse_name: class cv.Point2l with ['cv'] -> fullname:cv::Point2l namespace:cv classpath: classname: name:Point2l
register class cv::Point2l (('class cv.Point2l', '', ['/Simple'], [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']]))

--- Manual ---
('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2i with ['cv'] -> fullname:cv::Vec2i namespace:cv classpath: classname: name:Vec2i
register class cv::Vec2i (('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2i',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size2i with ['cv'] -> fullname:cv::Size2i namespace:cv classpath: classname: name:Size2i
register class cv::Size2i (('class cv.Size2i', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2i',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point2i with ['cv'] -> fullname:cv::Point2i namespace:cv classpath: classname: name:Point2i
register class cv::Point2i (('class cv.Point2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2i',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect2i with ['cv'] -> fullname:cv::Rect2i namespace:cv classpath: classname: name:Rect2i
register class cv::Rect2i (('class cv.Rect2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size with ['cv'] -> fullname:cv::Size namespace:cv classpath: classname: name:Size
register class cv::Size (('class cv.Size', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point with ['cv'] -> fullname:cv::Point namespace:cv classpath: classname: name:Point
register class cv::Point (('class cv.Point', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect with ['cv'] -> fullname:cv::Rect namespace:cv classpath: classname: name:Rect
register class cv::Rect (('class cv.Rect', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2w with ['cv'] -> fullname:cv::Vec2w namespace:cv classpath: classname: name:Vec2w
register class cv::Vec2w (('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2s with ['cv'] -> fullname:cv::Vec2s namespace:cv classpath: classname: name:Vec2s
register class cv::Vec2s (('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2b with ['cv'] -> fullname:cv::Vec2b namespace:cv classpath: classname: name:Vec2b
register class cv::Vec2b (('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Scalar with ['cv'] -> fullname:cv::Scalar namespace:cv classpath: classname: name:Scalar
register class cv::Scalar (('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv._InputArray', '', ['/Ghost'], [])
parse_name: class cv._InputArray with ['cv'] -> fullname:cv::_InputArray namespace:cv classpath: classname: name:_InputArray
register class cv::_InputArray (('class cv._InputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputArray', 'const _InputArray&', [], [])
parse_name: typedef cv.InputArray with ['cv'] -> fullname:cv::InputArray namespace:cv classpath: classname: name:InputArray
Registering an unknown type: InputArray

--- Manual ---
('class cv._OutputArray', '', ['/Ghost'], [])
parse_name: class cv._OutputArray with ['cv'] -> fullname:cv::_OutputArray namespace:cv classpath: classname: name:_OutputArray
register class cv::_OutputArray (('class cv._OutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.OutputArray', '_OutputArray&', [], [])
parse_name: typedef cv.OutputArray with ['cv'] -> fullname:cv::OutputArray namespace:cv classpath: classname: name:OutputArray
Registering an unknown type: OutputArray

--- Manual ---
('class cv._InputOutputArray', '', ['/Ghost'], [])
parse_name: class cv._InputOutputArray with ['cv'] -> fullname:cv::_InputOutputArray namespace:cv classpath: classname: name:_InputOutputArray
register class cv::_InputOutputArray (('class cv._InputOutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputOutputArray', '_InputOutputArray&', [], [])
parse_name: typedef cv.InputOutputArray with ['cv'] -> fullname:cv::InputOutputArray namespace:cv classpath: classname: name:InputOutputArray
Registering an unknown type: InputOutputArray

--- Manual ---
('typedef cv.InputArrayOfArrays', 'InputArray', [], [])
parse_name: typedef cv.InputArrayOfArrays with ['cv'] -> fullname:cv::InputArrayOfArrays namespace:cv classpath: classname: name:InputArrayOfArrays
Registering an unknown type: InputArrayOfArrays

--- Manual ---
('typedef cv.OutputArrayOfArrays', 'OutputArray', [], [])
parse_name: typedef cv.OutputArrayOfArrays with ['cv'] -> fullname:cv::OutputArrayOfArrays namespace:cv classpath: classname: name:OutputArrayOfArrays
Registering an unknown type: OutputArrayOfArrays

--- Manual ---
('typedef cv.InputOutputArrayOfArrays', 'InputOutputArray', [], [])
parse_name: typedef cv.InputOutputArrayOfArrays with ['cv'] -> fullname:cv::InputOutputArrayOfArrays namespace:cv classpath: classname: name:InputOutputArrayOfArrays
Registering an unknown type: InputOutputArrayOfArrays

--- Manual ---
('class cv.Range', '', ['/Ghost'], [])
parse_name: class cv.Range with ['cv'] -> fullname:cv::Range namespace:cv classpath: classname: name:Range
register class cv::Range (('class cv.Range', '', ['/Ghost'], []))

--- Manual ---
('class cv.MatExpr', '', ['/Ghost'], [])
parse_name: class cv.MatExpr with ['cv'] -> fullname:cv::MatExpr namespace:cv classpath: classname: name:MatExpr
register class cv::MatExpr (('class cv.MatExpr', '', ['/Ghost'], []))

--- Manual ---
('class cv.Mat', '', ['/Ghost'], [])
parse_name: class cv.Mat with ['cv'] -> fullname:cv::Mat namespace:cv classpath: classname: name:Mat
register class cv::Mat (('class cv.Mat', '', ['/Ghost'], []))

--- Manual ---
('class cv.UMat', '', ['/Ghost'], [])
parse_name: class cv.UMat with ['cv'] -> fullname:cv::UMat namespace:cv classpath: classname: name:UMat
register class cv::UMat (('class cv.UMat', '', ['/Ghost'], []))

--- Manual ---
('class cv.Algorithm', '', ['/Ghost'], [])
parse_name: class cv.Algorithm with ['cv'] -> fullname:cv::Algorithm namespace:cv classpath: classname: name:Algorithm
register class cv::Algorithm (('class cv.Algorithm', '', ['/Ghost'], []))

--- Manual ---
('class cv.DMatch', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.DMatch with ['cv'] -> fullname:cv::DMatch namespace:cv classpath: classname: name:DMatch
register class cv::DMatch (('class cv.DMatch', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.KeyPoint', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.KeyPoint with ['cv'] -> fullname:cv::KeyPoint namespace:cv classpath: classname: name:KeyPoint
register class cv::KeyPoint (('class cv.KeyPoint', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.RotatedRect', '', ['/Ghost'], [])
parse_name: class cv.RotatedRect with ['cv'] -> fullname:cv::RotatedRect namespace:cv classpath: classname: name:RotatedRect
register class cv::RotatedRect (('class cv.RotatedRect', '', ['/Ghost'], []))

--- Manual ---
('class cv.TermCriteria', '', ['/Ghost'], [])
parse_name: class cv.TermCriteria with ['cv'] -> fullname:cv::TermCriteria namespace:cv classpath: classname: name:TermCriteria
register class cv::TermCriteria (('class cv.TermCriteria', '', ['/Ghost'], []))

--- Manual ---
('class cv.utils.logging.LogTag', '', ['/Ghost'], [])
parse_name: class cv.utils.logging.LogTag with ['cv'] -> fullname:cv::utils::logging::LogTag namespace:cv classpath:utils::logging classname:logging name:LogTag
register class cv::utils::logging::LogTag (('class cv.utils.logging.LogTag', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileNode', '', ['/Ghost'], [])
parse_name: class cv.FileNode with ['cv'] -> fullname:cv::FileNode namespace:cv classpath: classname: name:FileNode
register class cv::FileNode (('class cv.FileNode', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileStorage', '', ['/Ghost'], [])
parse_name: class cv.FileStorage with ['cv'] -> fullname:cv::FileStorage namespace:cv classpath: classname: name:FileStorage
register class cv::FileStorage (('class cv.FileStorage', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.LayerParams', '', ['/Ghost'], [])
parse_name: class cv.dnn.LayerParams with ['cv'] -> fullname:cv::dnn::LayerParams namespace:cv classpath:dnn classname:dnn name:LayerParams
register class cv::dnn::LayerParams (('class cv.dnn.LayerParams', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.Layer', '', ['/Ghost'], [])
parse_name: class cv.dnn.Layer with ['cv'] -> fullname:cv::dnn::Layer namespace:cv classpath:dnn classname:dnn name:Layer
register class cv::dnn::Layer (('class cv.dnn.Layer', '', ['/Ghost'], []))

--- Manual ---
('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])
parse_name: class cv.Feature2D with ['cv'] -> fullname:cv::Feature2D namespace:cv classpath: classname: name:Feature2D
register class cv::Feature2D (('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])) impl:cv::Algorithm

--- Manual ---
('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])
parse_name: class cv.DescriptorMatcher with ['cv'] -> fullname:cv::DescriptorMatcher namespace:cv classpath: classname: name:DescriptorMatcher
register class cv::DescriptorMatcher (('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])) impl:cv::Algorithm

--- Manual ---
('typedef cv.FeatureDetector', 'Feature2D', [], [])
parse_name: typedef cv.FeatureDetector with ['cv'] -> fullname:cv::FeatureDetector namespace:cv classpath: classname: name:FeatureDetector
Registering an unknown type: FeatureDetector

--- Manual ---
('typedef cv.DescriptorExtractor', 'Feature2D', [], [])
parse_name: typedef cv.DescriptorExtractor with ['cv'] -> fullname:cv::DescriptorExtractor namespace:cv classpath: classname: name:DescriptorExtractor
Registering an unknown type: DescriptorExtractor

--- Manual ---
('enum cv.InterpolationFlags', '', ['/Ghost'], [])
parse_name: enum cv.InterpolationFlags with ['cv'] -> fullname:cv::InterpolationFlags namespace:cv classpath: classname: name:InterpolationFlags


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn.hpp ================


Namespaces: []
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n'}


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn/all_layers.hpp ================


Namespaces: ['cv', 'cv.dnn']
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n', 'dnnLayerList': ' @defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))\n\n'}

--- Incoming ---
[   'class cv.dnn.BlankLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '@defgroup dnnLayerList Partial List of Implemented Layers\n'
    '@{\n'
    'This subsection of dnn module contains information about built-in layers '
    'and their descriptions.\n'
    '\n'
    'Classes listed here, in fact, provides C++ API for creating instances of '
    'built-in layers.\n'
    'In addition to this way of layers instantiation, there is a more common '
    'factory API (see @ref dnnLayerFactory), it allows to create layers '
    'dynamically (by name) and register new ones.\n'
    'You can use both API, but factory API is less convenient for native C++ '
    'programming and basically designed for use inside importers (see @ref '
    'readNetFromCaffe(), @ref readNetFromTorch(), @ref '
    'readNetFromTensorflow()).\n'
    '\n'
    'Built-in layers partially reproduce functionality of corresponding Caffe '
    'and Torch7 layers.\n'
    'In particular, the following layers and Caffe importer were tested to '
    'reproduce <a '
    'href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> '
    'functionality:\n'
    '- Convolution\n'
    '- Deconvolution\n'
    '- Pooling\n'
    '- InnerProduct\n'
    '- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n'
    '- Softmax\n'
    '- Reshape, Flatten, Slice, Split\n'
    '- LRN\n'
    '- MVN\n'
    '- Dropout (since it does nothing on forward pass -))']
parse_name: class cv.dnn.BlankLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BlankLayer namespace:cv::dnn classpath: classname: name:BlankLayer
register class cv::dnn::BlankLayer (['class cv.dnn.BlankLayer', ': cv::dnn::Layer', [], [], None, '@defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.BlankLayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.BlankLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BlankLayer::create namespace:cv::dnn classpath:BlankLayer classname:BlankLayer name:create
register (method) create in cv::dnn::BlankLayer (cv_dnn_BlankLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.ConstLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '* Constant layer produces the same data blob at an every forward pass.']
parse_name: class cv.dnn.ConstLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ConstLayer namespace:cv::dnn classpath: classname: name:ConstLayer
register class cv::dnn::ConstLayer (['class cv.dnn.ConstLayer', ': cv::dnn::Layer', [], [], None, '* Constant layer produces the same data blob at an every forward pass.']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ConstLayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ConstLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ConstLayer::create namespace:cv::dnn classpath:ConstLayer classname:ConstLayer name:create
register (method) create in cv::dnn::ConstLayer (cv_dnn_ConstLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.LSTMLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    'LSTM recurrent layer']
parse_name: class cv.dnn.LSTMLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer namespace:cv::dnn classpath: classname: name:LSTMLayer
register class cv::dnn::LSTMLayer (['class cv.dnn.LSTMLayer', ': cv::dnn::Layer', [], [], None, 'LSTM recurrent layer']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.LSTMLayer.create',
    'Ptr<LSTMLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    'Creates instance of LSTM layer']
parse_name: cv.dnn.LSTMLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer::create namespace:cv::dnn classpath:LSTMLayer classname:LSTMLayer name:create
register (method) create in cv::dnn::LSTMLayer (cv_dnn_LSTMLayer_create_LayerParams)

--- Incoming ---
[   'cv.dnn.LSTMLayer.setWeights',
    'void',
    ['/A'],
    [   ['const Mat &', 'Wh', '', []],
        ['const Mat &', 'Wx', '', []],
        ['const Mat &', 'b', '', []]],
    None,
    '@deprecated Use LayerParams::blobs instead.\n'
    '@brief Set trained weights for LSTM layer.\n'
    '\n'
    'LSTM behavior on each step is defined by current input, previous output, '
    'previous cell state and learned weights.\n'
    '\n'
    'Let @f$x_t@f$ be current input, @f$h_t@f$ be current output, @f$c_t@f$ be '
    'current state.\n'
    'Than current output and current cell state is computed as follows:\n'
    '@f{eqnarray*}{\n'
    'h_t &= o_t \\odot tanh(c_t),               \\\\\n'
    'c_t &= f_t \\odot c_{t-1} + i_t \\odot g_t, \\\\\n'
    '@f}\n'
    'where @f$\\odot@f$ is per-element multiply operation and @f$i_t, f_t, '
    'o_t, g_t@f$ is internal gates that are computed using learned wights.\n'
    '\n'
    'Gates are computed as follows:\n'
    '@f{eqnarray*}{\n'
    'i_t &= sigmoid&(W_{xi} x_t + W_{hi} h_{t-1} + b_i), \\\\\n'
    'f_t &= sigmoid&(W_{xf} x_t + W_{hf} h_{t-1} + b_f), \\\\\n'
    'o_t &= sigmoid&(W_{xo} x_t + W_{ho} h_{t-1} + b_o), \\\\\n'
    'g_t &= tanh   &(W_{xg} x_t + W_{hg} h_{t-1} + b_g), \\\\\n'
    '@f}\n'
    'where @f$W_{x?}@f$, @f$W_{h?}@f$ and @f$b_{?}@f$ are learned weights '
    'represented as matrices:\n'
    '@f$W_{x?} \\in R^{N_h \\times N_x}@f$, @f$W_{h?} \\in R^{N_h \\times '
    'N_h}@f$, @f$b_? \\in R^{N_h}@f$.\n'
    '\n'
    'For simplicity and performance purposes we use @f$ W_x = [W_{xi}; W_{xf}; '
    'W_{xo}, W_{xg}] @f$\n'
    '(i.e. @f$W_x@f$ is vertical concatenation of @f$ W_{x?} @f$), @f$ W_x '
    '\\in R^{4N_h \\times N_x} @f$.\n'
    'The same for @f$ W_h = [W_{hi}; W_{hf}; W_{ho}, W_{hg}], W_h \\in R^{4N_h '
    '\\times N_h} @f$\n'
    'and for @f$ b = [b_i; b_f, b_o, b_g]@f$, @f$b \\in R^{4N_h} @f$.\n'
    '\n'
    '@param Wh is matrix defining how previous output is transformed to '
    'internal gates (i.e. according to above mentioned notation is @f$ W_h '
    '@f$)\n'
    '@param Wx is matrix defining how current input is transformed to internal '
    'gates (i.e. according to above mentioned notation is @f$ W_x @f$)\n'
    '@param b  is bias vector (i.e. according to above mentioned notation is '
    '@f$ b @f$)']
parse_name: cv.dnn.LSTMLayer.setWeights with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer::setWeights namespace:cv::dnn classpath:LSTMLayer classname:LSTMLayer name:setWeights
register (method) setWeights in cv::dnn::LSTMLayer (trait) (cv_dnn_LSTMLayer_setWeights_Mat_Mat_Mat)

--- Incoming ---
[   'cv.dnn.LSTMLayer.setOutShape',
    'void',
    ['/A'],
    [['const MatShape &', 'outTailShape', 'MatShape()', []]],
    None,
    '@brief Specifies shape of output blob which will be [[`T`], `N`] + @p '
    'outTailShape.\n'
    '* @details If this parameter is empty or unset then @p outTailShape = '
    '[`Wh`.size(0)] will be used,\n'
    '* where `Wh` is parameter from setWeights().']
parse_name: cv.dnn.LSTMLayer.setOutShape with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer::setOutShape namespace:cv::dnn classpath:LSTMLayer classname:LSTMLayer name:setOutShape
Registering an unknown type: MatShape
register (method) setOutShape in cv::dnn::LSTMLayer (trait) (cv_dnn_LSTMLayer_setOutShape_MatShape)

--- Incoming ---
[   'cv.dnn.LSTMLayer.setUseTimstampsDim',
    'void',
    ['/A'],
    [['bool', 'use', 'true', []]],
    None,
    '@deprecated Use flag `produce_cell_output` in LayerParams.\n'
    '* @brief Specifies either interpret first dimension of input blob as '
    'timestamp dimenion either as sample.\n'
    '*\n'
    '* If flag is set to true then shape of input blob will be interpreted as '
    '[`T`, `N`, `[data dims]`] where `T` specifies number of timestamps, `N` '
    'is number of independent streams.\n'
    '* In this case each forward() call will iterate through `T` timestamps '
    "and update layer's state `T` times.\n"
    '*\n'
    '* If flag is set to false then shape of input blob will be interpreted as '
    '[`N`, `[data dims]`].\n'
    '* In this case each forward() call will make one iteration and produce '
    'one timestamp with shape [`N`, `[out dims]`].']
parse_name: cv.dnn.LSTMLayer.setUseTimstampsDim with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer::setUseTimstampsDim namespace:cv::dnn classpath:LSTMLayer classname:LSTMLayer name:setUseTimstampsDim
register (method) setUseTimstampsDim in cv::dnn::LSTMLayer (trait) (cv_dnn_LSTMLayer_setUseTimstampsDim_bool)

--- Incoming ---
[   'cv.dnn.LSTMLayer.setProduceCellOutput',
    'void',
    ['/A'],
    [['bool', 'produce', 'false', []]],
    None,
    '@deprecated Use flag `use_timestamp_dim` in LayerParams.\n'
    '* @brief If this flag is set to true then layer will produce @f$ c_t @f$ '
    'as second output.\n'
    '* @details Shape of the second output is the same as first output.']
parse_name: cv.dnn.LSTMLayer.setProduceCellOutput with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer::setProduceCellOutput namespace:cv::dnn classpath:LSTMLayer classname:LSTMLayer name:setProduceCellOutput
register (method) setProduceCellOutput in cv::dnn::LSTMLayer (trait) (cv_dnn_LSTMLayer_setProduceCellOutput_bool)

--- Incoming ---
[   'cv.dnn.LSTMLayer.inputNameToIndex',
    'int',
    [],
    [['String', 'inputName', '', []]],
    None,
    '']
parse_name: cv.dnn.LSTMLayer.inputNameToIndex with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer::inputNameToIndex namespace:cv::dnn classpath:LSTMLayer classname:LSTMLayer name:inputNameToIndex
register (method) inputNameToIndex in cv::dnn::LSTMLayer (trait) (cv_dnn_LSTMLayer_inputNameToIndex_String)

--- Incoming ---
[   'cv.dnn.LSTMLayer.outputNameToIndex',
    'int',
    [],
    [['const String&', 'outputName', '', []]],
    None,
    '']
parse_name: cv.dnn.LSTMLayer.outputNameToIndex with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LSTMLayer::outputNameToIndex namespace:cv::dnn classpath:LSTMLayer classname:LSTMLayer name:outputNameToIndex
register (method) outputNameToIndex in cv::dnn::LSTMLayer (trait) (cv_dnn_LSTMLayer_outputNameToIndex_String)

--- Incoming ---
[   'class cv.dnn.RNNLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '@brief Classical recurrent layer\n'
    '\n'
    'Accepts two inputs @f$x_t@f$ and @f$h_{t-1}@f$ and compute two outputs '
    '@f$o_t@f$ and @f$h_t@f$.\n'
    '\n'
    '- input: should contain packed input @f$x_t@f$.\n'
    '- output: should contain output @f$o_t@f$ (and @f$h_t@f$ if '
    'setProduceHiddenOutput() is set to true).\n'
    '\n'
    'input[0] should have shape [`T`, `N`, `data_dims`] where `T` and `N` is '
    'number of timestamps and number of independent samples of @f$x_t@f$ '
    'respectively.\n'
    '\n'
    'output[0] will have shape [`T`, `N`, @f$N_o@f$], where @f$N_o@f$ is '
    'number of rows in @f$ W_{xo} @f$ matrix.\n'
    '\n'
    'If setProduceHiddenOutput() is set to true then @p output[1] will contain '
    'a Mat with shape [`T`, `N`, @f$N_h@f$], where @f$N_h@f$ is number of rows '
    'in @f$ W_{hh} @f$ matrix.']
parse_name: class cv.dnn.RNNLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::RNNLayer namespace:cv::dnn classpath: classname: name:RNNLayer
register class cv::dnn::RNNLayer (['class cv.dnn.RNNLayer', ': cv::dnn::Layer', [], [], None, '@brief Classical recurrent layer\n\nAccepts two inputs @f$x_t@f$ and @f$h_{t-1}@f$ and compute two outputs @f$o_t@f$ and @f$h_t@f$.\n\n- input: should contain packed input @f$x_t@f$.\n- output: should contain output @f$o_t@f$ (and @f$h_t@f$ if setProduceHiddenOutput() is set to true).\n\ninput[0] should have shape [`T`, `N`, `data_dims`] where `T` and `N` is number of timestamps and number of independent samples of @f$x_t@f$ respectively.\n\noutput[0] will have shape [`T`, `N`, @f$N_o@f$], where @f$N_o@f$ is number of rows in @f$ W_{xo} @f$ matrix.\n\nIf setProduceHiddenOutput() is set to true then @p output[1] will contain a Mat with shape [`T`, `N`, @f$N_h@f$], where @f$N_h@f$ is number of rows in @f$ W_{hh} @f$ matrix.']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.RNNLayer.create',
    'Ptr<RNNLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    'Creates instance of RNNLayer']
parse_name: cv.dnn.RNNLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::RNNLayer::create namespace:cv::dnn classpath:RNNLayer classname:RNNLayer name:create
register (method) create in cv::dnn::RNNLayer (cv_dnn_RNNLayer_create_LayerParams)

--- Incoming ---
[   'cv.dnn.RNNLayer.setWeights',
    'void',
    ['/A'],
    [   ['const Mat &', 'Wxh', '', []],
        ['const Mat &', 'bh', '', []],
        ['const Mat &', 'Whh', '', []],
        ['const Mat &', 'Who', '', []],
        ['const Mat &', 'bo', '', []]],
    None,
    'Setups learned weights.\n'
    '\n'
    'Recurrent-layer behavior on each step is defined by current input @f$ x_t '
    '@f$, previous state @f$ h_t @f$ and learned weights as follows:\n'
    '@f{eqnarray*}{\n'
    'h_t &= tanh&(W_{hh} h_{t-1} + W_{xh} x_t + b_h),  \\\\\n'
    'o_t &= tanh&(W_{ho} h_t + b_o),\n'
    '@f}\n'
    '\n'
    '@param Wxh is @f$ W_{xh} @f$ matrix\n'
    '@param bh  is @f$ b_{h}  @f$ vector\n'
    '@param Whh is @f$ W_{hh} @f$ matrix\n'
    '@param Who is @f$ W_{xo} @f$ matrix\n'
    '@param bo  is @f$ b_{o}  @f$ vector']
parse_name: cv.dnn.RNNLayer.setWeights with ['cv', 'cv::dnn'] -> fullname:cv::dnn::RNNLayer::setWeights namespace:cv::dnn classpath:RNNLayer classname:RNNLayer name:setWeights
register (method) setWeights in cv::dnn::RNNLayer (trait) (cv_dnn_RNNLayer_setWeights_Mat_Mat_Mat_Mat_Mat)

--- Incoming ---
[   'cv.dnn.RNNLayer.setProduceHiddenOutput',
    'void',
    ['/A'],
    [['bool', 'produce', 'false', []]],
    None,
    '@brief If this flag is set to true then layer will produce @f$ h_t @f$ as '
    'second output.\n'
    '* @details Shape of the second output is the same as first output.']
parse_name: cv.dnn.RNNLayer.setProduceHiddenOutput with ['cv', 'cv::dnn'] -> fullname:cv::dnn::RNNLayer::setProduceHiddenOutput namespace:cv::dnn classpath:RNNLayer classname:RNNLayer name:setProduceHiddenOutput
register (method) setProduceHiddenOutput in cv::dnn::RNNLayer (trait) (cv_dnn_RNNLayer_setProduceHiddenOutput_bool)

--- Incoming ---
['class cv.dnn.BaseConvolutionLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.BaseConvolutionLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BaseConvolutionLayer namespace:cv::dnn classpath: classname: name:BaseConvolutionLayer
register class cv::dnn::BaseConvolutionLayer (['class cv.dnn.BaseConvolutionLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'class cv.dnn.ConvolutionLayer',
    ': cv::dnn::BaseConvolutionLayer',
    [],
    [],
    None,
    '']
parse_name: class cv.dnn.ConvolutionLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ConvolutionLayer namespace:cv::dnn classpath: classname: name:ConvolutionLayer
register class cv::dnn::ConvolutionLayer (['class cv.dnn.ConvolutionLayer', ': cv::dnn::BaseConvolutionLayer', [], [], None, '']) impl:cv::dnn::BaseConvolutionLayer

--- Incoming ---
[   'cv.dnn.ConvolutionLayer.create',
    'Ptr<BaseConvolutionLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ConvolutionLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ConvolutionLayer::create namespace:cv::dnn classpath:ConvolutionLayer classname:ConvolutionLayer name:create
register (method) create in cv::dnn::ConvolutionLayer (cv_dnn_ConvolutionLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.DeconvolutionLayer',
    ': cv::dnn::BaseConvolutionLayer',
    [],
    [],
    None,
    '']
parse_name: class cv.dnn.DeconvolutionLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DeconvolutionLayer namespace:cv::dnn classpath: classname: name:DeconvolutionLayer
register class cv::dnn::DeconvolutionLayer (['class cv.dnn.DeconvolutionLayer', ': cv::dnn::BaseConvolutionLayer', [], [], None, '']) impl:cv::dnn::BaseConvolutionLayer

--- Incoming ---
[   'cv.dnn.DeconvolutionLayer.create',
    'Ptr<BaseConvolutionLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.DeconvolutionLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DeconvolutionLayer::create namespace:cv::dnn classpath:DeconvolutionLayer classname:DeconvolutionLayer name:create
register (method) create in cv::dnn::DeconvolutionLayer (cv_dnn_DeconvolutionLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.LRNLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.LRNLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LRNLayer namespace:cv::dnn classpath: classname: name:LRNLayer
register class cv::dnn::LRNLayer (['class cv.dnn.LRNLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.LRNLayer.create',
    'Ptr<LRNLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.LRNLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LRNLayer::create namespace:cv::dnn classpath:LRNLayer classname:LRNLayer name:create
register (method) create in cv::dnn::LRNLayer (cv_dnn_LRNLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.PoolingLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.PoolingLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PoolingLayer namespace:cv::dnn classpath: classname: name:PoolingLayer
register class cv::dnn::PoolingLayer (['class cv.dnn.PoolingLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.PoolingLayer.create',
    'Ptr<PoolingLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.PoolingLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PoolingLayer::create namespace:cv::dnn classpath:PoolingLayer classname:PoolingLayer name:create
register (method) create in cv::dnn::PoolingLayer (cv_dnn_PoolingLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.SoftmaxLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.SoftmaxLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SoftmaxLayer namespace:cv::dnn classpath: classname: name:SoftmaxLayer
register class cv::dnn::SoftmaxLayer (['class cv.dnn.SoftmaxLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.SoftmaxLayer.create',
    'Ptr<SoftmaxLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.SoftmaxLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SoftmaxLayer::create namespace:cv::dnn classpath:SoftmaxLayer classname:SoftmaxLayer name:create
register (method) create in cv::dnn::SoftmaxLayer (cv_dnn_SoftmaxLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.InnerProductLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.InnerProductLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::InnerProductLayer namespace:cv::dnn classpath: classname: name:InnerProductLayer
register class cv::dnn::InnerProductLayer (['class cv.dnn.InnerProductLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.InnerProductLayer.create',
    'Ptr<InnerProductLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.InnerProductLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::InnerProductLayer::create namespace:cv::dnn classpath:InnerProductLayer classname:InnerProductLayer name:create
register (method) create in cv::dnn::InnerProductLayer (cv_dnn_InnerProductLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.MVNLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.MVNLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::MVNLayer namespace:cv::dnn classpath: classname: name:MVNLayer
register class cv::dnn::MVNLayer (['class cv.dnn.MVNLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.MVNLayer.create',
    'Ptr<MVNLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.MVNLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::MVNLayer::create namespace:cv::dnn classpath:MVNLayer classname:MVNLayer name:create
register (method) create in cv::dnn::MVNLayer (cv_dnn_MVNLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ReshapeLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.ReshapeLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReshapeLayer namespace:cv::dnn classpath: classname: name:ReshapeLayer
register class cv::dnn::ReshapeLayer (['class cv.dnn.ReshapeLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ReshapeLayer.create',
    'Ptr<ReshapeLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ReshapeLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReshapeLayer::create namespace:cv::dnn classpath:ReshapeLayer classname:ReshapeLayer name:create
register (method) create in cv::dnn::ReshapeLayer (cv_dnn_ReshapeLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.FlattenLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.FlattenLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::FlattenLayer namespace:cv::dnn classpath: classname: name:FlattenLayer
register class cv::dnn::FlattenLayer (['class cv.dnn.FlattenLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.FlattenLayer.create',
    'Ptr<FlattenLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.FlattenLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::FlattenLayer::create namespace:cv::dnn classpath:FlattenLayer classname:FlattenLayer name:create
register (method) create in cv::dnn::FlattenLayer (cv_dnn_FlattenLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ConcatLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.ConcatLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ConcatLayer namespace:cv::dnn classpath: classname: name:ConcatLayer
register class cv::dnn::ConcatLayer (['class cv.dnn.ConcatLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ConcatLayer.create',
    'Ptr<ConcatLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ConcatLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ConcatLayer::create namespace:cv::dnn classpath:ConcatLayer classname:ConcatLayer name:create
register (method) create in cv::dnn::ConcatLayer (cv_dnn_ConcatLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.SplitLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.SplitLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SplitLayer namespace:cv::dnn classpath: classname: name:SplitLayer
register class cv::dnn::SplitLayer (['class cv.dnn.SplitLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.SplitLayer.create',
    'Ptr<SplitLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.SplitLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SplitLayer::create namespace:cv::dnn classpath:SplitLayer classname:SplitLayer name:create
register (method) create in cv::dnn::SplitLayer (cv_dnn_SplitLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.SliceLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '* Slice layer has several modes:\n'
    '* 1. Caffe mode\n'
    '* @param[in] axis Axis of split operation\n'
    '* @param[in] slice_point Array of split points\n'
    '*\n'
    '* Number of output blobs equals to number of split points plus one. The\n'
    '* first blob is a slice on input from 0 to @p slice_point[0] - 1 by @p '
    'axis,\n'
    '* the second output blob is a slice of input from @p slice_point[0] to\n'
    '* @p slice_point[1] - 1 by @p axis and the last output blob is a slice '
    'of\n'
    '* input from @p slice_point[-1] up to the end of @p axis size.\n'
    '*\n'
    '* 2. TensorFlow mode\n'
    '* @param begin Vector of start indices\n'
    '* @param size Vector of sizes\n'
    '*\n'
    '* More convenient numpy-like slice. One and only output blob\n'
    '* is a slice `input[begin[0]:begin[0]+size[0], begin[1]:begin[1]+size[1], '
    '...]`\n'
    '*\n'
    '* 3. Torch mode\n'
    '* @param axis Axis of split operation\n'
    '*\n'
    '* Split input blob on the equal parts by @p axis.']
parse_name: class cv.dnn.SliceLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SliceLayer namespace:cv::dnn classpath: classname: name:SliceLayer
register class cv::dnn::SliceLayer (['class cv.dnn.SliceLayer', ': cv::dnn::Layer', [], [], None, '* Slice layer has several modes:\n* 1. Caffe mode\n* @param[in] axis Axis of split operation\n* @param[in] slice_point Array of split points\n*\n* Number of output blobs equals to number of split points plus one. The\n* first blob is a slice on input from 0 to @p slice_point[0] - 1 by @p axis,\n* the second output blob is a slice of input from @p slice_point[0] to\n* @p slice_point[1] - 1 by @p axis and the last output blob is a slice of\n* input from @p slice_point[-1] up to the end of @p axis size.\n*\n* 2. TensorFlow mode\n* @param begin Vector of start indices\n* @param size Vector of sizes\n*\n* More convenient numpy-like slice. One and only output blob\n* is a slice `input[begin[0]:begin[0]+size[0], begin[1]:begin[1]+size[1], ...]`\n*\n* 3. Torch mode\n* @param axis Axis of split operation\n*\n* Split input blob on the equal parts by @p axis.']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.SliceLayer.create',
    'Ptr<SliceLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.SliceLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SliceLayer::create namespace:cv::dnn classpath:SliceLayer classname:SliceLayer name:create
register (method) create in cv::dnn::SliceLayer (cv_dnn_SliceLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.PermuteLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.PermuteLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PermuteLayer namespace:cv::dnn classpath: classname: name:PermuteLayer
register class cv::dnn::PermuteLayer (['class cv.dnn.PermuteLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.PermuteLayer.create',
    'Ptr<PermuteLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.PermuteLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PermuteLayer::create namespace:cv::dnn classpath:PermuteLayer classname:PermuteLayer name:create
register (method) create in cv::dnn::PermuteLayer (cv_dnn_PermuteLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.ShuffleChannelLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '* Permute channels of 4-dimensional input blob.\n'
    '* @param group Number of groups to split input channels and pick in '
    'turns\n'
    '*              into output blob.\n'
    '*\n'
    '* \\f[ groupSize = \\frac{number\\ of\\ channels}{group} \\f]\n'
    '* \\f[ output(n, c, h, w) = input(n, groupSize \\times (c \\% group) + '
    '\\lfloor \\frac{c}{group} \\rfloor, h, w) \\f]\n'
    '* Read more at https://arxiv.org/pdf/1707.01083.pdf']
parse_name: class cv.dnn.ShuffleChannelLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ShuffleChannelLayer namespace:cv::dnn classpath: classname: name:ShuffleChannelLayer
register class cv::dnn::ShuffleChannelLayer (['class cv.dnn.ShuffleChannelLayer', ': cv::dnn::Layer', [], [], None, '* Permute channels of 4-dimensional input blob.\n* @param group Number of groups to split input channels and pick in turns\n*              into output blob.\n*\n* \\f[ groupSize = \\frac{number\\ of\\ channels}{group} \\f]\n* \\f[ output(n, c, h, w) = input(n, groupSize \\times (c \\% group) + \\lfloor \\frac{c}{group} \\rfloor, h, w) \\f]\n* Read more at https://arxiv.org/pdf/1707.01083.pdf']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ShuffleChannelLayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ShuffleChannelLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ShuffleChannelLayer::create namespace:cv::dnn classpath:ShuffleChannelLayer classname:ShuffleChannelLayer name:create
register (method) create in cv::dnn::ShuffleChannelLayer (cv_dnn_ShuffleChannelLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.PaddingLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '* @brief Adds extra values for specific axes.\n'
    '* @param paddings Vector of paddings in format\n'
    '*                 @code\n'
    '*                 [ pad_before, pad_after,  // [0]th dimension\n'
    '*                   pad_before, pad_after,  // [1]st dimension\n'
    '*                   ...\n'
    '*                   pad_before, pad_after ] // [n]th dimension\n'
    '*                 @endcode\n'
    '*                 that represents number of padded values at every '
    'dimension\n'
    '*                 starting from the first one. The rest of dimensions '
    "won't\n"
    '*                 be padded.\n'
    '* @param value Value to be padded. Defaults to zero.\n'
    "* @param type Padding type: 'constant', 'reflect'\n"
    "* @param input_dims Torch's parameter. If @p input_dims is not equal to "
    'the\n'
    '*                   actual input dimensionality then the `[0]th` '
    'dimension\n'
    '*                   is considered as a batch dimension and @p paddings '
    'are shifted\n'
    '*                   to a one dimension. Defaults to `-1` that means '
    'padding\n'
    '*                   corresponding to @p paddings.']
parse_name: class cv.dnn.PaddingLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PaddingLayer namespace:cv::dnn classpath: classname: name:PaddingLayer
register class cv::dnn::PaddingLayer (['class cv.dnn.PaddingLayer', ': cv::dnn::Layer', [], [], None, "* @brief Adds extra values for specific axes.\n* @param paddings Vector of paddings in format\n*                 @code\n*                 [ pad_before, pad_after,  // [0]th dimension\n*                   pad_before, pad_after,  // [1]st dimension\n*                   ...\n*                   pad_before, pad_after ] // [n]th dimension\n*                 @endcode\n*                 that represents number of padded values at every dimension\n*                 starting from the first one. The rest of dimensions won't\n*                 be padded.\n* @param value Value to be padded. Defaults to zero.\n* @param type Padding type: 'constant', 'reflect'\n* @param input_dims Torch's parameter. If @p input_dims is not equal to the\n*                   actual input dimensionality then the `[0]th` dimension\n*                   is considered as a batch dimension and @p paddings are shifted\n*                   to a one dimension. Defaults to `-1` that means padding\n*                   corresponding to @p paddings."]) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.PaddingLayer.create',
    'Ptr<PaddingLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.PaddingLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PaddingLayer::create namespace:cv::dnn classpath:PaddingLayer classname:PaddingLayer name:create
register (method) create in cv::dnn::PaddingLayer (cv_dnn_PaddingLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ActivationLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.ActivationLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ActivationLayer namespace:cv::dnn classpath: classname: name:ActivationLayer
register class cv::dnn::ActivationLayer (['class cv.dnn.ActivationLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ActivationLayer.forwardSlice',
    'void',
    ['/A', '/C'],
    [   ['const float*', 'src', '', []],
        ['float*', 'dst', '', []],
        ['int', 'len', '', []],
        ['size_t', 'outPlaneSize', '', []],
        ['int', 'cn0', '', []],
        ['int', 'cn1', '', []]],
    None,
    '']
parse_name: cv.dnn.ActivationLayer.forwardSlice with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ActivationLayer::forwardSlice namespace:cv::dnn classpath:ActivationLayer classname:ActivationLayer name:forwardSlice
register (method) forwardSlice in cv::dnn::ActivationLayer (trait) (cv_dnn_ActivationLayer_forwardSlice_const_const_float_X_float_X_int_size_t_int_int)

--- Incoming ---
['class cv.dnn.ReLULayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.ReLULayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReLULayer namespace:cv::dnn classpath: classname: name:ReLULayer
register class cv::dnn::ReLULayer (['class cv.dnn.ReLULayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.ReLULayer.create',
    'Ptr<ReLULayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ReLULayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReLULayer::create namespace:cv::dnn classpath:ReLULayer classname:ReLULayer name:create
register (method) create in cv::dnn::ReLULayer (cv_dnn_ReLULayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ReLU6Layer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.ReLU6Layer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReLU6Layer namespace:cv::dnn classpath: classname: name:ReLU6Layer
register class cv::dnn::ReLU6Layer (['class cv.dnn.ReLU6Layer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.ReLU6Layer.create',
    'Ptr<ReLU6Layer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ReLU6Layer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReLU6Layer::create namespace:cv::dnn classpath:ReLU6Layer classname:ReLU6Layer name:create
register (method) create in cv::dnn::ReLU6Layer (cv_dnn_ReLU6Layer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.ChannelsPReLULayer',
    ': cv::dnn::ActivationLayer',
    [],
    [],
    None,
    '']
parse_name: class cv.dnn.ChannelsPReLULayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ChannelsPReLULayer namespace:cv::dnn classpath: classname: name:ChannelsPReLULayer
register class cv::dnn::ChannelsPReLULayer (['class cv.dnn.ChannelsPReLULayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.ChannelsPReLULayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ChannelsPReLULayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ChannelsPReLULayer::create namespace:cv::dnn classpath:ChannelsPReLULayer classname:ChannelsPReLULayer name:create
register (method) create in cv::dnn::ChannelsPReLULayer (cv_dnn_ChannelsPReLULayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ELULayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.ELULayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ELULayer namespace:cv::dnn classpath: classname: name:ELULayer
register class cv::dnn::ELULayer (['class cv.dnn.ELULayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.ELULayer.create',
    'Ptr<ELULayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ELULayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ELULayer::create namespace:cv::dnn classpath:ELULayer classname:ELULayer name:create
register (method) create in cv::dnn::ELULayer (cv_dnn_ELULayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.TanHLayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.TanHLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::TanHLayer namespace:cv::dnn classpath: classname: name:TanHLayer
register class cv::dnn::TanHLayer (['class cv.dnn.TanHLayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.TanHLayer.create',
    'Ptr<TanHLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.TanHLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::TanHLayer::create namespace:cv::dnn classpath:TanHLayer classname:TanHLayer name:create
register (method) create in cv::dnn::TanHLayer (cv_dnn_TanHLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.SigmoidLayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.SigmoidLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SigmoidLayer namespace:cv::dnn classpath: classname: name:SigmoidLayer
register class cv::dnn::SigmoidLayer (['class cv.dnn.SigmoidLayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.SigmoidLayer.create',
    'Ptr<SigmoidLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.SigmoidLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::SigmoidLayer::create namespace:cv::dnn classpath:SigmoidLayer classname:SigmoidLayer name:create
register (method) create in cv::dnn::SigmoidLayer (cv_dnn_SigmoidLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.BNLLLayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.BNLLLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BNLLLayer namespace:cv::dnn classpath: classname: name:BNLLLayer
register class cv::dnn::BNLLLayer (['class cv.dnn.BNLLLayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.BNLLLayer.create',
    'Ptr<BNLLLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.BNLLLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BNLLLayer::create namespace:cv::dnn classpath:BNLLLayer classname:BNLLLayer name:create
register (method) create in cv::dnn::BNLLLayer (cv_dnn_BNLLLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.AbsLayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.AbsLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::AbsLayer namespace:cv::dnn classpath: classname: name:AbsLayer
register class cv::dnn::AbsLayer (['class cv.dnn.AbsLayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.AbsLayer.create',
    'Ptr<AbsLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.AbsLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::AbsLayer::create namespace:cv::dnn classpath:AbsLayer classname:AbsLayer name:create
register (method) create in cv::dnn::AbsLayer (cv_dnn_AbsLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.PowerLayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.PowerLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PowerLayer namespace:cv::dnn classpath: classname: name:PowerLayer
register class cv::dnn::PowerLayer (['class cv.dnn.PowerLayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.PowerLayer.create',
    'Ptr<PowerLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.PowerLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PowerLayer::create namespace:cv::dnn classpath:PowerLayer classname:PowerLayer name:create
register (method) create in cv::dnn::PowerLayer (cv_dnn_PowerLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.CropLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.CropLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::CropLayer namespace:cv::dnn classpath: classname: name:CropLayer
register class cv::dnn::CropLayer (['class cv.dnn.CropLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.CropLayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.CropLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::CropLayer::create namespace:cv::dnn classpath:CropLayer classname:CropLayer name:create
register (method) create in cv::dnn::CropLayer (cv_dnn_CropLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.EltwiseLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.EltwiseLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::EltwiseLayer namespace:cv::dnn classpath: classname: name:EltwiseLayer
register class cv::dnn::EltwiseLayer (['class cv.dnn.EltwiseLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.EltwiseLayer.create',
    'Ptr<EltwiseLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.EltwiseLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::EltwiseLayer::create namespace:cv::dnn classpath:EltwiseLayer classname:EltwiseLayer name:create
register (method) create in cv::dnn::EltwiseLayer (cv_dnn_EltwiseLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.BatchNormLayer', ': cv::dnn::ActivationLayer', [], [], None, '']
parse_name: class cv.dnn.BatchNormLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BatchNormLayer namespace:cv::dnn classpath: classname: name:BatchNormLayer
register class cv::dnn::BatchNormLayer (['class cv.dnn.BatchNormLayer', ': cv::dnn::ActivationLayer', [], [], None, '']) impl:cv::dnn::ActivationLayer

--- Incoming ---
[   'cv.dnn.BatchNormLayer.create',
    'Ptr<BatchNormLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.BatchNormLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BatchNormLayer::create namespace:cv::dnn classpath:BatchNormLayer classname:BatchNormLayer name:create
register (method) create in cv::dnn::BatchNormLayer (cv_dnn_BatchNormLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.MaxUnpoolLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.MaxUnpoolLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::MaxUnpoolLayer namespace:cv::dnn classpath: classname: name:MaxUnpoolLayer
register class cv::dnn::MaxUnpoolLayer (['class cv.dnn.MaxUnpoolLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.MaxUnpoolLayer.create',
    'Ptr<MaxUnpoolLayer>',
    ['/S'],
    [['const LayerParams &', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.MaxUnpoolLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::MaxUnpoolLayer::create namespace:cv::dnn classpath:MaxUnpoolLayer classname:MaxUnpoolLayer name:create
register (method) create in cv::dnn::MaxUnpoolLayer (cv_dnn_MaxUnpoolLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ScaleLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.ScaleLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ScaleLayer namespace:cv::dnn classpath: classname: name:ScaleLayer
register class cv::dnn::ScaleLayer (['class cv.dnn.ScaleLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ScaleLayer.create',
    'Ptr<ScaleLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ScaleLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ScaleLayer::create namespace:cv::dnn classpath:ScaleLayer classname:ScaleLayer name:create
register (method) create in cv::dnn::ScaleLayer (cv_dnn_ScaleLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ShiftLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.ShiftLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ShiftLayer namespace:cv::dnn classpath: classname: name:ShiftLayer
register class cv::dnn::ShiftLayer (['class cv.dnn.ShiftLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ShiftLayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ShiftLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ShiftLayer::create namespace:cv::dnn classpath:ShiftLayer classname:ShiftLayer name:create
register (method) create in cv::dnn::ShiftLayer (cv_dnn_ShiftLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.PriorBoxLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.PriorBoxLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PriorBoxLayer namespace:cv::dnn classpath: classname: name:PriorBoxLayer
register class cv::dnn::PriorBoxLayer (['class cv.dnn.PriorBoxLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.PriorBoxLayer.create',
    'Ptr<PriorBoxLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.PriorBoxLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::PriorBoxLayer::create namespace:cv::dnn classpath:PriorBoxLayer classname:PriorBoxLayer name:create
register (method) create in cv::dnn::PriorBoxLayer (cv_dnn_PriorBoxLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ReorgLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.ReorgLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReorgLayer namespace:cv::dnn classpath: classname: name:ReorgLayer
register class cv::dnn::ReorgLayer (['class cv.dnn.ReorgLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ReorgLayer.create',
    'Ptr<ReorgLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ReorgLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ReorgLayer::create namespace:cv::dnn classpath:ReorgLayer classname:ReorgLayer name:create
register (method) create in cv::dnn::ReorgLayer (cv_dnn_ReorgLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.RegionLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.RegionLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::RegionLayer namespace:cv::dnn classpath: classname: name:RegionLayer
register class cv::dnn::RegionLayer (['class cv.dnn.RegionLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.RegionLayer.create',
    'Ptr<RegionLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.RegionLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::RegionLayer::create namespace:cv::dnn classpath:RegionLayer classname:RegionLayer name:create
register (method) create in cv::dnn::RegionLayer (cv_dnn_RegionLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.DetectionOutputLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.DetectionOutputLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DetectionOutputLayer namespace:cv::dnn classpath: classname: name:DetectionOutputLayer
register class cv::dnn::DetectionOutputLayer (['class cv.dnn.DetectionOutputLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.DetectionOutputLayer.create',
    'Ptr<DetectionOutputLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.DetectionOutputLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DetectionOutputLayer::create namespace:cv::dnn classpath:DetectionOutputLayer classname:DetectionOutputLayer name:create
register (method) create in cv::dnn::DetectionOutputLayer (cv_dnn_DetectionOutputLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.NormalizeBBoxLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '* @brief \\f$ L_p \\f$ - normalization layer.\n'
    '* @param p Normalization factor. The most common `p = 1` for \\f$ L_1 '
    '\\f$ -\n'
    '*          normalization or `p = 2` for \\f$ L_2 \\f$ - normalization or '
    'a custom one.\n'
    '* @param eps Parameter \\f$ \\epsilon \\f$ to prevent a division by '
    'zero.\n'
    '* @param across_spatial If true, normalize an input across all non-batch '
    'dimensions.\n'
    '*                       Otherwise normalize an every channel separately.\n'
    '*\n'
    '* Across spatial:\n'
    '* @f[\n'
    '* norm = \\sqrt[p]{\\epsilon + \\sum_{x, y, c} |src(x, y, c)|^p } \\\\\n'
    '* dst(x, y, c) = \\frac{ src(x, y, c) }{norm}\n'
    '* @f]\n'
    '*\n'
    '* Channel wise normalization:\n'
    '* @f[\n'
    '* norm(c) = \\sqrt[p]{\\epsilon + \\sum_{x, y} |src(x, y, c)|^p } \\\\\n'
    '* dst(x, y, c) = \\frac{ src(x, y, c) }{norm(c)}\n'
    '* @f]\n'
    '*\n'
    '* Where `x, y` - spatial coordinates, `c` - channel.\n'
    '*\n'
    '* An every sample in the batch is normalized separately. Optionally,\n'
    '* output is scaled by the trained parameters.']
parse_name: class cv.dnn.NormalizeBBoxLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::NormalizeBBoxLayer namespace:cv::dnn classpath: classname: name:NormalizeBBoxLayer
register class cv::dnn::NormalizeBBoxLayer (['class cv.dnn.NormalizeBBoxLayer', ': cv::dnn::Layer', [], [], None, '* @brief \\f$ L_p \\f$ - normalization layer.\n* @param p Normalization factor. The most common `p = 1` for \\f$ L_1 \\f$ -\n*          normalization or `p = 2` for \\f$ L_2 \\f$ - normalization or a custom one.\n* @param eps Parameter \\f$ \\epsilon \\f$ to prevent a division by zero.\n* @param across_spatial If true, normalize an input across all non-batch dimensions.\n*                       Otherwise normalize an every channel separately.\n*\n* Across spatial:\n* @f[\n* norm = \\sqrt[p]{\\epsilon + \\sum_{x, y, c} |src(x, y, c)|^p } \\\\\n* dst(x, y, c) = \\frac{ src(x, y, c) }{norm}\n* @f]\n*\n* Channel wise normalization:\n* @f[\n* norm(c) = \\sqrt[p]{\\epsilon + \\sum_{x, y} |src(x, y, c)|^p } \\\\\n* dst(x, y, c) = \\frac{ src(x, y, c) }{norm(c)}\n* @f]\n*\n* Where `x, y` - spatial coordinates, `c` - channel.\n*\n* An every sample in the batch is normalized separately. Optionally,\n* output is scaled by the trained parameters.']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.NormalizeBBoxLayer.create',
    'Ptr<NormalizeBBoxLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.NormalizeBBoxLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::NormalizeBBoxLayer::create namespace:cv::dnn classpath:NormalizeBBoxLayer classname:NormalizeBBoxLayer name:create
register (method) create in cv::dnn::NormalizeBBoxLayer (cv_dnn_NormalizeBBoxLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.ResizeLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '* @brief Resize input 4-dimensional blob by nearest neighbor or bilinear '
    'strategy.\n'
    '*\n'
    "* Layer is used to support TensorFlow's resize_nearest_neighbor and "
    'resize_bilinear ops.']
parse_name: class cv.dnn.ResizeLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ResizeLayer namespace:cv::dnn classpath: classname: name:ResizeLayer
register class cv::dnn::ResizeLayer (['class cv.dnn.ResizeLayer', ': cv::dnn::Layer', [], [], None, "* @brief Resize input 4-dimensional blob by nearest neighbor or bilinear strategy.\n*\n* Layer is used to support TensorFlow's resize_nearest_neighbor and resize_bilinear ops."]) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ResizeLayer.create',
    'Ptr<ResizeLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ResizeLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ResizeLayer::create namespace:cv::dnn classpath:ResizeLayer classname:ResizeLayer name:create
register (method) create in cv::dnn::ResizeLayer (cv_dnn_ResizeLayer_create_LayerParams)

--- Incoming ---
[   'class cv.dnn.InterpLayer',
    ': cv::dnn::Layer',
    [],
    [],
    None,
    '* @brief Bilinear resize layer from '
    'https://github.com/cdmh/deeplab-public-ver2\n'
    '*\n'
    '* It differs from @ref ResizeLayer in output shape and resize scales '
    'computations.']
parse_name: class cv.dnn.InterpLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::InterpLayer namespace:cv::dnn classpath: classname: name:InterpLayer
register class cv::dnn::InterpLayer (['class cv.dnn.InterpLayer', ': cv::dnn::Layer', [], [], None, '* @brief Bilinear resize layer from https://github.com/cdmh/deeplab-public-ver2\n*\n* It differs from @ref ResizeLayer in output shape and resize scales computations.']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.InterpLayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.InterpLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::InterpLayer::create namespace:cv::dnn classpath:InterpLayer classname:InterpLayer name:create
register (method) create in cv::dnn::InterpLayer (cv_dnn_InterpLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.ProposalLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.ProposalLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ProposalLayer namespace:cv::dnn classpath: classname: name:ProposalLayer
register class cv::dnn::ProposalLayer (['class cv.dnn.ProposalLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.ProposalLayer.create',
    'Ptr<ProposalLayer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.ProposalLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::ProposalLayer::create namespace:cv::dnn classpath:ProposalLayer classname:ProposalLayer name:create
register (method) create in cv::dnn::ProposalLayer (cv_dnn_ProposalLayer_create_LayerParams)

--- Incoming ---
['class cv.dnn.CropAndResizeLayer', ': cv::dnn::Layer', [], [], None, '']
parse_name: class cv.dnn.CropAndResizeLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::CropAndResizeLayer namespace:cv::dnn classpath: classname: name:CropAndResizeLayer
register class cv::dnn::CropAndResizeLayer (['class cv.dnn.CropAndResizeLayer', ': cv::dnn::Layer', [], [], None, '']) impl:cv::dnn::Layer

--- Incoming ---
[   'cv.dnn.CropAndResizeLayer.create',
    'Ptr<Layer>',
    ['/S'],
    [['const LayerParams&', 'params', '', []]],
    None,
    '']
parse_name: cv.dnn.CropAndResizeLayer.create with ['cv', 'cv::dnn'] -> fullname:cv::dnn::CropAndResizeLayer::create namespace:cv::dnn classpath:CropAndResizeLayer classname:CropAndResizeLayer name:create
register (method) create in cv::dnn::CropAndResizeLayer (cv_dnn_CropAndResizeLayer_create_LayerParams)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn/dict.hpp ================


Namespaces: ['cv', 'cv.dnn']
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n', 'dnnLayerList': ' @defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))\n\n'}

--- Incoming ---
[   'struct cv.dnn.DictValue',
    '',
    [],
    [],
    None,
    '@brief This struct stores the scalar value (or array) of one of the '
    'following type: double, cv::String or int64.\n'
    '*  @todo Maybe int64 is useless because double type exactly stores at '
    'least 2^52 integers.']
parse_name: struct cv.dnn.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue namespace:cv::dnn classpath: classname: name:DictValue
register class cv::dnn::DictValue (['struct cv.dnn.DictValue', '', [], [], None, '@brief This struct stores the scalar value (or array) of one of the following type: double, cv::String or int64.\n*  @todo Maybe int64 is useless because double type exactly stores at least 2^52 integers.'])

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['const DictValue &', 'r', '', []]],
    None,
    '']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) copy in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_DictValue)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['bool', 'i', '', []]],
    None,
    'Constructs integer scalar\n']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) new in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_bool)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['int64', 'i', '0', []]],
    None,
    'Constructs integer scalar\n']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) new in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_int64)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['int', 'i', '', []]],
    None,
    'Constructs integer scalar\n']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) new in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_int)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['unsigned', 'p', '', []]],
    None,
    'Constructs integer scalar\n']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) new in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_unsigned)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['double', 'p', '', []]],
    None,
    'Constructs floating point scalar\n']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) new in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_double)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['const String &', 's', '', []]],
    None,
    'Constructs string scalar\n']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) new in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_String)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    'D',
    [],
    [['const char *', 's', '', []]],
    None,
    '@overload\n']
parse_name: cv.dnn.DictValue.DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue
register (constructor) new in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_const_char_X)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue arrayInt',
    'template<typename TypeIter> static DictValue',
    [],
    [['TypeIter', 'begin', '', []], ['int', 'size', '', []]],
    None,
    'Constructs integer array\n']
parse_name: cv.dnn.DictValue.DictValue arrayInt with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue arrayInt namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue arrayInt
Registering an unknown type: template<typename TypeIter> static DictValue
Registering an unknown type: TypeIter
register (method) DictValue arrayInt in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_arrayInt_TypeIter_int)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue arrayReal',
    'template<typename TypeIter> static DictValue',
    [],
    [['TypeIter', 'begin', '', []], ['int', 'size', '', []]],
    None,
    'Constructs floating point array\n']
parse_name: cv.dnn.DictValue.DictValue arrayReal with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue arrayReal namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue arrayReal
register (method) DictValue arrayReal in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_arrayReal_TypeIter_int)

--- Incoming ---
[   'cv.dnn.DictValue.DictValue arrayString',
    'template<typename TypeIter> static DictValue',
    [],
    [['TypeIter', 'begin', '', []], ['int', 'size', '', []]],
    None,
    'Constructs array of strings\n']
parse_name: cv.dnn.DictValue.DictValue arrayString with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::DictValue arrayString namespace:cv::dnn classpath:DictValue classname:DictValue name:DictValue arrayString
register (method) DictValue arrayString in cv::dnn::DictValue (cv_dnn_DictValue_DictValue_arrayString_TypeIter_int)

--- Incoming ---
[   'cv.dnn.DictValue.get',
    'template<typename T> T',
    ['/C'],
    [['int', 'idx', '-1', []]],
    None,
    'Tries to convert array element with specified index to requested type and '
    'returns its.\n']
parse_name: cv.dnn.DictValue.get with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::get namespace:cv::dnn classpath:DictValue classname:DictValue name:get
Registering an unknown type: template<typename T> T
register (method) get in cv::dnn::DictValue (cv_dnn_DictValue_get_const_int)

--- Incoming ---
['cv.dnn.DictValue.size', 'int', ['/C'], [], None, '']
parse_name: cv.dnn.DictValue.size with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::size namespace:cv::dnn classpath:DictValue classname:DictValue name:size
register (method) size in cv::dnn::DictValue (cv_dnn_DictValue_size_const)

--- Incoming ---
['cv.dnn.DictValue.isInt', 'bool', ['/C'], [], None, '']
parse_name: cv.dnn.DictValue.isInt with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::isInt namespace:cv::dnn classpath:DictValue classname:DictValue name:isInt
register (method) isInt in cv::dnn::DictValue (cv_dnn_DictValue_isInt_const)

--- Incoming ---
['cv.dnn.DictValue.isString', 'bool', ['/C'], [], None, '']
parse_name: cv.dnn.DictValue.isString with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::isString namespace:cv::dnn classpath:DictValue classname:DictValue name:isString
register (method) isString in cv::dnn::DictValue (cv_dnn_DictValue_isString_const)

--- Incoming ---
['cv.dnn.DictValue.isReal', 'bool', ['/C'], [], None, '']
parse_name: cv.dnn.DictValue.isReal with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::isReal namespace:cv::dnn classpath:DictValue classname:DictValue name:isReal
register (method) isReal in cv::dnn::DictValue (cv_dnn_DictValue_isReal_const)

--- Incoming ---
[   'cv.dnn.DictValue.getIntValue',
    'int',
    ['/C'],
    [['int', 'idx', '-1', []]],
    None,
    '']
parse_name: cv.dnn.DictValue.getIntValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::getIntValue namespace:cv::dnn classpath:DictValue classname:DictValue name:getIntValue
register (method) getIntValue in cv::dnn::DictValue (cv_dnn_DictValue_getIntValue_const_int)

--- Incoming ---
[   'cv.dnn.DictValue.getRealValue',
    'double',
    ['/C'],
    [['int', 'idx', '-1', []]],
    None,
    '']
parse_name: cv.dnn.DictValue.getRealValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::getRealValue namespace:cv::dnn classpath:DictValue classname:DictValue name:getRealValue
register (method) getRealValue in cv::dnn::DictValue (cv_dnn_DictValue_getRealValue_const_int)

--- Incoming ---
[   'cv.dnn.DictValue.getStringValue',
    'String',
    ['/C'],
    [['int', 'idx', '-1', []]],
    None,
    '']
parse_name: cv.dnn.DictValue.getStringValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::getStringValue namespace:cv::dnn classpath:DictValue classname:DictValue name:getStringValue
register (method) getStringValue in cv::dnn::DictValue (cv_dnn_DictValue_getStringValue_const_int)

--- Incoming ---
[   'cv.dnn.DictValue.operator=',
    'DictValue &',
    [],
    [['const DictValue &', 'r', '', []]],
    None,
    '']
parse_name: cv.dnn.DictValue.operator= with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::operator= namespace:cv::dnn classpath:DictValue classname:DictValue name:operator=
ignore (method) operator= in cv::dnn::DictValue

--- Incoming ---
[   'cv.dnn.std.ostream operator <<',
    'friend std::ostream &',
    [],
    [   ['std::ostream &', 'stream', '', []],
        ['const DictValue &', 'dictv', '', []]],
    None,
    '']
parse_name: cv.dnn.std.ostream operator << with ['cv', 'cv::dnn'] -> fullname:cv::dnn::std::ostream operator << namespace:cv::dnn classpath:std classname:std name:ostream operator <<
Registering an unknown type: friend std::ostream
Registering an unknown type: std::ostream

--- Incoming ---
['cv.dnn.DictValue.~DictValue', '~', [], [], None, '']
parse_name: cv.dnn.DictValue.~DictValue with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DictValue::~DictValue namespace:cv::dnn classpath:DictValue classname:DictValue name:~DictValue
Registering an unknown type: ~
ignore destructor (method) ~DictValue in cv::dnn::DictValue

--- Incoming ---
[   'class cv.dnn.Dict',
    '',
    [],
    [],
    None,
    '@brief This class implements name-value dictionary, values are instances '
    'of DictValue.']
parse_name: class cv.dnn.Dict with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict namespace:cv::dnn classpath: classname: name:Dict
register class cv::dnn::Dict (['class cv.dnn.Dict', '', [], [], None, '@brief This class implements name-value dictionary, values are instances of DictValue.'])

--- Incoming ---
[   'cv.dnn.Dict.has',
    'bool',
    ['/C'],
    [['const String &', 'key', '', []]],
    None,
    'Checks a presence of the @p key in the dictionary.']
parse_name: cv.dnn.Dict.has with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::has namespace:cv::dnn classpath:Dict classname:Dict name:has
register (method) has in cv::dnn::Dict (cv_dnn_Dict_has_const_String)

--- Incoming ---
[   'cv.dnn.Dict.ptr',
    'DictValue *',
    [],
    [['const String &', 'key', '', []]],
    None,
    'If the @p key in the dictionary then returns pointer to its value, else '
    'returns NULL.']
parse_name: cv.dnn.Dict.ptr with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::ptr namespace:cv::dnn classpath:Dict classname:Dict name:ptr
register (method) ptr in cv::dnn::Dict (cv_dnn_Dict_ptr_String)

--- Incoming ---
[   'cv.dnn.Dict.ptr',
    'const DictValue *',
    ['/C'],
    [['const String &', 'key', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Dict.ptr with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::ptr namespace:cv::dnn classpath:Dict classname:Dict name:ptr
register (method) ptr in cv::dnn::Dict (cv_dnn_Dict_ptr_const_String)

--- Incoming ---
[   'cv.dnn.Dict.get',
    'const DictValue &',
    ['/C'],
    [['const String &', 'key', '', []]],
    None,
    'If the @p key in the dictionary then returns its value, else an error '
    'will be generated.']
parse_name: cv.dnn.Dict.get with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::get namespace:cv::dnn classpath:Dict classname:Dict name:get
register (method) get in cv::dnn::Dict (cv_dnn_Dict_get_const_String)

--- Incoming ---
[   'cv.dnn.Dict.get',
    'template <typename T> T',
    ['/C'],
    [['const String &', 'key', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Dict.get with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::get namespace:cv::dnn classpath:Dict classname:Dict name:get
Registering an unknown type: template <typename T> T
register (method) get in cv::dnn::Dict (cv_dnn_Dict_get_const_String)

--- Incoming ---
[   'cv.dnn.Dict.get',
    'template <typename T> T',
    ['/C'],
    [['const String &', 'key', '', []], ['const T &', 'defaultValue', '', []]],
    None,
    'If the @p key in the dictionary then returns its value, else returns @p '
    'defaultValue.']
parse_name: cv.dnn.Dict.get with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::get namespace:cv::dnn classpath:Dict classname:Dict name:get
Registering an unknown type: T
register (method) get in cv::dnn::Dict (cv_dnn_Dict_get_const_String_T)

--- Incoming ---
[   'cv.dnn.Dict.set',
    'template<typename T> const T &',
    [],
    [['const String &', 'key', '', []], ['const T &', 'value', '', []]],
    None,
    'Sets new @p value for the @p key, or adds new key-value pair into the '
    'dictionary.']
parse_name: cv.dnn.Dict.set with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::set namespace:cv::dnn classpath:Dict classname:Dict name:set
register (method) set in cv::dnn::Dict (cv_dnn_Dict_set_String_DictValue)

--- Incoming ---
[   'cv.dnn.Dict.erase',
    'void',
    [],
    [['const String &', 'key', '', []]],
    None,
    'Erase @p key from the dictionary.']
parse_name: cv.dnn.Dict.erase with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Dict::erase namespace:cv::dnn classpath:Dict classname:Dict name:erase
register (method) erase in cv::dnn::Dict (cv_dnn_Dict_erase_String)

--- Incoming ---
[   'cv.dnn.std.ostream operator <<',
    'friend std::ostream &',
    [],
    [['std::ostream &', 'stream', '', []], ['const Dict &', 'dict', '', []]],
    None,
    '']
parse_name: cv.dnn.std.ostream operator << with ['cv', 'cv::dnn'] -> fullname:cv::dnn::std::ostream operator << namespace:cv::dnn classpath:std classname:std name:ostream operator <<

--- Incoming ---
[   'cv.dnn..const_iterator begin',
    'std::map<String, DictValue>::const_iterator',
    ['/C'],
    [],
    None,
    '']
parse_name: cv.dnn..const_iterator begin with ['cv', 'cv::dnn'] -> fullname:cv::dnn::::const_iterator begin namespace:cv::dnn classpath: classname: name:const_iterator begin
Registering an unknown type: std::map<String, DictValue>::const_iterator
register (function) const_iterator begin (cv_dnn__const_iterator_begin_const)

--- Incoming ---
[   'cv.dnn..const_iterator end',
    'std::map<String, DictValue>::const_iterator',
    ['/C'],
    [],
    None,
    '']
parse_name: cv.dnn..const_iterator end with ['cv', 'cv::dnn'] -> fullname:cv::dnn::::const_iterator end namespace:cv::dnn classpath: classname: name:const_iterator end
register (function) const_iterator end (cv_dnn__const_iterator_end_const)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn/dnn.hpp ================


Namespaces: ['cv', 'cv.dnn']
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n', 'dnnLayerList': ' @defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))\n\n'}

--- Incoming ---
[   'typedef cv.dnn.MatShape',
    'std::vector<int>',
    '',
    [],
    None,
    '@addtogroup dnn\n@{']
parse_name: typedef cv.dnn.MatShape with ['cv', 'cv::dnn'] -> fullname:cv::dnn::MatShape namespace:cv::dnn classpath: classname: name:MatShape
Registering an unknown type: MatShape

--- Incoming ---
[   'enum cv.dnn.Backend',
    '',
    [],
    [   ['const cv.dnn.DNN_BACKEND_DEFAULT', '0', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_HALIDE', '1', [], [], None, ''],
        [   'const cv.dnn.DNN_BACKEND_INFERENCE_ENGINE',
            '2',
            [],
            [],
            None,
            "Intel's Inference Engine computational backend.\n"],
        ['const cv.dnn.DNN_BACKEND_OPENCV', '3', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_VKCOM', '4', [], [], None, '']],
    None,
    '* @brief Enum of computation backends supported by layers.\n'
    '* @see Net::setPreferableBackend']
parse_name: const cv.dnn.DNN_BACKEND_DEFAULT with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_DEFAULT namespace:cv::dnn classpath: classname: name:DNN_BACKEND_DEFAULT
parse_name: const cv.dnn.DNN_BACKEND_HALIDE with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_HALIDE namespace:cv::dnn classpath: classname: name:DNN_BACKEND_HALIDE
parse_name: const cv.dnn.DNN_BACKEND_INFERENCE_ENGINE with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_INFERENCE_ENGINE namespace:cv::dnn classpath: classname: name:DNN_BACKEND_INFERENCE_ENGINE
parse_name: const cv.dnn.DNN_BACKEND_OPENCV with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_OPENCV namespace:cv::dnn classpath: classname: name:DNN_BACKEND_OPENCV
parse_name: const cv.dnn.DNN_BACKEND_VKCOM with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_VKCOM namespace:cv::dnn classpath: classname: name:DNN_BACKEND_VKCOM
parse_name: enum cv.dnn.Backend with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Backend namespace:cv::dnn classpath: classname: name:Backend
parse_name: const cv.dnn.DNN_BACKEND_DEFAULT with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_DEFAULT namespace:cv::dnn classpath: classname: name:DNN_BACKEND_DEFAULT
parse_name: const cv.dnn.DNN_BACKEND_HALIDE with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_HALIDE namespace:cv::dnn classpath: classname: name:DNN_BACKEND_HALIDE
parse_name: const cv.dnn.DNN_BACKEND_INFERENCE_ENGINE with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_INFERENCE_ENGINE namespace:cv::dnn classpath: classname: name:DNN_BACKEND_INFERENCE_ENGINE
parse_name: const cv.dnn.DNN_BACKEND_OPENCV with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_OPENCV namespace:cv::dnn classpath: classname: name:DNN_BACKEND_OPENCV
parse_name: const cv.dnn.DNN_BACKEND_VKCOM with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_BACKEND_VKCOM namespace:cv::dnn classpath: classname: name:DNN_BACKEND_VKCOM

--- Incoming ---
[   'enum cv.dnn.Target',
    '',
    [],
    [   ['const cv.dnn.DNN_TARGET_CPU', '0', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_OPENCL', '1', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_OPENCL_FP16', '2', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_MYRIAD', '3', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_VULKAN', '4', [], [], None, ''],
        [   'const cv.dnn.DNN_TARGET_FPGA',
            '5',
            [],
            [],
            None,
            "FPGA device with CPU fallbacks using Inference Engine's "
            'Heterogeneous plugin.\n']],
    None,
    '* @brief Enum of target devices for computations.\n'
    '* @see Net::setPreferableTarget']
parse_name: const cv.dnn.DNN_TARGET_CPU with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_CPU namespace:cv::dnn classpath: classname: name:DNN_TARGET_CPU
parse_name: const cv.dnn.DNN_TARGET_OPENCL with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_OPENCL namespace:cv::dnn classpath: classname: name:DNN_TARGET_OPENCL
parse_name: const cv.dnn.DNN_TARGET_OPENCL_FP16 with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_OPENCL_FP16 namespace:cv::dnn classpath: classname: name:DNN_TARGET_OPENCL_FP16
parse_name: const cv.dnn.DNN_TARGET_MYRIAD with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_MYRIAD namespace:cv::dnn classpath: classname: name:DNN_TARGET_MYRIAD
parse_name: const cv.dnn.DNN_TARGET_VULKAN with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_VULKAN namespace:cv::dnn classpath: classname: name:DNN_TARGET_VULKAN
parse_name: const cv.dnn.DNN_TARGET_FPGA with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_FPGA namespace:cv::dnn classpath: classname: name:DNN_TARGET_FPGA
parse_name: enum cv.dnn.Target with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Target namespace:cv::dnn classpath: classname: name:Target
parse_name: const cv.dnn.DNN_TARGET_CPU with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_CPU namespace:cv::dnn classpath: classname: name:DNN_TARGET_CPU
parse_name: const cv.dnn.DNN_TARGET_OPENCL with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_OPENCL namespace:cv::dnn classpath: classname: name:DNN_TARGET_OPENCL
parse_name: const cv.dnn.DNN_TARGET_OPENCL_FP16 with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_OPENCL_FP16 namespace:cv::dnn classpath: classname: name:DNN_TARGET_OPENCL_FP16
parse_name: const cv.dnn.DNN_TARGET_MYRIAD with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_MYRIAD namespace:cv::dnn classpath: classname: name:DNN_TARGET_MYRIAD
parse_name: const cv.dnn.DNN_TARGET_VULKAN with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_VULKAN namespace:cv::dnn classpath: classname: name:DNN_TARGET_VULKAN
parse_name: const cv.dnn.DNN_TARGET_FPGA with ['cv', 'cv::dnn'] -> fullname:cv::dnn::DNN_TARGET_FPGA namespace:cv::dnn classpath: classname: name:DNN_TARGET_FPGA

--- Incoming ---
[   'cv.dnn.getAvailableBackends',
    'std::vector< std::pair<Backend, Target> >',
    [],
    [],
    None,
    '']
parse_name: cv.dnn.getAvailableBackends with ['cv', 'cv::dnn'] -> fullname:cv::dnn::getAvailableBackends namespace:cv::dnn classpath: classname: name:getAvailableBackends
Registering an unknown type: std::pair<Backend, Target>
register (function) getAvailableBackends (cv_dnn_getAvailableBackends)

--- Incoming ---
[   'cv.dnn.getAvailableTargets',
    'std::vector<Target>',
    [],
    [['Backend', 'be', '', []]],
    None,
    '']
parse_name: cv.dnn.getAvailableTargets with ['cv', 'cv::dnn'] -> fullname:cv::dnn::getAvailableTargets namespace:cv::dnn classpath: classname: name:getAvailableTargets
register (function) getAvailableTargets (cv_dnn_getAvailableTargets_Backend)

--- Incoming ---
[   'class cv.dnn.LayerParams',
    ': cv::dnn::Dict',
    [],
    [   [   'vector_Mat',
            'blobs',
            'List of learned parameters stored as blobs.',
            []],
        [   'String',
            'name',
            'Name of the layer instance (optional, can be used internal '
            'purposes).',
            []],
        [   'String',
            'type',
            'Type name which was used for creating layer by layer factory '
            '(optional).',
            []]],
    None,
    '@brief This class provides all data needed to initialize layer.\n'
    '*\n'
    '* It includes dictionary with scalar params (which can be read by using '
    'Dict interface),\n'
    '* blob params #blobs and optional meta information: #name and #type of '
    'layer instance.']
parse_name: class cv.dnn.LayerParams with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerParams namespace:cv::dnn classpath: classname: name:LayerParams
register class cv::dnn::LayerParams (['class cv.dnn.LayerParams', ': cv::dnn::Dict', [], [['vector_Mat', 'blobs', 'List of learned parameters stored as blobs.', []], ['String', 'name', 'Name of the layer instance (optional, can be used internal purposes).', []], ['String', 'type', 'Type name which was used for creating layer by layer factory (optional).', []]], None, '@brief This class provides all data needed to initialize layer.\n*\n* It includes dictionary with scalar params (which can be read by using Dict interface),\n* blob params #blobs and optional meta information: #name and #type of layer instance.']) impl:cv::dnn::Dict
parse_name: cv.dnn.LayerParams.blobs with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerParams::blobs namespace:cv::dnn classpath:LayerParams classname:LayerParams name:blobs
register (method) blobs in cv::dnn::LayerParams (cv_dnn_LayerParams_blobs)
parse_name: cv.dnn.LayerParams.set_blobs with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerParams::set_blobs namespace:cv::dnn classpath:LayerParams classname:LayerParams name:set_blobs
register (method) set_blobs in cv::dnn::LayerParams (cv_dnn_LayerParams_set_blobs_VectorOfMat)
parse_name: cv.dnn.LayerParams.name with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerParams::name namespace:cv::dnn classpath:LayerParams classname:LayerParams name:name
register (method) name in cv::dnn::LayerParams (cv_dnn_LayerParams_name)
parse_name: cv.dnn.LayerParams.set_name with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerParams::set_name namespace:cv::dnn classpath:LayerParams classname:LayerParams name:set_name
register (method) set_name in cv::dnn::LayerParams (cv_dnn_LayerParams_set_name_String)
parse_name: cv.dnn.LayerParams.type with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerParams::type namespace:cv::dnn classpath:LayerParams classname:LayerParams name:type
register (method) type in cv::dnn::LayerParams (cv_dnn_LayerParams_type)
parse_name: cv.dnn.LayerParams.set_type with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerParams::set_type namespace:cv::dnn classpath:LayerParams classname:LayerParams name:set_type
register (method) set_type in cv::dnn::LayerParams (cv_dnn_LayerParams_set_type_String)

--- Incoming ---
[   'class cv.dnn.BackendNode',
    '',
    [],
    [],
    None,
    '* @brief Derivatives of this class encapsulates functions of certain '
    'backends.']
parse_name: class cv.dnn.BackendNode with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendNode namespace:cv::dnn classpath: classname: name:BackendNode
register class cv::dnn::BackendNode (['class cv.dnn.BackendNode', '', [], [], None, '* @brief Derivatives of this class encapsulates functions of certain backends.'])

--- Incoming ---
[   'cv.dnn.BackendNode.BackendNode',
    'B',
    [],
    [['int', 'backendId', '', []]],
    None,
    '']
parse_name: cv.dnn.BackendNode.BackendNode with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendNode::BackendNode namespace:cv::dnn classpath:BackendNode classname:BackendNode name:BackendNode
register (constructor) new in cv::dnn::BackendNode (cv_dnn_BackendNode_BackendNode_int)

--- Incoming ---
[   'cv.dnn.BackendNode.~BackendNode',
    '~',
    [],
    [],
    None,
    'Virtual destructor to make polymorphism.\n']
parse_name: cv.dnn.BackendNode.~BackendNode with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendNode::~BackendNode namespace:cv::dnn classpath:BackendNode classname:BackendNode name:~BackendNode
ignore destructor (method) ~BackendNode in cv::dnn::BackendNode

--- Incoming ---
[   'class cv.dnn.BackendWrapper',
    '',
    [],
    [],
    None,
    '* @brief Derivatives of this class wraps cv::Mat for different backends '
    'and targets.']
parse_name: class cv.dnn.BackendWrapper with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendWrapper namespace:cv::dnn classpath: classname: name:BackendWrapper
register class cv::dnn::BackendWrapper (['class cv.dnn.BackendWrapper', '', [], [], None, '* @brief Derivatives of this class wraps cv::Mat for different backends and targets.'])

--- Incoming ---
[   'cv.dnn.BackendWrapper.BackendWrapper',
    'B',
    [],
    [['int', 'backendId', '', []], ['int', 'targetId', '', []]],
    None,
    '']
parse_name: cv.dnn.BackendWrapper.BackendWrapper with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendWrapper::BackendWrapper namespace:cv::dnn classpath:BackendWrapper classname:BackendWrapper name:BackendWrapper
register (constructor) new in cv::dnn::BackendWrapper (cv_dnn_BackendWrapper_BackendWrapper_int_int)

--- Incoming ---
[   'cv.dnn.BackendWrapper.BackendWrapper',
    'B',
    [],
    [['int', 'targetId', '', []], ['const cv::Mat&', 'm', '', []]],
    None,
    '* @brief Wrap cv::Mat for specific backend and target.\n'
    '* @param[in] targetId Target identifier.\n'
    '* @param[in] m cv::Mat for wrapping.\n'
    '*\n'
    "* Make CPU->GPU data transfer if it's require for the target."]
parse_name: cv.dnn.BackendWrapper.BackendWrapper with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendWrapper::BackendWrapper namespace:cv::dnn classpath:BackendWrapper classname:BackendWrapper name:BackendWrapper
register (constructor) new in cv::dnn::BackendWrapper (cv_dnn_BackendWrapper_BackendWrapper_int_Mat)

--- Incoming ---
[   'cv.dnn.BackendWrapper.BackendWrapper',
    'B',
    [],
    [   ['const Ptr<BackendWrapper>&', 'base', '', []],
        ['const MatShape&', 'shape', '', []]],
    None,
    '* @brief Make wrapper for reused cv::Mat.\n'
    '* @param[in] base Wrapper of cv::Mat that will be reused.\n'
    '* @param[in] shape Specific shape.\n'
    '*\n'
    "* Initialize wrapper from another one. It'll wrap the same host CPU\n"
    "* memory and mustn't allocate memory on device(i.e. GPU). It might\n"
    '* has different shape. Use in case of CPU memory reusing for reuse\n'
    '* associated memory on device too.']
parse_name: cv.dnn.BackendWrapper.BackendWrapper with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendWrapper::BackendWrapper namespace:cv::dnn classpath:BackendWrapper classname:BackendWrapper name:BackendWrapper
Registering an unknown type: MatShape
register (constructor) new in cv::dnn::BackendWrapper (cv_dnn_BackendWrapper_BackendWrapper_PtrOfBackendWrapper_MatShape)

--- Incoming ---
[   'cv.dnn.BackendWrapper.~BackendWrapper',
    '~',
    [],
    [],
    None,
    'Virtual destructor to make polymorphism.\n']
parse_name: cv.dnn.BackendWrapper.~BackendWrapper with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendWrapper::~BackendWrapper namespace:cv::dnn classpath:BackendWrapper classname:BackendWrapper name:~BackendWrapper
ignore destructor (method) ~BackendWrapper in cv::dnn::BackendWrapper

--- Incoming ---
[   'cv.dnn.BackendWrapper.copyToHost',
    'void',
    ['/A'],
    [],
    None,
    '* @brief Transfer data to CPU host memory.']
parse_name: cv.dnn.BackendWrapper.copyToHost with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendWrapper::copyToHost namespace:cv::dnn classpath:BackendWrapper classname:BackendWrapper name:copyToHost
register (method) copyToHost in cv::dnn::BackendWrapper (trait) (cv_dnn_BackendWrapper_copyToHost)

--- Incoming ---
[   'cv.dnn.BackendWrapper.setHostDirty',
    'void',
    ['/A'],
    [],
    None,
    '* @brief Indicate that an actual data is on CPU.']
parse_name: cv.dnn.BackendWrapper.setHostDirty with ['cv', 'cv::dnn'] -> fullname:cv::dnn::BackendWrapper::setHostDirty namespace:cv::dnn classpath:BackendWrapper classname:BackendWrapper name:setHostDirty
register (method) setHostDirty in cv::dnn::BackendWrapper (trait) (cv_dnn_BackendWrapper_setHostDirty)

--- Incoming ---
[   'class cv.dnn.Layer',
    ': cv::Algorithm',
    [],
    [   [   'vector_Mat',
            'blobs',
            'List of learned parameters must be stored here to allow read them '
            'by using Net::getParam().',
            ['/RW']],
        [   'String',
            'name',
            'Name of the layer instance, can be used for logging or other '
            'internal purposes.',
            []],
        [   'String',
            'type',
            'Type name which was used for creating layer by layer factory.',
            []],
        ['int', 'preferableTarget', 'prefer target for layer forwarding', []]],
    None,
    '@brief This interface class allows to build new Layers - are building '
    'blocks of networks.\n'
    '*\n'
    '* Each class, derived from Layer, must implement allocate() methods to '
    'declare own outputs and forward() to compute outputs.\n'
    '* Also before using the new layer into networks you must register your '
    'layer by using one of @ref dnnLayerFactory "LayerFactory" macros.']
parse_name: class cv.dnn.Layer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer namespace:cv::dnn classpath: classname: name:Layer
register class cv::dnn::Layer (['class cv.dnn.Layer', ': cv::Algorithm', [], [['vector_Mat', 'blobs', 'List of learned parameters must be stored here to allow read them by using Net::getParam().', ['/RW']], ['String', 'name', 'Name of the layer instance, can be used for logging or other internal purposes.', []], ['String', 'type', 'Type name which was used for creating layer by layer factory.', []], ['int', 'preferableTarget', 'prefer target for layer forwarding', []]], None, '@brief This interface class allows to build new Layers - are building blocks of networks.\n*\n* Each class, derived from Layer, must implement allocate() methods to declare own outputs and forward() to compute outputs.\n* Also before using the new layer into networks you must register your layer by using one of @ref dnnLayerFactory "LayerFactory" macros.']) impl:cv::Algorithm
parse_name: cv.dnn.Layer.blobs with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::blobs namespace:cv::dnn classpath:Layer classname:Layer name:blobs
register (method) blobs in cv::dnn::Layer (trait) (cv_dnn_Layer_blobs)
parse_name: cv.dnn.Layer.set_blobs with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::set_blobs namespace:cv::dnn classpath:Layer classname:Layer name:set_blobs
register (method) set_blobs in cv::dnn::Layer (trait) (cv_dnn_Layer_set_blobs_VectorOfMat)
parse_name: cv.dnn.Layer.name with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::name namespace:cv::dnn classpath:Layer classname:Layer name:name
register (method) name in cv::dnn::Layer (trait) (cv_dnn_Layer_name)
parse_name: cv.dnn.Layer.set_name with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::set_name namespace:cv::dnn classpath:Layer classname:Layer name:set_name
register (method) set_name in cv::dnn::Layer (trait) (cv_dnn_Layer_set_name_String)
parse_name: cv.dnn.Layer.type with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::type namespace:cv::dnn classpath:Layer classname:Layer name:type
register (method) type in cv::dnn::Layer (trait) (cv_dnn_Layer_type)
parse_name: cv.dnn.Layer.set_type with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::set_type namespace:cv::dnn classpath:Layer classname:Layer name:set_type
register (method) set_type in cv::dnn::Layer (trait) (cv_dnn_Layer_set_type_String)
parse_name: cv.dnn.Layer.preferableTarget with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::preferableTarget namespace:cv::dnn classpath:Layer classname:Layer name:preferableTarget
register (method) preferableTarget in cv::dnn::Layer (trait) (cv_dnn_Layer_preferableTarget_const)

--- Incoming ---
[   'cv.dnn.Layer.void finalize',
    '_EXTERNAL void',
    [],
    [   ['const std::vector<Mat*> &', 'input', '', []],
        ['std::vector<Mat> &', 'output', '', []]],
    None,
    '@brief Computes and sets internal parameters according to inputs, outputs '
    'and blobs.\n'
    '*  @deprecated Use Layer::finalize(InputArrayOfArrays, '
    'OutputArrayOfArrays) instead\n'
    '*  @param[in]  input  vector of already allocated input blobs\n'
    '*  @param[out] output vector of already allocated output blobs\n'
    '*\n'
    '* If this method is called after network has allocated all memory for '
    'input and output blobs\n'
    '* and before inferencing.']
parse_name: cv.dnn.Layer.void finalize with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::void finalize namespace:cv::dnn classpath:Layer classname:Layer name:void finalize
Registering an unknown type: _EXTERNAL void
register (method) void finalize in cv::dnn::Layer (trait) (cv_dnn_Layer_void_finalize_std_vector<Mat*>_VectorOfMat)

--- Incoming ---
[   'cv.dnn.Layer.finalize',
    'void',
    [],
    [   ['InputArrayOfArrays', 'inputs', '', []],
        ['OutputArrayOfArrays', 'outputs', '', []]],
    None,
    '@brief Computes and sets internal parameters according to inputs, outputs '
    'and blobs.\n'
    '*  @param[in]  inputs  vector of already allocated input blobs\n'
    '*  @param[out] outputs vector of already allocated output blobs\n'
    '*\n'
    '* If this method is called after network has allocated all memory for '
    'input and output blobs\n'
    '* and before inferencing.']
parse_name: cv.dnn.Layer.finalize with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::finalize namespace:cv::dnn classpath:Layer classname:Layer name:finalize
register (method) finalize in cv::dnn::Layer (trait) (cv_dnn_Layer_finalize__InputArray__OutputArray)

--- Incoming ---
[   'cv.dnn.Layer.void forward',
    '_EXTERNAL void',
    [],
    [   ['std::vector<Mat*> &', 'input', '', []],
        ['std::vector<Mat> &', 'output', '', []],
        ['std::vector<Mat> &', 'internals', '', []]],
    None,
    '@brief Given the @p input blobs, computes the output @p blobs.\n'
    '*  @deprecated Use Layer::forward(InputArrayOfArrays, '
    'OutputArrayOfArrays, OutputArrayOfArrays) instead\n'
    '*  @param[in]  input  the input blobs.\n'
    '*  @param[out] output allocated output blobs, which will store results of '
    'the computation.\n'
    '*  @param[out] internals allocated internal blobs']
parse_name: cv.dnn.Layer.void forward with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::void forward namespace:cv::dnn classpath:Layer classname:Layer name:void forward
register (method) void forward in cv::dnn::Layer (trait) (cv_dnn_Layer_void_forward_std_vector<Mat*>_VectorOfMat_VectorOfMat)

--- Incoming ---
[   'cv.dnn.Layer.forward',
    'void',
    [],
    [   ['InputArrayOfArrays', 'inputs', '', []],
        ['OutputArrayOfArrays', 'outputs', '', []],
        ['OutputArrayOfArrays', 'internals', '', []]],
    None,
    '@brief Given the @p input blobs, computes the output @p blobs.\n'
    '*  @param[in]  inputs  the input blobs.\n'
    '*  @param[out] outputs allocated output blobs, which will store results '
    'of the computation.\n'
    '*  @param[out] internals allocated internal blobs']
parse_name: cv.dnn.Layer.forward with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::forward namespace:cv::dnn classpath:Layer classname:Layer name:forward
register (method) forward in cv::dnn::Layer (trait) (cv_dnn_Layer_forward__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.dnn.Layer.forward_fallback',
    'void',
    [],
    [   ['InputArrayOfArrays', 'inputs', '', []],
        ['OutputArrayOfArrays', 'outputs', '', []],
        ['OutputArrayOfArrays', 'internals', '', []]],
    None,
    '@brief Given the @p input blobs, computes the output @p blobs.\n'
    '*  @param[in]  inputs  the input blobs.\n'
    '*  @param[out] outputs allocated output blobs, which will store results '
    'of the computation.\n'
    '*  @param[out] internals allocated internal blobs']
parse_name: cv.dnn.Layer.forward_fallback with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::forward_fallback namespace:cv::dnn classpath:Layer classname:Layer name:forward_fallback
register (method) forward_fallback in cv::dnn::Layer (trait) (cv_dnn_Layer_forward_fallback__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.dnn.Layer.void finalize',
    '_EXTERNAL void',
    [],
    [   ['const std::vector<Mat> &', 'inputs', '', []],
        ['std::vector<Mat> &', 'outputs', '', []]],
    None,
    '@brief\n'
    '* @overload\n'
    '* @deprecated Use Layer::finalize(InputArrayOfArrays, '
    'OutputArrayOfArrays) instead']
parse_name: cv.dnn.Layer.void finalize with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::void finalize namespace:cv::dnn classpath:Layer classname:Layer name:void finalize
register (method) void finalize in cv::dnn::Layer (trait) (cv_dnn_Layer_void_finalize_VectorOfMat_VectorOfMat)

--- Incoming ---
[   'cv.dnn.Layer.finalize',
    'std::vector<Mat>',
    [],
    [['const std::vector<Mat> &', 'inputs', '', []]],
    None,
    '@brief\n'
    '* @overload\n'
    '* @deprecated Use Layer::finalize(InputArrayOfArrays, '
    'OutputArrayOfArrays) instead']
parse_name: cv.dnn.Layer.finalize with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::finalize namespace:cv::dnn classpath:Layer classname:Layer name:finalize
register (method) finalize in cv::dnn::Layer (trait) (cv_dnn_Layer_finalize_VectorOfMat)

--- Incoming ---
[   'cv.dnn.Layer.run',
    'void',
    [],
    [   ['const std::vector<Mat> &', 'inputs', '', []],
        ['std::vector<Mat> &', 'outputs', '', []],
        ['std::vector<Mat> &', 'internals', '', []]],
    None,
    '@brief Allocates layer and computes output.\n'
    '*  @deprecated This method will be removed in the future release.']
parse_name: cv.dnn.Layer.run with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::run namespace:cv::dnn classpath:Layer classname:Layer name:run
register (method) run in cv::dnn::Layer (trait) (cv_dnn_Layer_run_VectorOfMat_VectorOfMat_VectorOfMat)

--- Incoming ---
[   'cv.dnn.Layer.inputNameToIndex',
    'int',
    [],
    [['String', 'inputName', '', []]],
    None,
    '@brief Returns index of input blob into the input array.\n'
    '*  @param inputName label of input blob\n'
    '*\n'
    '* Each layer input and output can be labeled to easily identify them '
    'using "%<layer_name%>[.output_name]" notation.\n'
    '* This method maps label of input blob to its index into input vector.']
parse_name: cv.dnn.Layer.inputNameToIndex with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::inputNameToIndex namespace:cv::dnn classpath:Layer classname:Layer name:inputNameToIndex
register (method) inputNameToIndex in cv::dnn::Layer (trait) (cv_dnn_Layer_inputNameToIndex_String)

--- Incoming ---
[   'cv.dnn.Layer.outputNameToIndex',
    'int',
    [],
    [['const String&', 'outputName', '', []]],
    None,
    '@brief Returns index of output blob in output array.\n'
    '*  @see inputNameToIndex()']
parse_name: cv.dnn.Layer.outputNameToIndex with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::outputNameToIndex namespace:cv::dnn classpath:Layer classname:Layer name:outputNameToIndex
register (method) outputNameToIndex in cv::dnn::Layer (trait) (cv_dnn_Layer_outputNameToIndex_String)

--- Incoming ---
[   'cv.dnn.Layer.supportBackend',
    'bool',
    [],
    [['int', 'backendId', '', []]],
    None,
    '* @brief Ask layer if it support specific backend for doing '
    'computations.\n'
    '* @param[in] backendId computation backend identifier.\n'
    '* @see Backend']
parse_name: cv.dnn.Layer.supportBackend with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::supportBackend namespace:cv::dnn classpath:Layer classname:Layer name:supportBackend
register (method) supportBackend in cv::dnn::Layer (trait) (cv_dnn_Layer_supportBackend_int)

--- Incoming ---
[   'cv.dnn.Layer.initHalide',
    'Ptr<BackendNode>',
    [],
    [['const std::vector<Ptr<BackendWrapper> > &', 'inputs', '', []]],
    None,
    '* @brief Returns Halide backend node.\n'
    '* @param[in] inputs Input Halide buffers.\n'
    '* @see BackendNode, BackendWrapper\n'
    '*\n'
    '* Input buffers should be exactly the same that will be used in forward '
    'invocations.\n'
    '* Despite we can use Halide::ImageParam based on input shape only,\n'
    '* it helps prevent some memory management issues (if something wrong,\n'
    '* Halide tests will be failed).']
parse_name: cv.dnn.Layer.initHalide with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::initHalide namespace:cv::dnn classpath:Layer classname:Layer name:initHalide
register (method) initHalide in cv::dnn::Layer (trait) (cv_dnn_Layer_initHalide_VectorOfPtrOfBackendWrapper)

--- Incoming ---
[   'cv.dnn.Layer.initInfEngine',
    'Ptr<BackendNode>',
    [],
    [['const std::vector<Ptr<BackendWrapper> > &', 'inputs', '', []]],
    None,
    '']
parse_name: cv.dnn.Layer.initInfEngine with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::initInfEngine namespace:cv::dnn classpath:Layer classname:Layer name:initInfEngine
register (method) initInfEngine in cv::dnn::Layer (trait) (cv_dnn_Layer_initInfEngine_VectorOfPtrOfBackendWrapper)

--- Incoming ---
[   'cv.dnn.Layer.initVkCom',
    'Ptr<BackendNode>',
    [],
    [['const std::vector<Ptr<BackendWrapper> > &', 'inputs', '', []]],
    None,
    '']
parse_name: cv.dnn.Layer.initVkCom with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::initVkCom namespace:cv::dnn classpath:Layer classname:Layer name:initVkCom
register (method) initVkCom in cv::dnn::Layer (trait) (cv_dnn_Layer_initVkCom_VectorOfPtrOfBackendWrapper)

--- Incoming ---
[   'cv.dnn.Layer.applyHalideScheduler',
    'void',
    ['/C'],
    [   ['Ptr<BackendNode>&', 'node', '', []],
        ['const std::vector<Mat*> &', 'inputs', '', []],
        ['const std::vector<Mat> &', 'outputs', '', []],
        ['int', 'targetId', '', []]],
    None,
    '* @brief Automatic Halide scheduling based on layer hyper-parameters.\n'
    '* @param[in] node Backend node with Halide functions.\n'
    '* @param[in] inputs Blobs that will be used in forward invocations.\n'
    '* @param[in] outputs Blobs that will be used in forward invocations.\n'
    '* @param[in] targetId Target identifier\n'
    '* @see BackendNode, Target\n'
    '*\n'
    "* Layer don't use own Halide::Func members because we can have applied\n"
    '* layers fusing. In this way the fused function should be scheduled.']
parse_name: cv.dnn.Layer.applyHalideScheduler with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::applyHalideScheduler namespace:cv::dnn classpath:Layer classname:Layer name:applyHalideScheduler
register (method) applyHalideScheduler in cv::dnn::Layer (trait) (cv_dnn_Layer_applyHalideScheduler_const_PtrOfBackendNode_std_vector<Mat*>_VectorOfMat_int)

--- Incoming ---
[   'cv.dnn.Layer.tryAttach',
    'Ptr<BackendNode>',
    [],
    [['const Ptr<BackendNode>&', 'node', '', []]],
    None,
    '* @brief Implement layers fusing.\n'
    '* @param[in] node Backend node of bottom layer.\n'
    '* @see BackendNode\n'
    '*\n'
    '* Actual for graph-based backends. If layer attached successfully,\n'
    '* returns non-empty cv::Ptr to node of the same backend.\n'
    '* Fuse only over the last function.']
parse_name: cv.dnn.Layer.tryAttach with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::tryAttach namespace:cv::dnn classpath:Layer classname:Layer name:tryAttach
register (method) tryAttach in cv::dnn::Layer (trait) (cv_dnn_Layer_tryAttach_PtrOfBackendNode)

--- Incoming ---
[   'cv.dnn.Layer.setActivation',
    'bool',
    [],
    [['const Ptr<ActivationLayer>&', 'layer', '', []]],
    None,
    '* @brief Tries to attach to the layer the subsequent activation layer, '
    'i.e. do the layer fusion in a partial case.\n'
    '* @param[in] layer The subsequent activation layer.\n'
    '*\n'
    '* Returns true if the activation layer has been attached successfully.']
parse_name: cv.dnn.Layer.setActivation with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::setActivation namespace:cv::dnn classpath:Layer classname:Layer name:setActivation
register (method) setActivation in cv::dnn::Layer (trait) (cv_dnn_Layer_setActivation_PtrOfActivationLayer)

--- Incoming ---
[   'cv.dnn.Layer.tryFuse',
    'bool',
    [],
    [['Ptr<Layer>&', 'top', '', []]],
    None,
    '* @brief Try to fuse current layer with a next one\n'
    '* @param[in] top Next layer to be fused.\n'
    '* @returns True if fusion was performed.']
parse_name: cv.dnn.Layer.tryFuse with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::tryFuse namespace:cv::dnn classpath:Layer classname:Layer name:tryFuse
register (method) tryFuse in cv::dnn::Layer (trait) (cv_dnn_Layer_tryFuse_PtrOfLayer)

--- Incoming ---
[   'cv.dnn.Layer.getScaleShift',
    'void',
    ['/C'],
    [['Mat&', 'scale', '', []], ['Mat&', 'shift', '', []]],
    None,
    '* @brief Returns parameters of layers with channel-wise multiplication '
    'and addition.\n'
    '* @param[out] scale Channel-wise multipliers. Total number of values '
    'should\n'
    '*                   be equal to number of channels.\n'
    '* @param[out] shift Channel-wise offsets. Total number of values should\n'
    '*                   be equal to number of channels.\n'
    '*\n'
    '* Some layers can fuse their transformations with further layers.\n'
    '* In example, convolution + batch normalization. This way base layer\n'
    '* use weights from layer after it. Fused layer is skipped.\n'
    '* By default, @p scale and @p shift are empty that means layer has no\n'
    '* element-wise multiplications or additions.']
parse_name: cv.dnn.Layer.getScaleShift with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::getScaleShift namespace:cv::dnn classpath:Layer classname:Layer name:getScaleShift
register (method) getScaleShift in cv::dnn::Layer (trait) (cv_dnn_Layer_getScaleShift_const_Mat_Mat)

--- Incoming ---
[   'cv.dnn.Layer.unsetAttached',
    'void',
    [],
    [],
    None,
    '* @brief "Deattaches" all the layers, attached to particular layer.']
parse_name: cv.dnn.Layer.unsetAttached with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::unsetAttached namespace:cv::dnn classpath:Layer classname:Layer name:unsetAttached
register (method) unsetAttached in cv::dnn::Layer (trait) (cv_dnn_Layer_unsetAttached)

--- Incoming ---
[   'cv.dnn.Layer.getMemoryShapes',
    'bool',
    ['/C'],
    [   ['const std::vector<MatShape> &', 'inputs', '', []],
        ['const int', 'requiredOutputs', '', []],
        ['std::vector<MatShape> &', 'outputs', '', []],
        ['std::vector<MatShape> &', 'internals', '', []]],
    None,
    '']
parse_name: cv.dnn.Layer.getMemoryShapes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::getMemoryShapes namespace:cv::dnn classpath:Layer classname:Layer name:getMemoryShapes
register (method) getMemoryShapes in cv::dnn::Layer (trait) (cv_dnn_Layer_getMemoryShapes_const_VectorOfVectorOfint_int_VectorOfVectorOfint_VectorOfVectorOfint)

--- Incoming ---
[   'cv.dnn.Layer.getFLOPS',
    'int64',
    ['/C'],
    [   ['const std::vector<MatShape> &', 'inputs', '', []],
        ['const std::vector<MatShape> &', 'outputs', '', []]],
    None,
    '']
parse_name: cv.dnn.Layer.getFLOPS with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::getFLOPS namespace:cv::dnn classpath:Layer classname:Layer name:getFLOPS
register (method) getFLOPS in cv::dnn::Layer (trait) (cv_dnn_Layer_getFLOPS_const_VectorOfVectorOfint_VectorOfVectorOfint)

--- Incoming ---
['cv.dnn.Layer.Layer', 'L', [], [], None, '']
parse_name: cv.dnn.Layer.Layer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::Layer namespace:cv::dnn classpath:Layer classname:Layer name:Layer
register (constructor) default in cv::dnn::Layer (trait) (cv_dnn_Layer_Layer)

--- Incoming ---
[   'cv.dnn.Layer.Layer',
    'L',
    ['/E'],
    [['const LayerParams &', 'params', '', []]],
    None,
    'Initializes only #name, #type and #blobs fields.\n']
parse_name: cv.dnn.Layer.Layer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::Layer namespace:cv::dnn classpath:Layer classname:Layer name:Layer
register (constructor) new in cv::dnn::Layer (trait) (cv_dnn_Layer_Layer_LayerParams)

--- Incoming ---
[   'cv.dnn.Layer.setParamsFrom',
    'void',
    [],
    [['const LayerParams &', 'params', '', []]],
    None,
    'Initializes only #name, #type and #blobs fields.\n']
parse_name: cv.dnn.Layer.setParamsFrom with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::setParamsFrom namespace:cv::dnn classpath:Layer classname:Layer name:setParamsFrom
register (method) setParamsFrom in cv::dnn::Layer (trait) (cv_dnn_Layer_setParamsFrom_LayerParams)

--- Incoming ---
['cv.dnn.Layer.~Layer', '~', [], [], None, '']
parse_name: cv.dnn.Layer.~Layer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Layer::~Layer namespace:cv::dnn classpath:Layer classname:Layer name:~Layer
ignore destructor (method) ~Layer in cv::dnn::Layer (trait)

--- Incoming ---
[   'class cv.dnn.Net',
    '',
    ['/Simple'],
    [],
    None,
    '@brief This class allows to create and manipulate comprehensive '
    'artificial neural networks.\n'
    '*\n'
    '* Neural network is presented as directed acyclic graph (DAG), where '
    'vertices are Layer instances,\n'
    '* and edges specify relationships between layers inputs and outputs.\n'
    '*\n'
    '* Each network layer has unique integer id and unique string name inside '
    'its network.\n'
    '* LayerId can store either layer name or layer id.\n'
    '*\n'
    '* This class supports reference counting of its instances, i. e. copies '
    'point to the same instance.']
parse_name: class cv.dnn.Net with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net namespace:cv::dnn classpath: classname: name:Net
register class cv::dnn::Net (['class cv.dnn.Net', '', [], [], None, '@brief This class allows to create and manipulate comprehensive artificial neural networks.\n*\n* Neural network is presented as directed acyclic graph (DAG), where vertices are Layer instances,\n* and edges specify relationships between layers inputs and outputs.\n*\n* Each network layer has unique integer id and unique string name inside its network.\n* LayerId can store either layer name or layer id.\n*\n* This class supports reference counting of its instances, i. e. copies point to the same instance.'])

--- Incoming ---
['cv.dnn.Net.Net', 'N', [], [], None, 'Default constructor.\n']
parse_name: cv.dnn.Net.Net with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::Net namespace:cv::dnn classpath:Net classname:Net name:Net
register (constructor) default in cv::dnn::Net (cv_dnn_Net_Net)

--- Incoming ---
[   'cv.dnn.Net.~Net',
    '~',
    [],
    [],
    None,
    "Destructor frees the net only if there aren't references to the net "
    'anymore.\n']
parse_name: cv.dnn.Net.~Net with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::~Net namespace:cv::dnn classpath:Net classname:Net name:~Net
ignore destructor (method) ~Net in cv::dnn::Net

--- Incoming ---
[   'cv.dnn.Net.readFromModelOptimizer',
    'Net',
    ['/S'],
    [['const String&', 'xml', '', []], ['const String&', 'bin', '', []]],
    None,
    "@brief Create a network from Intel's Model Optimizer intermediate "
    'representation.\n'
    "*  @param[in] xml XML configuration file with network's topology.\n"
    '*  @param[in] bin Binary file with trained weights.\n'
    "*  Networks imported from Intel's Model Optimizer are launched in Intel's "
    'Inference Engine\n'
    '*  backend.']
parse_name: cv.dnn.Net.readFromModelOptimizer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::readFromModelOptimizer namespace:cv::dnn classpath:Net classname:Net name:readFromModelOptimizer
register (method) readFromModelOptimizer in cv::dnn::Net (cv_dnn_Net_readFromModelOptimizer_String_String)

--- Incoming ---
[   'cv.dnn.Net.empty',
    'bool',
    ['/C'],
    [],
    None,
    'Returns true if there are no layers in the network.']
parse_name: cv.dnn.Net.empty with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::empty namespace:cv::dnn classpath:Net classname:Net name:empty
register (method) empty in cv::dnn::Net (cv_dnn_Net_empty_const)

--- Incoming ---
[   'cv.dnn.Net.dump',
    'String',
    [],
    [],
    None,
    '@brief Dump net to String\n'
    '*  @returns String with structure, hyperparameters, backend, target and '
    'fusion\n'
    '*  Call method after setInput(). To see correct backend, target and '
    'fusion run after forward().']
parse_name: cv.dnn.Net.dump with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::dump namespace:cv::dnn classpath:Net classname:Net name:dump
register (method) dump in cv::dnn::Net (cv_dnn_Net_dump)

--- Incoming ---
[   'cv.dnn.Net.dumpToFile',
    'void',
    [],
    [['const String&', 'path', '', []]],
    None,
    '@brief Dump net structure, hyperparameters, backend, target and fusion to '
    'dot file\n'
    '*  @param path   path to output file with .dot extension\n'
    '*  @see dump()']
parse_name: cv.dnn.Net.dumpToFile with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::dumpToFile namespace:cv::dnn classpath:Net classname:Net name:dumpToFile
register (method) dumpToFile in cv::dnn::Net (cv_dnn_Net_dumpToFile_String)

--- Incoming ---
[   'cv.dnn.Net.addLayer',
    'int',
    [],
    [   ['const String &', 'name', '', []],
        ['const String &', 'type', '', []],
        ['LayerParams &', 'params', '', []]],
    None,
    '@brief Adds new layer to the net.\n'
    '*  @param name   unique name of the adding layer.\n'
    '*  @param type   typename of the adding layer (type must be registered in '
    'LayerRegister).\n'
    '*  @param params parameters which will be used to initialize the creating '
    'layer.\n'
    '*  @returns unique identifier of created layer, or -1 if a failure will '
    'happen.']
parse_name: cv.dnn.Net.addLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::addLayer namespace:cv::dnn classpath:Net classname:Net name:addLayer
register (method) addLayer in cv::dnn::Net (cv_dnn_Net_addLayer_String_String_LayerParams)

--- Incoming ---
[   'cv.dnn.Net.addLayerToPrev',
    'int',
    [],
    [   ['const String &', 'name', '', []],
        ['const String &', 'type', '', []],
        ['LayerParams &', 'params', '', []]],
    None,
    '@brief Adds new layer and connects its first input to the first output of '
    'previously added layer.\n'
    '*  @see addLayer()']
parse_name: cv.dnn.Net.addLayerToPrev with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::addLayerToPrev namespace:cv::dnn classpath:Net classname:Net name:addLayerToPrev
register (method) addLayerToPrev in cv::dnn::Net (cv_dnn_Net_addLayerToPrev_String_String_LayerParams)

--- Incoming ---
[   'cv.dnn.Net.getLayerId',
    'int',
    [],
    [['const String &', 'layer', '', []]],
    None,
    '@brief Converts string name of the layer to the integer identifier.\n'
    "*  @returns id of the layer, or -1 if the layer wasn't found."]
parse_name: cv.dnn.Net.getLayerId with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayerId namespace:cv::dnn classpath:Net classname:Net name:getLayerId
register (method) getLayerId in cv::dnn::Net (cv_dnn_Net_getLayerId_String)

--- Incoming ---
['cv.dnn.Net.getLayerNames', 'std::vector<String>', ['/C'], [], None, '']
parse_name: cv.dnn.Net.getLayerNames with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayerNames namespace:cv::dnn classpath:Net classname:Net name:getLayerNames
register (method) getLayerNames in cv::dnn::Net (cv_dnn_Net_getLayerNames_const)

--- Incoming ---
[   'typedef cv.dnn.Net.LayerId',
    'DictValue',
    '',
    [],
    None,
    '@brief Container for strings and integers.']
parse_name: typedef cv.dnn.Net.LayerId with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::LayerId namespace:cv::dnn classpath:Net classname:Net name:LayerId
Registering an unknown type: LayerId

--- Incoming ---
[   'cv.dnn.Net.getLayer',
    'Ptr<Layer>',
    [],
    [['LayerId', 'layerId', '', []]],
    None,
    '@brief Returns pointer to layer with specified id or name which the '
    'network use.']
parse_name: cv.dnn.Net.getLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayer namespace:cv::dnn classpath:Net classname:Net name:getLayer
register (method) getLayer in cv::dnn::Net (cv_dnn_Net_getLayer_DictValue)

--- Incoming ---
[   'cv.dnn.Net.getLayerInputs',
    'std::vector<Ptr<Layer> >',
    [],
    [['LayerId', 'layerId', '', []]],
    None,
    '@brief Returns pointers to input layers of specific layer.']
parse_name: cv.dnn.Net.getLayerInputs with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayerInputs namespace:cv::dnn classpath:Net classname:Net name:getLayerInputs
register (method) getLayerInputs in cv::dnn::Net (cv_dnn_Net_getLayerInputs_DictValue)

--- Incoming ---
[   'cv.dnn.Net.connect',
    'void',
    [],
    [['String', 'outPin', '', []], ['String', 'inpPin', '', []]],
    None,
    '@brief Connects output of the first layer to input of the second layer.\n'
    '*  @param outPin descriptor of the first layer output.\n'
    '*  @param inpPin descriptor of the second layer input.\n'
    '*\n'
    '* Descriptors have the following template '
    '<DFN>&lt;layer_name&gt;[.input_number]</DFN>:\n'
    '* - the first part of the template <DFN>layer_name</DFN> is sting name of '
    'the added layer.\n'
    '*   If this part is empty then the network input pseudo layer will be '
    'used;\n'
    '* - the second optional part of the template <DFN>input_number</DFN>\n'
    '*   is either number of the layer input, either label one.\n'
    '*   If this part is omitted then the first layer input will be used.\n'
    '*\n'
    '*  @see setNetInputs(), Layer::inputNameToIndex(), '
    'Layer::outputNameToIndex()']
parse_name: cv.dnn.Net.connect with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::connect namespace:cv::dnn classpath:Net classname:Net name:connect
register (method) connect in cv::dnn::Net (cv_dnn_Net_connect_String_String)

--- Incoming ---
[   'cv.dnn.Net.connect',
    'void',
    [],
    [   ['int', 'outLayerId', '', []],
        ['int', 'outNum', '', []],
        ['int', 'inpLayerId', '', []],
        ['int', 'inpNum', '', []]],
    None,
    '@brief Connects #@p outNum output of the first layer to #@p inNum input '
    'of the second layer.\n'
    '*  @param outLayerId identifier of the first layer\n'
    '*  @param outNum number of the first layer output\n'
    '*  @param inpLayerId identifier of the second layer\n'
    '*  @param inpNum number of the second layer input']
parse_name: cv.dnn.Net.connect with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::connect namespace:cv::dnn classpath:Net classname:Net name:connect
register (method) connect in cv::dnn::Net (cv_dnn_Net_connect_int_int_int_int)

--- Incoming ---
[   'cv.dnn.Net.setInputsNames',
    'void',
    [],
    [['const std::vector<String> &', 'inputBlobNames', '', []]],
    None,
    '@brief Sets outputs names of the network input pseudo layer.\n'
    '*\n'
    '* Each net always has special own the network input pseudo layer with '
    'id=0.\n'
    "* This layer stores the user blobs only and don't make any computations.\n"
    '* In fact, this layer provides the only way to pass user data into the '
    'network.\n'
    '* As any other layer, this layer can label its outputs and this function '
    'provides an easy way to do this.']
parse_name: cv.dnn.Net.setInputsNames with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::setInputsNames namespace:cv::dnn classpath:Net classname:Net name:setInputsNames
register (method) setInputsNames in cv::dnn::Net (cv_dnn_Net_setInputsNames_VectorOfString)

--- Incoming ---
[   'cv.dnn.Net.forward',
    'Mat',
    [],
    [['const String&', 'outputName', 'String()', []]],
    None,
    '@brief Runs forward pass to compute output of layer with name @p '
    'outputName.\n'
    '*  @param outputName name for layer which output is needed to get\n'
    '*  @return blob for first output of specified layer.\n'
    '*  @details By default runs forward pass for the whole network.']
parse_name: cv.dnn.Net.forward with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::forward namespace:cv::dnn classpath:Net classname:Net name:forward
register (method) forward in cv::dnn::Net (cv_dnn_Net_forward_String)

--- Incoming ---
[   'cv.dnn.Net.forwardAsync',
    'AsyncArray',
    [],
    [['const String&', 'outputName', 'String()', []]],
    None,
    '@brief Runs forward pass to compute output of layer with name @p '
    'outputName.\n'
    '*  @param outputName name for layer which output is needed to get\n'
    '*  @details By default runs forward pass for the whole network.\n'
    '*\n'
    '*  This is an asynchronous version of forward(const String&).\n'
    '*  dnn::DNN_BACKEND_INFERENCE_ENGINE backend is required.']
parse_name: cv.dnn.Net.forwardAsync with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::forwardAsync namespace:cv::dnn classpath:Net classname:Net name:forwardAsync
Registering an unknown type: AsyncArray
register (method) forwardAsync in cv::dnn::Net (cv_dnn_Net_forwardAsync_String)

--- Incoming ---
[   'cv.dnn.Net.forward',
    'void',
    [],
    [   ['OutputArrayOfArrays', 'outputBlobs', '', []],
        ['const String&', 'outputName', 'String()', []]],
    None,
    '@brief Runs forward pass to compute output of layer with name @p '
    'outputName.\n'
    '*  @param outputBlobs contains all output blobs for specified layer.\n'
    '*  @param outputName name for layer which output is needed to get\n'
    '*  @details If @p outputName is empty, runs forward pass for the whole '
    'network.']
parse_name: cv.dnn.Net.forward with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::forward namespace:cv::dnn classpath:Net classname:Net name:forward
register (method) forward in cv::dnn::Net (cv_dnn_Net_forward__OutputArray_String)

--- Incoming ---
[   'cv.dnn.Net.forward',
    'void',
    [],
    [   ['OutputArrayOfArrays', 'outputBlobs', '', []],
        ['const std::vector<String>&', 'outBlobNames', '', []]],
    None,
    '@brief Runs forward pass to compute outputs of layers listed in @p '
    'outBlobNames.\n'
    '*  @param outputBlobs contains blobs for first outputs of specified '
    'layers.\n'
    '*  @param outBlobNames names for layers which outputs are needed to get']
parse_name: cv.dnn.Net.forward with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::forward namespace:cv::dnn classpath:Net classname:Net name:forward
register (method) forward in cv::dnn::Net (cv_dnn_Net_forward__OutputArray_VectorOfString)

--- Incoming ---
[   'cv.dnn.Net.forward',
    'void',
    [],
    [   ['std::vector<std::vector<Mat> >&', 'outputBlobs', '', []],
        ['const std::vector<String>&', 'outBlobNames', '', []]],
    None,
    '@brief Runs forward pass to compute outputs of layers listed in @p '
    'outBlobNames.\n'
    '*  @param outputBlobs contains all output blobs for each layer specified '
    'in @p outBlobNames.\n'
    '*  @param outBlobNames names for layers which outputs are needed to get']
parse_name: cv.dnn.Net.forward with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::forward namespace:cv::dnn classpath:Net classname:Net name:forward
register (method) forward in cv::dnn::Net (cv_dnn_Net_forward_VectorOfVectorOfMat_VectorOfString)

--- Incoming ---
[   'cv.dnn.Net.setHalideScheduler',
    'void',
    [],
    [['const String&', 'scheduler', '', []]],
    None,
    '* @brief Compile Halide layers.\n'
    '* @param[in] scheduler Path to YAML file with scheduling directives.\n'
    '* @see setPreferableBackend\n'
    '*\n'
    '* Schedule layers that support Halide backend. Then compile them for\n'
    '* specific target. For layers that not represented in scheduling file\n'
    '* or if no manual scheduling used at all, automatic scheduling will be '
    'applied.']
parse_name: cv.dnn.Net.setHalideScheduler with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::setHalideScheduler namespace:cv::dnn classpath:Net classname:Net name:setHalideScheduler
register (method) setHalideScheduler in cv::dnn::Net (cv_dnn_Net_setHalideScheduler_String)

--- Incoming ---
[   'cv.dnn.Net.setPreferableBackend',
    'void',
    [],
    [['int', 'backendId', '', []]],
    None,
    '* @brief Ask network to use specific computation backend where it '
    'supported.\n'
    '* @param[in] backendId backend identifier.\n'
    '* @see Backend\n'
    '*\n'
    "* If OpenCV is compiled with Intel's Inference Engine library, "
    'DNN_BACKEND_DEFAULT\n'
    '* means DNN_BACKEND_INFERENCE_ENGINE. Otherwise it equals to '
    'DNN_BACKEND_OPENCV.']
parse_name: cv.dnn.Net.setPreferableBackend with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::setPreferableBackend namespace:cv::dnn classpath:Net classname:Net name:setPreferableBackend
register (method) setPreferableBackend in cv::dnn::Net (cv_dnn_Net_setPreferableBackend_int)

--- Incoming ---
[   'cv.dnn.Net.setPreferableTarget',
    'void',
    [],
    [['int', 'targetId', '', []]],
    None,
    '* @brief Ask network to make computations on specific target device.\n'
    '* @param[in] targetId target identifier.\n'
    '* @see Target\n'
    '*\n'
    '* List of supported combinations backend / target:\n'
    '* |                        | DNN_BACKEND_OPENCV | '
    'DNN_BACKEND_INFERENCE_ENGINE | DNN_BACKEND_HALIDE |\n'
    '* '
    '|------------------------|--------------------|------------------------------|--------------------|\n'
    '* | DNN_TARGET_CPU         |                  + '
    '|                            + |                  + |\n'
    '* | DNN_TARGET_OPENCL      |                  + '
    '|                            + |                  + |\n'
    '* | DNN_TARGET_OPENCL_FP16 |                  + '
    '|                            + |                    |\n'
    '* | DNN_TARGET_MYRIAD      |                    '
    '|                            + |                    |\n'
    '* | DNN_TARGET_FPGA        |                    '
    '|                            + |                    |']
parse_name: cv.dnn.Net.setPreferableTarget with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::setPreferableTarget namespace:cv::dnn classpath:Net classname:Net name:setPreferableTarget
register (method) setPreferableTarget in cv::dnn::Net (cv_dnn_Net_setPreferableTarget_int)

--- Incoming ---
[   'cv.dnn.Net.setInput',
    'void',
    [],
    [   ['InputArray', 'blob', '', []],
        ['const String&', 'name', '""', []],
        ['double', 'scalefactor', '1.0', []],
        ['const Scalar&', 'mean', 'Scalar()', []]],
    None,
    '@brief Sets the new input value for the network\n'
    '*  @param blob        A new blob. Should have CV_32F or CV_8U depth.\n'
    '*  @param name        A name of input layer.\n'
    '*  @param scalefactor An optional normalization scale.\n'
    '*  @param mean        An optional mean subtraction values.\n'
    '*  @see connect(String, String) to know format of the descriptor.\n'
    '*\n'
    '*  If scale or mean values are specified, a final input blob is computed\n'
    '*  as:\n'
    '* \\f[input(n,c,h,w) = scalefactor \\times (blob(n,c,h,w) - mean_c)\\f]']
parse_name: cv.dnn.Net.setInput with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::setInput namespace:cv::dnn classpath:Net classname:Net name:setInput
register (method) setInput in cv::dnn::Net (cv_dnn_Net_setInput__InputArray_String_double_Scalar)

--- Incoming ---
[   'cv.dnn.Net.setParam',
    'void',
    [],
    [   ['LayerId', 'layer', '', []],
        ['int', 'numParam', '', []],
        ['const Mat &', 'blob', '', []]],
    None,
    '@brief Sets the new value for the learned param of the layer.\n'
    '*  @param layer name or id of the layer.\n'
    '*  @param numParam index of the layer parameter in the Layer::blobs '
    'array.\n'
    '*  @param blob the new value.\n'
    '*  @see Layer::blobs\n'
    '*  @note If shape of the new blob differs from the previous shape,\n'
    '*  then the following forward pass may fail.']
parse_name: cv.dnn.Net.setParam with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::setParam namespace:cv::dnn classpath:Net classname:Net name:setParam
register (method) setParam in cv::dnn::Net (cv_dnn_Net_setParam_DictValue_int_Mat)

--- Incoming ---
[   'cv.dnn.Net.getParam',
    'Mat',
    [],
    [['LayerId', 'layer', '', []], ['int', 'numParam', '0', []]],
    None,
    '@brief Returns parameter blob of the layer.\n'
    '*  @param layer name or id of the layer.\n'
    '*  @param numParam index of the layer parameter in the Layer::blobs '
    'array.\n'
    '*  @see Layer::blobs']
parse_name: cv.dnn.Net.getParam with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getParam namespace:cv::dnn classpath:Net classname:Net name:getParam
register (method) getParam in cv::dnn::Net (cv_dnn_Net_getParam_DictValue_int)

--- Incoming ---
[   'cv.dnn.Net.getUnconnectedOutLayers',
    'std::vector<int>',
    ['/C'],
    [],
    None,
    '@brief Returns indexes of layers with unconnected outputs.']
parse_name: cv.dnn.Net.getUnconnectedOutLayers with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getUnconnectedOutLayers namespace:cv::dnn classpath:Net classname:Net name:getUnconnectedOutLayers
register (method) getUnconnectedOutLayers in cv::dnn::Net (cv_dnn_Net_getUnconnectedOutLayers_const)

--- Incoming ---
[   'cv.dnn.Net.getUnconnectedOutLayersNames',
    'std::vector<String>',
    ['/C'],
    [],
    None,
    '@brief Returns names of layers with unconnected outputs.']
parse_name: cv.dnn.Net.getUnconnectedOutLayersNames with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getUnconnectedOutLayersNames namespace:cv::dnn classpath:Net classname:Net name:getUnconnectedOutLayersNames
register (method) getUnconnectedOutLayersNames in cv::dnn::Net (cv_dnn_Net_getUnconnectedOutLayersNames_const)

--- Incoming ---
[   'cv.dnn.Net.getLayersShapes',
    'void',
    ['/C'],
    [   ['const std::vector<MatShape>&', 'netInputShapes', '', []],
        ['std::vector<int>&', 'layersIds', '', []],
        ['std::vector<std::vector<MatShape> >&', 'inLayersShapes', '', []],
        ['std::vector<std::vector<MatShape> >&', 'outLayersShapes', '', []]],
    None,
    '@brief Returns input and output shapes for all layers in loaded model;\n'
    "*  preliminary inferencing isn't necessary.\n"
    '*  @param netInputShapes shapes for all input blobs in net input layer.\n'
    '*  @param layersIds output parameter for layer IDs.\n'
    '*  @param inLayersShapes output parameter for input layers shapes;\n'
    '* order is the same as in layersIds\n'
    '*  @param outLayersShapes output parameter for output layers shapes;\n'
    '* order is the same as in layersIds']
parse_name: cv.dnn.Net.getLayersShapes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayersShapes namespace:cv::dnn classpath:Net classname:Net name:getLayersShapes
register (method) getLayersShapes in cv::dnn::Net (cv_dnn_Net_getLayersShapes_const_VectorOfVectorOfint_VectorOfint_VectorOfVectorOfVectorOfint_VectorOfVectorOfVectorOfint)

--- Incoming ---
[   'cv.dnn.Net.getLayersShapes',
    'void',
    ['/C'],
    [   ['const MatShape&', 'netInputShape', '', []],
        ['std::vector<int>&', 'layersIds', '', []],
        ['std::vector<std::vector<MatShape> >&', 'inLayersShapes', '', []],
        ['std::vector<std::vector<MatShape> >&', 'outLayersShapes', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getLayersShapes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayersShapes namespace:cv::dnn classpath:Net classname:Net name:getLayersShapes
register (method) getLayersShapes in cv::dnn::Net (cv_dnn_Net_getLayersShapes_const_MatShape_VectorOfint_VectorOfVectorOfVectorOfint_VectorOfVectorOfVectorOfint)

--- Incoming ---
[   'cv.dnn.Net.getLayerShapes',
    'void',
    ['/C'],
    [   ['const MatShape&', 'netInputShape', '', []],
        ['const int', 'layerId', '', []],
        ['std::vector<MatShape>&', 'inLayerShapes', '', []],
        ['std::vector<MatShape>&', 'outLayerShapes', '', []]],
    None,
    '@brief Returns input and output shapes for layer with specified\n'
    "* id in loaded model; preliminary inferencing isn't necessary.\n"
    '*  @param netInputShape shape input blob in net input layer.\n'
    '*  @param layerId id for layer.\n'
    '*  @param inLayerShapes output parameter for input layers shapes;\n'
    '* order is the same as in layersIds\n'
    '*  @param outLayerShapes output parameter for output layers shapes;\n'
    '* order is the same as in layersIds']
parse_name: cv.dnn.Net.getLayerShapes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayerShapes namespace:cv::dnn classpath:Net classname:Net name:getLayerShapes
register (method) getLayerShapes in cv::dnn::Net (cv_dnn_Net_getLayerShapes_const_MatShape_int_VectorOfVectorOfint_VectorOfVectorOfint)

--- Incoming ---
[   'cv.dnn.Net.getLayerShapes',
    'void',
    ['/C'],
    [   ['const std::vector<MatShape>&', 'netInputShapes', '', []],
        ['const int', 'layerId', '', []],
        ['std::vector<MatShape>&', 'inLayerShapes', '', []],
        ['std::vector<MatShape>&', 'outLayerShapes', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getLayerShapes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayerShapes namespace:cv::dnn classpath:Net classname:Net name:getLayerShapes
register (method) getLayerShapes in cv::dnn::Net (cv_dnn_Net_getLayerShapes_const_VectorOfVectorOfint_int_VectorOfVectorOfint_VectorOfVectorOfint)

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [['const std::vector<MatShape>&', 'netInputShapes', '', []]],
    None,
    '@brief Computes FLOP for whole loaded model with specified input shapes.\n'
    '* @param netInputShapes vector of shapes for all net inputs.\n'
    '* @returns computed FLOP.']
parse_name: cv.dnn.Net.getFLOPS with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getFLOPS namespace:cv::dnn classpath:Net classname:Net name:getFLOPS
register (method) getFLOPS in cv::dnn::Net (cv_dnn_Net_getFLOPS_const_VectorOfVectorOfint)

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [['const MatShape&', 'netInputShape', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getFLOPS with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getFLOPS namespace:cv::dnn classpath:Net classname:Net name:getFLOPS
register (method) getFLOPS in cv::dnn::Net (cv_dnn_Net_getFLOPS_const_MatShape)

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [   ['const int', 'layerId', '', []],
        ['const std::vector<MatShape>&', 'netInputShapes', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getFLOPS with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getFLOPS namespace:cv::dnn classpath:Net classname:Net name:getFLOPS
register (method) getFLOPS in cv::dnn::Net (cv_dnn_Net_getFLOPS_const_int_VectorOfVectorOfint)

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [   ['const int', 'layerId', '', []],
        ['const MatShape&', 'netInputShape', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getFLOPS with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getFLOPS namespace:cv::dnn classpath:Net classname:Net name:getFLOPS
register (method) getFLOPS in cv::dnn::Net (cv_dnn_Net_getFLOPS_const_int_MatShape)

--- Incoming ---
[   'cv.dnn.Net.getLayerTypes',
    'void',
    ['/C'],
    [['std::vector<String>&', 'layersTypes', '', []]],
    None,
    '@brief Returns list of types for layer used in model.\n'
    '* @param layersTypes output parameter for returning types.']
parse_name: cv.dnn.Net.getLayerTypes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayerTypes namespace:cv::dnn classpath:Net classname:Net name:getLayerTypes
register (method) getLayerTypes in cv::dnn::Net (cv_dnn_Net_getLayerTypes_const_VectorOfString)

--- Incoming ---
[   'cv.dnn.Net.getLayersCount',
    'int',
    ['/C'],
    [['const String&', 'layerType', '', []]],
    None,
    '@brief Returns count of layers of specified type.\n'
    '* @param layerType type.\n'
    '* @returns count of layers']
parse_name: cv.dnn.Net.getLayersCount with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getLayersCount namespace:cv::dnn classpath:Net classname:Net name:getLayersCount
register (method) getLayersCount in cv::dnn::Net (cv_dnn_Net_getLayersCount_const_String)

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['const std::vector<MatShape>&', 'netInputShapes', '', []],
        ['size_t&', 'weights', '', []],
        ['size_t&', 'blobs', '', []]],
    None,
    '@brief Computes bytes number which are required to store\n'
    '* all weights and intermediate blobs for model.\n'
    '* @param netInputShapes vector of shapes for all net inputs.\n'
    '* @param weights output parameter to store resulting bytes for weights.\n'
    '* @param blobs output parameter to store resulting bytes for intermediate '
    'blobs.']
parse_name: cv.dnn.Net.getMemoryConsumption with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getMemoryConsumption namespace:cv::dnn classpath:Net classname:Net name:getMemoryConsumption
register (method) getMemoryConsumption in cv::dnn::Net (cv_dnn_Net_getMemoryConsumption_const_VectorOfVectorOfint_size_t_size_t)

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['const MatShape&', 'netInputShape', '', []],
        ['size_t&', 'weights', '', []],
        ['size_t&', 'blobs', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getMemoryConsumption with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getMemoryConsumption namespace:cv::dnn classpath:Net classname:Net name:getMemoryConsumption
register (method) getMemoryConsumption in cv::dnn::Net (cv_dnn_Net_getMemoryConsumption_const_MatShape_size_t_size_t)

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['const int', 'layerId', '', []],
        ['const std::vector<MatShape>&', 'netInputShapes', '', []],
        ['size_t&', 'weights', '', []],
        ['size_t&', 'blobs', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getMemoryConsumption with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getMemoryConsumption namespace:cv::dnn classpath:Net classname:Net name:getMemoryConsumption
register (method) getMemoryConsumption in cv::dnn::Net (cv_dnn_Net_getMemoryConsumption_const_int_VectorOfVectorOfint_size_t_size_t)

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['const int', 'layerId', '', []],
        ['const MatShape&', 'netInputShape', '', []],
        ['size_t&', 'weights', '', []],
        ['size_t&', 'blobs', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getMemoryConsumption with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getMemoryConsumption namespace:cv::dnn classpath:Net classname:Net name:getMemoryConsumption
register (method) getMemoryConsumption in cv::dnn::Net (cv_dnn_Net_getMemoryConsumption_const_int_MatShape_size_t_size_t)

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['const std::vector<MatShape>&', 'netInputShapes', '', []],
        ['std::vector<int>&', 'layerIds', '', []],
        ['std::vector<size_t>&', 'weights', '', []],
        ['std::vector<size_t>&', 'blobs', '', []]],
    None,
    '@brief Computes bytes number which are required to store\n'
    '* all weights and intermediate blobs for each layer.\n'
    '* @param netInputShapes vector of shapes for all net inputs.\n'
    '* @param layerIds output vector to save layer IDs.\n'
    '* @param weights output parameter to store resulting bytes for weights.\n'
    '* @param blobs output parameter to store resulting bytes for intermediate '
    'blobs.']
parse_name: cv.dnn.Net.getMemoryConsumption with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getMemoryConsumption namespace:cv::dnn classpath:Net classname:Net name:getMemoryConsumption
register (method) getMemoryConsumption in cv::dnn::Net (cv_dnn_Net_getMemoryConsumption_const_VectorOfVectorOfint_VectorOfint_VectorOfsize_t_VectorOfsize_t)

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['const MatShape&', 'netInputShape', '', []],
        ['std::vector<int>&', 'layerIds', '', []],
        ['std::vector<size_t>&', 'weights', '', []],
        ['std::vector<size_t>&', 'blobs', '', []]],
    None,
    '@overload']
parse_name: cv.dnn.Net.getMemoryConsumption with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getMemoryConsumption namespace:cv::dnn classpath:Net classname:Net name:getMemoryConsumption
register (method) getMemoryConsumption in cv::dnn::Net (cv_dnn_Net_getMemoryConsumption_const_MatShape_VectorOfint_VectorOfsize_t_VectorOfsize_t)

--- Incoming ---
[   'cv.dnn.Net.enableFusion',
    'void',
    [],
    [['bool', 'fusion', '', []]],
    None,
    '@brief Enables or disables layer fusion in the network.\n'
    '* @param fusion true to enable the fusion, false to disable. The fusion '
    'is enabled by default.']
parse_name: cv.dnn.Net.enableFusion with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::enableFusion namespace:cv::dnn classpath:Net classname:Net name:enableFusion
register (method) enableFusion in cv::dnn::Net (cv_dnn_Net_enableFusion_bool)

--- Incoming ---
[   'cv.dnn.Net.getPerfProfile',
    'int64',
    [],
    [['std::vector<double>&', 'timings', '', []]],
    None,
    '@brief Returns overall time for inference and timings (in ticks) for '
    'layers.\n'
    '* Indexes in returned vector correspond to layers ids. Some layers can be '
    'fused with others,\n'
    '* in this case zero ticks count will be return for that skipped layers.\n'
    '* @param timings vector for tick timings for all layers.\n'
    '* @return overall ticks for model inference.']
parse_name: cv.dnn.Net.getPerfProfile with ['cv', 'cv::dnn'] -> fullname:cv::dnn::Net::getPerfProfile namespace:cv::dnn classpath:Net classname:Net name:getPerfProfile
register (method) getPerfProfile in cv::dnn::Net (cv_dnn_Net_getPerfProfile_VectorOfdouble)

--- Incoming ---
[   'cv.dnn.readNetFromDarknet',
    'Net',
    [],
    [   ['const String &', 'cfgFile', '', []],
        ['const String &', 'darknetModel', 'String()', []]],
    None,
    '@brief Reads a network model stored in <a '
    'href="https://pjreddie.com/darknet/">Darknet</a> model files.\n'
    '*  @param cfgFile      path to the .cfg file with text description of the '
    'network architecture.\n'
    '*  @param darknetModel path to the .weights file with learned network.\n'
    '*  @returns Network object that ready to do forward, throw an exception '
    'in failure cases.\n'
    '*  @returns Net object.']
parse_name: cv.dnn.readNetFromDarknet with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromDarknet namespace:cv::dnn classpath: classname: name:readNetFromDarknet
register (function) readNetFromDarknet (cv_dnn_readNetFromDarknet_String_String)

--- Incoming ---
[   'cv.dnn.readNetFromDarknet',
    'Net',
    [],
    [   ['const std::vector<uchar>&', 'bufferCfg', '', []],
        [   'const std::vector<uchar>&',
            'bufferModel',
            'std::vector<uchar>()',
            []]],
    None,
    '@brief Reads a network model stored in <a '
    'href="https://pjreddie.com/darknet/">Darknet</a> model files.\n'
    '*  @param bufferCfg   A buffer contains a content of .cfg file with text '
    'description of the network architecture.\n'
    '*  @param bufferModel A buffer contains a content of .weights file with '
    'learned network.\n'
    '*  @returns Net object.']
parse_name: cv.dnn.readNetFromDarknet with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromDarknet namespace:cv::dnn classpath: classname: name:readNetFromDarknet
register (function) readNetFromDarknet (cv_dnn_readNetFromDarknet_VectorOfuchar_VectorOfuchar)

--- Incoming ---
[   'cv.dnn.readNetFromDarknet',
    'Net',
    [],
    [   ['const char *', 'bufferCfg', '', []],
        ['size_t', 'lenCfg', '', []],
        ['const char *', 'bufferModel', 'NULL', []],
        ['size_t', 'lenModel', '0', []]],
    None,
    '@brief Reads a network model stored in <a '
    'href="https://pjreddie.com/darknet/">Darknet</a> model files.\n'
    '*  @param bufferCfg   A buffer contains a content of .cfg file with text '
    'description of the network architecture.\n'
    '*  @param lenCfg      Number of bytes to read from bufferCfg\n'
    '*  @param bufferModel A buffer contains a content of .weights file with '
    'learned network.\n'
    '*  @param lenModel    Number of bytes to read from bufferModel\n'
    '*  @returns Net object.']
parse_name: cv.dnn.readNetFromDarknet with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromDarknet namespace:cv::dnn classpath: classname: name:readNetFromDarknet
register (function) readNetFromDarknet (cv_dnn_readNetFromDarknet_const_char_X_size_t_const_char_X_size_t)

--- Incoming ---
[   'cv.dnn.readNetFromCaffe',
    'Net',
    [],
    [   ['const String &', 'prototxt', '', []],
        ['const String &', 'caffeModel', 'String()', []]],
    None,
    '@brief Reads a network model stored in <a '
    'href="http://caffe.berkeleyvision.org">Caffe</a> framework\'s format.\n'
    '* @param prototxt   path to the .prototxt file with text description of '
    'the network architecture.\n'
    '* @param caffeModel path to the .caffemodel file with learned network.\n'
    '* @returns Net object.']
parse_name: cv.dnn.readNetFromCaffe with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromCaffe namespace:cv::dnn classpath: classname: name:readNetFromCaffe
register (function) readNetFromCaffe (cv_dnn_readNetFromCaffe_String_String)

--- Incoming ---
[   'cv.dnn.readNetFromCaffe',
    'Net',
    [],
    [   ['const std::vector<uchar>&', 'bufferProto', '', []],
        [   'const std::vector<uchar>&',
            'bufferModel',
            'std::vector<uchar>()',
            []]],
    None,
    '@brief Reads a network model stored in Caffe model in memory.\n'
    '* @param bufferProto buffer containing the content of the .prototxt file\n'
    '* @param bufferModel buffer containing the content of the .caffemodel '
    'file\n'
    '* @returns Net object.']
parse_name: cv.dnn.readNetFromCaffe with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromCaffe namespace:cv::dnn classpath: classname: name:readNetFromCaffe
register (function) readNetFromCaffe (cv_dnn_readNetFromCaffe_VectorOfuchar_VectorOfuchar)

--- Incoming ---
[   'cv.dnn.readNetFromCaffe',
    'Net',
    [],
    [   ['const char *', 'bufferProto', '', []],
        ['size_t', 'lenProto', '', []],
        ['const char *', 'bufferModel', 'NULL', []],
        ['size_t', 'lenModel', '0', []]],
    None,
    '@brief Reads a network model stored in Caffe model in memory.\n'
    '* @details This is an overloaded member function, provided for '
    'convenience.\n'
    '* It differs from the above function only in what argument(s) it '
    'accepts.\n'
    '* @param bufferProto buffer containing the content of the .prototxt file\n'
    '* @param lenProto length of bufferProto\n'
    '* @param bufferModel buffer containing the content of the .caffemodel '
    'file\n'
    '* @param lenModel length of bufferModel\n'
    '* @returns Net object.']
parse_name: cv.dnn.readNetFromCaffe with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromCaffe namespace:cv::dnn classpath: classname: name:readNetFromCaffe
register (function) readNetFromCaffe (cv_dnn_readNetFromCaffe_const_char_X_size_t_const_char_X_size_t)

--- Incoming ---
[   'cv.dnn.readNetFromTensorflow',
    'Net',
    [],
    [   ['const String &', 'model', '', []],
        ['const String &', 'config', 'String()', []]],
    None,
    '@brief Reads a network model stored in <a '
    'href="https://www.tensorflow.org/">TensorFlow</a> framework\'s format.\n'
    '* @param model  path to the .pb file with binary protobuf description of '
    'the network architecture\n'
    '* @param config path to the .pbtxt file that contains text graph '
    'definition in protobuf format.\n'
    '*               Resulting Net object is built by text graph using weights '
    'from a binary one that\n'
    '*               let us make it more flexible.\n'
    '* @returns Net object.']
parse_name: cv.dnn.readNetFromTensorflow with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromTensorflow namespace:cv::dnn classpath: classname: name:readNetFromTensorflow
register (function) readNetFromTensorflow (cv_dnn_readNetFromTensorflow_String_String)

--- Incoming ---
[   'cv.dnn.readNetFromTensorflow',
    'Net',
    [],
    [   ['const std::vector<uchar>&', 'bufferModel', '', []],
        [   'const std::vector<uchar>&',
            'bufferConfig',
            'std::vector<uchar>()',
            []]],
    None,
    '@brief Reads a network model stored in <a '
    'href="https://www.tensorflow.org/">TensorFlow</a> framework\'s format.\n'
    '* @param bufferModel buffer containing the content of the pb file\n'
    '* @param bufferConfig buffer containing the content of the pbtxt file\n'
    '* @returns Net object.']
parse_name: cv.dnn.readNetFromTensorflow with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromTensorflow namespace:cv::dnn classpath: classname: name:readNetFromTensorflow
register (function) readNetFromTensorflow (cv_dnn_readNetFromTensorflow_VectorOfuchar_VectorOfuchar)

--- Incoming ---
[   'cv.dnn.readNetFromTensorflow',
    'Net',
    [],
    [   ['const char *', 'bufferModel', '', []],
        ['size_t', 'lenModel', '', []],
        ['const char *', 'bufferConfig', 'NULL', []],
        ['size_t', 'lenConfig', '0', []]],
    None,
    '@brief Reads a network model stored in <a '
    'href="https://www.tensorflow.org/">TensorFlow</a> framework\'s format.\n'
    '* @details This is an overloaded member function, provided for '
    'convenience.\n'
    '* It differs from the above function only in what argument(s) it '
    'accepts.\n'
    '* @param bufferModel buffer containing the content of the pb file\n'
    '* @param lenModel length of bufferModel\n'
    '* @param bufferConfig buffer containing the content of the pbtxt file\n'
    '* @param lenConfig length of bufferConfig']
parse_name: cv.dnn.readNetFromTensorflow with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromTensorflow namespace:cv::dnn classpath: classname: name:readNetFromTensorflow
register (function) readNetFromTensorflow (cv_dnn_readNetFromTensorflow_const_char_X_size_t_const_char_X_size_t)

--- Incoming ---
[   'cv.dnn.readNetFromTorch',
    'Net',
    [],
    [   ['const String &', 'model', '', []],
        ['bool', 'isBinary', 'true', []],
        ['bool', 'evaluate', 'true', []]],
    None,
    '*  @brief Reads a network model stored in <a '
    'href="http://torch.ch">Torch7</a> framework\'s format.\n'
    '*  @param model    path to the file, dumped from Torch by using '
    'torch.save() function.\n'
    '*  @param isBinary specifies whether the network was serialized in ascii '
    'mode or binary.\n'
    "*  @param evaluate specifies testing phase of network. If true, it's "
    'similar to evaluate() method in Torch.\n'
    '*  @returns Net object.\n'
    '*\n'
    '*  @note Ascii mode of Torch serializer is more preferable, because '
    'binary mode extensively use `long` type of C language,\n'
    '*  which has various bit-length on different systems.\n'
    '*\n'
    '* The loading file must contain serialized <a '
    'href="https://github.com/torch/nn/blob/master/doc/module.md">nn.Module</a> '
    'object\n'
    '* with importing network. Try to eliminate a custom objects from '
    'serialazing data to avoid importing errors.\n'
    '*\n'
    '* List of supported layers (i.e. object instances derived from Torch '
    'nn.Module class):\n'
    '* - nn.Sequential\n'
    '* - nn.Parallel\n'
    '* - nn.Concat\n'
    '* - nn.Linear\n'
    '* - nn.SpatialConvolution\n'
    '* - nn.SpatialMaxPooling, nn.SpatialAveragePooling\n'
    '* - nn.ReLU, nn.TanH, nn.Sigmoid\n'
    '* - nn.Reshape\n'
    '* - nn.SoftMax, nn.LogSoftMax\n'
    '*\n'
    '* Also some equivalents of these classes from cunn, cudnn, and fbcunn may '
    'be successfully imported.']
parse_name: cv.dnn.readNetFromTorch with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromTorch namespace:cv::dnn classpath: classname: name:readNetFromTorch
register (function) readNetFromTorch (cv_dnn_readNetFromTorch_String_bool_bool)

--- Incoming ---
[   'cv.dnn.readNet',
    'Net',
    [],
    [   ['const String&', 'model', '', []],
        ['const String&', 'config', '""', []],
        ['const String&', 'framework', '""', []]],
    None,
    '* @brief Read deep learning network represented in one of the supported '
    'formats.\n'
    '* @param[in] model Binary file contains trained weights. The following '
    'file\n'
    '*                  extensions are expected for models from different '
    'frameworks:\n'
    '*                  * `*.caffemodel` (Caffe, '
    'http://caffe.berkeleyvision.org/)\n'
    '*                  * `*.pb` (TensorFlow, https://www.tensorflow.org/)\n'
    '*                  * `*.t7` | `*.net` (Torch, http://torch.ch/)\n'
    '*                  * `*.weights` (Darknet, '
    'https://pjreddie.com/darknet/)\n'
    '*                  * `*.bin` (DLDT, '
    'https://software.intel.com/openvino-toolkit)\n'
    '*                  * `*.onnx` (ONNX, https://onnx.ai/)\n'
    '* @param[in] config Text file contains network configuration. It could be '
    'a\n'
    '*                   file with the following extensions:\n'
    '*                  * `*.prototxt` (Caffe, '
    'http://caffe.berkeleyvision.org/)\n'
    '*                  * `*.pbtxt` (TensorFlow, https://www.tensorflow.org/)\n'
    '*                  * `*.cfg` (Darknet, https://pjreddie.com/darknet/)\n'
    '*                  * `*.xml` (DLDT, '
    'https://software.intel.com/openvino-toolkit)\n'
    '* @param[in] framework Explicit framework name tag to determine a '
    'format.\n'
    '* @returns Net object.\n'
    '*\n'
    '* This function automatically detects an origin framework of trained '
    'model\n'
    '* and calls an appropriate function such @ref readNetFromCaffe, @ref '
    'readNetFromTensorflow,\n'
    '* @ref readNetFromTorch or @ref readNetFromDarknet. An order of @p model '
    'and @p config\n'
    '* arguments does not matter.']
parse_name: cv.dnn.readNet with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNet namespace:cv::dnn classpath: classname: name:readNet
register (function) readNet (cv_dnn_readNet_String_String_String)

--- Incoming ---
[   'cv.dnn.readNet',
    'Net',
    [],
    [   ['const String&', 'framework', '', []],
        ['const std::vector<uchar>&', 'bufferModel', '', []],
        [   'const std::vector<uchar>&',
            'bufferConfig',
            'std::vector<uchar>()',
            []]],
    None,
    '* @brief Read deep learning network represented in one of the supported '
    'formats.\n'
    '* @details This is an overloaded member function, provided for '
    'convenience.\n'
    '*          It differs from the above function only in what argument(s) it '
    'accepts.\n'
    '* @param[in] framework    Name of origin framework.\n'
    '* @param[in] bufferModel  A buffer with a content of binary file with '
    'weights\n'
    '* @param[in] bufferConfig A buffer with a content of text file contains '
    'network configuration.\n'
    '* @returns Net object.']
parse_name: cv.dnn.readNet with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNet namespace:cv::dnn classpath: classname: name:readNet
register (function) readNet (cv_dnn_readNet_String_VectorOfuchar_VectorOfuchar)

--- Incoming ---
[   'cv.dnn.readTorchBlob',
    'Mat',
    [],
    [['const String &', 'filename', '', []], ['bool', 'isBinary', 'true', []]],
    None,
    '@brief Loads blob which was serialized as torch.Tensor object of Torch7 '
    'framework.\n'
    '*  @warning This function has the same limitations as readNetFromTorch().']
parse_name: cv.dnn.readTorchBlob with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readTorchBlob namespace:cv::dnn classpath: classname: name:readTorchBlob
register (function) readTorchBlob (cv_dnn_readTorchBlob_String_bool)

--- Incoming ---
[   'cv.dnn.readNetFromModelOptimizer',
    'Net',
    [],
    [['const String &', 'xml', '', []], ['const String &', 'bin', '', []]],
    None,
    "@brief Load a network from Intel's Model Optimizer intermediate "
    'representation.\n'
    "*  @param[in] xml XML configuration file with network's topology.\n"
    '*  @param[in] bin Binary file with trained weights.\n'
    '*  @returns Net object.\n'
    "*  Networks imported from Intel's Model Optimizer are launched in Intel's "
    'Inference Engine\n'
    '*  backend.']
parse_name: cv.dnn.readNetFromModelOptimizer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromModelOptimizer namespace:cv::dnn classpath: classname: name:readNetFromModelOptimizer
register (function) readNetFromModelOptimizer (cv_dnn_readNetFromModelOptimizer_String_String)

--- Incoming ---
[   'cv.dnn.readNetFromONNX',
    'Net',
    [],
    [['const String &', 'onnxFile', '', []]],
    None,
    '@brief Reads a network model <a href="https://onnx.ai/">ONNX</a>.\n'
    '*  @param onnxFile path to the .onnx file with text description of the '
    'network architecture.\n'
    '*  @returns Network object that ready to do forward, throw an exception '
    'in failure cases.']
parse_name: cv.dnn.readNetFromONNX with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromONNX namespace:cv::dnn classpath: classname: name:readNetFromONNX
register (function) readNetFromONNX (cv_dnn_readNetFromONNX_String)

--- Incoming ---
[   'cv.dnn.readNetFromONNX',
    'Net',
    [],
    [['const char*', 'buffer', '', []], ['size_t', 'sizeBuffer', '', []]],
    None,
    '@brief Reads a network model from <a href="https://onnx.ai/">ONNX</a>\n'
    '*         in-memory buffer.\n'
    '*  @param buffer memory address of the first byte of the buffer.\n'
    '*  @param sizeBuffer size of the buffer.\n'
    '*  @returns Network object that ready to do forward, throw an exception\n'
    '*        in failure cases.']
parse_name: cv.dnn.readNetFromONNX with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromONNX namespace:cv::dnn classpath: classname: name:readNetFromONNX
register (function) readNetFromONNX (cv_dnn_readNetFromONNX_const_char_X_size_t)

--- Incoming ---
[   'cv.dnn.readNetFromONNX',
    'Net',
    [],
    [['const std::vector<uchar>&', 'buffer', '', []]],
    None,
    '@brief Reads a network model from <a href="https://onnx.ai/">ONNX</a>\n'
    '*         in-memory buffer.\n'
    '*  @param buffer in-memory buffer that stores the ONNX model bytes.\n'
    '*  @returns Network object that ready to do forward, throw an exception\n'
    '*        in failure cases.']
parse_name: cv.dnn.readNetFromONNX with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readNetFromONNX namespace:cv::dnn classpath: classname: name:readNetFromONNX
register (function) readNetFromONNX (cv_dnn_readNetFromONNX_VectorOfuchar)

--- Incoming ---
[   'cv.dnn.readTensorFromONNX',
    'Mat',
    [],
    [['const String&', 'path', '', []]],
    None,
    '@brief Creates blob from .pb file.\n'
    '*  @param path to the .pb file with input tensor.\n'
    '*  @returns Mat.']
parse_name: cv.dnn.readTensorFromONNX with ['cv', 'cv::dnn'] -> fullname:cv::dnn::readTensorFromONNX namespace:cv::dnn classpath: classname: name:readTensorFromONNX
register (function) readTensorFromONNX (cv_dnn_readTensorFromONNX_String)

--- Incoming ---
[   'cv.dnn.blobFromImage',
    'Mat',
    [],
    [   ['InputArray', 'image', '', []],
        ['double', 'scalefactor', '1.0', []],
        ['const Size&', 'size', 'Size()', []],
        ['const Scalar&', 'mean', 'Scalar()', []],
        ['bool', 'swapRB', 'false', []],
        ['bool', 'crop', 'false', []],
        ['int', 'ddepth', 'CV_32F', []]],
    None,
    '@brief Creates 4-dimensional blob from image. Optionally resizes and '
    'crops @p image from center,\n'
    '*  subtract @p mean values, scales values by @p scalefactor, swap Blue '
    'and Red channels.\n'
    '*  @param image input image (with 1-, 3- or 4-channels).\n'
    '*  @param size spatial size for output image\n'
    '*  @param mean scalar with mean values which are subtracted from '
    'channels. Values are intended\n'
    '*  to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering '
    'and @p swapRB is true.\n'
    '*  @param scalefactor multiplier for @p image values.\n'
    '*  @param swapRB flag which indicates that swap first and last channels\n'
    '*  in 3-channel image is necessary.\n'
    '*  @param crop flag which indicates whether image will be cropped after '
    'resize or not\n'
    '*  @param ddepth Depth of output blob. Choose CV_32F or CV_8U.\n'
    '*  @details if @p crop is true, input image is resized so one side after '
    'resize is equal to corresponding\n'
    '*  dimension in @p size and another one is equal or larger. Then, crop '
    'from the center is performed.\n'
    '*  If @p crop is false, direct resize without cropping and preserving '
    'aspect ratio is performed.\n'
    '*  @returns 4-dimensional Mat with NCHW dimensions order.']
parse_name: cv.dnn.blobFromImage with ['cv', 'cv::dnn'] -> fullname:cv::dnn::blobFromImage namespace:cv::dnn classpath: classname: name:blobFromImage
register (function) blobFromImage (cv_dnn_blobFromImage__InputArray_double_Size_Scalar_bool_bool_int)

--- Incoming ---
[   'cv.dnn.blobFromImage',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'blob', '', []],
        ['double', 'scalefactor', '1.0', []],
        ['const Size&', 'size', 'Size()', []],
        ['const Scalar&', 'mean', 'Scalar()', []],
        ['bool', 'swapRB', 'false', []],
        ['bool', 'crop', 'false', []],
        ['int', 'ddepth', 'CV_32F', []]],
    None,
    '@brief Creates 4-dimensional blob from image.\n'
    '*  @details This is an overloaded member function, provided for '
    'convenience.\n'
    '*           It differs from the above function only in what argument(s) '
    'it accepts.']
parse_name: cv.dnn.blobFromImage with ['cv', 'cv::dnn'] -> fullname:cv::dnn::blobFromImage namespace:cv::dnn classpath: classname: name:blobFromImage
register (function) blobFromImage (cv_dnn_blobFromImage__InputArray__OutputArray_double_Size_Scalar_bool_bool_int)

--- Incoming ---
[   'cv.dnn.blobFromImages',
    'Mat',
    [],
    [   ['InputArrayOfArrays', 'images', '', []],
        ['double', 'scalefactor', '1.0', []],
        ['Size', 'size', 'Size()', []],
        ['const Scalar&', 'mean', 'Scalar()', []],
        ['bool', 'swapRB', 'false', []],
        ['bool', 'crop', 'false', []],
        ['int', 'ddepth', 'CV_32F', []]],
    None,
    '@brief Creates 4-dimensional blob from series of images. Optionally '
    'resizes and\n'
    '*  crops @p images from center, subtract @p mean values, scales values by '
    '@p scalefactor,\n'
    '*  swap Blue and Red channels.\n'
    '*  @param images input images (all with 1-, 3- or 4-channels).\n'
    '*  @param size spatial size for output image\n'
    '*  @param mean scalar with mean values which are subtracted from '
    'channels. Values are intended\n'
    '*  to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering '
    'and @p swapRB is true.\n'
    '*  @param scalefactor multiplier for @p images values.\n'
    '*  @param swapRB flag which indicates that swap first and last channels\n'
    '*  in 3-channel image is necessary.\n'
    '*  @param crop flag which indicates whether image will be cropped after '
    'resize or not\n'
    '*  @param ddepth Depth of output blob. Choose CV_32F or CV_8U.\n'
    '*  @details if @p crop is true, input image is resized so one side after '
    'resize is equal to corresponding\n'
    '*  dimension in @p size and another one is equal or larger. Then, crop '
    'from the center is performed.\n'
    '*  If @p crop is false, direct resize without cropping and preserving '
    'aspect ratio is performed.\n'
    '*  @returns 4-dimensional Mat with NCHW dimensions order.']
parse_name: cv.dnn.blobFromImages with ['cv', 'cv::dnn'] -> fullname:cv::dnn::blobFromImages namespace:cv::dnn classpath: classname: name:blobFromImages
register (function) blobFromImages (cv_dnn_blobFromImages__InputArray_double_Size_Scalar_bool_bool_int)

--- Incoming ---
[   'cv.dnn.blobFromImages',
    'void',
    [],
    [   ['InputArrayOfArrays', 'images', '', []],
        ['OutputArray', 'blob', '', []],
        ['double', 'scalefactor', '1.0', []],
        ['Size', 'size', 'Size()', []],
        ['const Scalar&', 'mean', 'Scalar()', []],
        ['bool', 'swapRB', 'false', []],
        ['bool', 'crop', 'false', []],
        ['int', 'ddepth', 'CV_32F', []]],
    None,
    '@brief Creates 4-dimensional blob from series of images.\n'
    '*  @details This is an overloaded member function, provided for '
    'convenience.\n'
    '*           It differs from the above function only in what argument(s) '
    'it accepts.']
parse_name: cv.dnn.blobFromImages with ['cv', 'cv::dnn'] -> fullname:cv::dnn::blobFromImages namespace:cv::dnn classpath: classname: name:blobFromImages
register (function) blobFromImages (cv_dnn_blobFromImages__InputArray__OutputArray_double_Size_Scalar_bool_bool_int)

--- Incoming ---
[   'cv.dnn.imagesFromBlob',
    'void',
    [],
    [   ['const cv::Mat&', 'blob_', '', []],
        ['OutputArrayOfArrays', 'images_', '', []]],
    None,
    '@brief Parse a 4D blob and output the images it contains as 2D arrays '
    'through a simpler data structure\n'
    '*  (std::vector<cv::Mat>).\n'
    '*  @param[in] blob_ 4 dimensional array (images, channels, height, width) '
    'in floating point precision (CV_32F) from\n'
    '*  which you would like to extract the images.\n'
    '*  @param[out] images_ array of 2D Mat containing the images extracted '
    'from the blob in floating point precision\n'
    '*  (CV_32F). They are non normalized neither mean added. The number of '
    'returned images equals the first dimension\n'
    '*  of the blob (batch size). Every image has a number of channels equals '
    'to the second dimension of the blob (depth).']
parse_name: cv.dnn.imagesFromBlob with ['cv', 'cv::dnn'] -> fullname:cv::dnn::imagesFromBlob namespace:cv::dnn classpath: classname: name:imagesFromBlob
register (function) imagesFromBlob (cv_dnn_imagesFromBlob_Mat__OutputArray)

--- Incoming ---
[   'cv.dnn.shrinkCaffeModel',
    'void',
    [],
    [   ['const String&', 'src', '', []],
        ['const String&', 'dst', '', []],
        [   'const std::vector<String>&',
            'layersTypes',
            'std::vector<String>()',
            []]],
    None,
    '@brief Convert all weights of Caffe network to half precision floating '
    'point.\n'
    '* @param src Path to origin model from Caffe framework contains single\n'
    '*            precision floating point weights (usually has `.caffemodel` '
    'extension).\n'
    '* @param dst Path to destination model with updated weights.\n'
    '* @param layersTypes Set of layers types which parameters will be '
    'converted.\n'
    '*                    By default, converts only Convolutional and '
    "Fully-Connected layers'\n"
    '*                    weights.\n'
    '*\n'
    "* @note Shrinked model has no origin float32 weights so it can't be used\n"
    '*       in origin Caffe framework anymore. However the structure of data\n'
    "*       is taken from NVidia's Caffe fork: "
    'https://github.com/NVIDIA/caffe.\n'
    '*       So the resulting model may be used there.']
parse_name: cv.dnn.shrinkCaffeModel with ['cv', 'cv::dnn'] -> fullname:cv::dnn::shrinkCaffeModel namespace:cv::dnn classpath: classname: name:shrinkCaffeModel
register (function) shrinkCaffeModel (cv_dnn_shrinkCaffeModel_String_String_VectorOfString)

--- Incoming ---
[   'cv.dnn.writeTextGraph',
    'void',
    [],
    [['const String&', 'model', '', []], ['const String&', 'output', '', []]],
    None,
    '@brief Create a text representation for a binary network stored in '
    'protocol buffer format.\n'
    '*  @param[in] model  A path to binary network.\n'
    '*  @param[in] output A path to output text file to be created.\n'
    '*\n'
    '*  @note To reduce output file size, trained weights are not included.']
parse_name: cv.dnn.writeTextGraph with ['cv', 'cv::dnn'] -> fullname:cv::dnn::writeTextGraph namespace:cv::dnn classpath: classname: name:writeTextGraph
register (function) writeTextGraph (cv_dnn_writeTextGraph_String_String)

--- Incoming ---
[   'cv.dnn.NMSBoxes',
    'void',
    [],
    [   ['const std::vector<Rect>&', 'bboxes', '', []],
        ['const std::vector<float>&', 'scores', '', []],
        ['const float', 'score_threshold', '', []],
        ['const float', 'nms_threshold', '', []],
        ['std::vector<int>&', 'indices', '', []],
        ['const float', 'eta', '1.f', []],
        ['const int', 'top_k', '0', []]],
    None,
    '@brief Performs non maximum suppression given boxes and corresponding '
    'scores.\n'
    '\n'
    '* @param bboxes a set of bounding boxes to apply NMS.\n'
    '* @param scores a set of corresponding confidences.\n'
    '* @param score_threshold a threshold used to filter boxes by score.\n'
    '* @param nms_threshold a threshold used in non maximum suppression.\n'
    '* @param indices the kept indices of bboxes after NMS.\n'
    '* @param eta a coefficient in adaptive threshold formula: '
    '\\f$nms\\_threshold_{i+1}=eta\\cdot nms\\_threshold_i\\f$.\n'
    '* @param top_k if `>0`, keep at most @p top_k picked indices.']
parse_name: cv.dnn.NMSBoxes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::NMSBoxes namespace:cv::dnn classpath: classname: name:NMSBoxes
register (function) NMSBoxes (cv_dnn_NMSBoxes_VectorOfRect_VectorOffloat_float_float_VectorOfint_float_int)

--- Incoming ---
[   'cv.dnn.NMSBoxes',
    'void',
    [],
    [   ['const std::vector<Rect2d>&', 'bboxes', '', []],
        ['const std::vector<float>&', 'scores', '', []],
        ['const float', 'score_threshold', '', []],
        ['const float', 'nms_threshold', '', []],
        ['std::vector<int>&', 'indices', '', []],
        ['const float', 'eta', '1.f', []],
        ['const int', 'top_k', '0', []]],
    None,
    '']
parse_name: cv.dnn.NMSBoxes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::NMSBoxes namespace:cv::dnn classpath: classname: name:NMSBoxes
register (function) NMSBoxes (cv_dnn_NMSBoxes_VectorOfRect2d_VectorOffloat_float_float_VectorOfint_float_int)

--- Incoming ---
[   'cv.dnn.NMSBoxes',
    'void',
    [],
    [   ['const std::vector<RotatedRect>&', 'bboxes', '', []],
        ['const std::vector<float>&', 'scores', '', []],
        ['const float', 'score_threshold', '', []],
        ['const float', 'nms_threshold', '', []],
        ['std::vector<int>&', 'indices', '', []],
        ['const float', 'eta', '1.f', []],
        ['const int', 'top_k', '0', []]],
    None,
    '']
parse_name: cv.dnn.NMSBoxes with ['cv', 'cv::dnn'] -> fullname:cv::dnn::NMSBoxes namespace:cv::dnn classpath: classname: name:NMSBoxes
register (function) NMSBoxes (cv_dnn_NMSBoxes_VectorOfRotatedRect_VectorOffloat_float_float_VectorOfint_float_int)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn/layer.hpp ================


Namespaces: ['cv', 'cv.dnn']
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n', 'dnnLayerList': ' @defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))\n\n'}

--- Incoming ---
[   'class cv.dnn.LayerFactory',
    '',
    [],
    [],
    None,
    '@brief %Layer factory allows to create instances of registered layers.']
parse_name: class cv.dnn.LayerFactory with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerFactory namespace:cv::dnn classpath: classname: name:LayerFactory
register class cv::dnn::LayerFactory (['class cv.dnn.LayerFactory', '', [], [], None, '@brief %Layer factory allows to create instances of registered layers.'])

--- Incoming ---
[   'callback cv.dnn.LayerFactory.Constructor',
    'Ptr<Layer>',
    '',
    [['LayerParams &params', '']],
    None,
    'Each Layer class must provide this function to the factory']
parse_name: callback cv.dnn.LayerFactory.Constructor with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerFactory::Constructor namespace:cv::dnn classpath:LayerFactory classname:LayerFactory name:Constructor
Registering an unknown type: LayerParams &params

--- Incoming ---
[   'cv.dnn.LayerFactory.registerLayer',
    'void',
    ['/S'],
    [   ['const String &', 'type', '', []],
        ['Constructor', 'constructor', '', []]],
    None,
    'Registers the layer class with typename @p type and specified @p '
    'constructor. Thread-safe.']
parse_name: cv.dnn.LayerFactory.registerLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerFactory::registerLayer namespace:cv::dnn classpath:LayerFactory classname:LayerFactory name:registerLayer
Registering an unknown type: Constructor
register (method) registerLayer in cv::dnn::LayerFactory (cv_dnn_LayerFactory_registerLayer_String_Constructor)

--- Incoming ---
[   'cv.dnn.LayerFactory.unregisterLayer',
    'void',
    ['/S'],
    [['const String &', 'type', '', []]],
    None,
    'Unregisters registered layer with specified type name. Thread-safe.']
parse_name: cv.dnn.LayerFactory.unregisterLayer with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerFactory::unregisterLayer namespace:cv::dnn classpath:LayerFactory classname:LayerFactory name:unregisterLayer
register (method) unregisterLayer in cv::dnn::LayerFactory (cv_dnn_LayerFactory_unregisterLayer_String)

--- Incoming ---
[   'cv.dnn.LayerFactory.createLayerInstance',
    'Ptr<Layer>',
    ['/S'],
    [['const String &', 'type', '', []], ['LayerParams&', 'params', '', []]],
    None,
    '@brief Creates instance of registered layer.\n'
    '*  @param type type name of creating layer.\n'
    '*  @param params parameters which will be used for layer initialization.\n'
    '*  @note Thread-safe.']
parse_name: cv.dnn.LayerFactory.createLayerInstance with ['cv', 'cv::dnn'] -> fullname:cv::dnn::LayerFactory::createLayerInstance namespace:cv::dnn classpath:LayerFactory classname:LayerFactory name:createLayerInstance
register (method) createLayerInstance in cv::dnn::LayerFactory (cv_dnn_LayerFactory_createLayerInstance_String_LayerParams)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn/shape_utils.hpp ================


Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>']
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n', 'dnnLayerList': ' @defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))\n\n'}

--- Incoming ---
['struct cv.dnn._Range', ': cv::Range', [], [], None, '']
parse_name: struct cv.dnn._Range with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::_Range namespace:cv::dnn classpath: classname: name:_Range
register class cv::dnn::_Range (['struct cv.dnn._Range', ': cv::Range', [], [], None, '']) [ignored] impl:cv::Range

--- Incoming ---
[   'cv.dnn._Range._Range',
    '_',
    [],
    [['const Range &r) : cv::Range(', 'r', '', []]],
    None,
    '']
parse_name: cv.dnn._Range._Range with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::_Range::_Range namespace:cv::dnn classpath:_Range classname:_Range name:_Range
Registering an unknown type: Range &r) : cv::Range(
register (constructor) new in cv::dnn::_Range (ignored) (cv_dnn__Range__Range_Range &r) : cv_Range()

--- Incoming ---
[   'cv.dnn._Range._Range',
    '_',
    [],
    [   ['int', 'start_', '', []],
        ['int', 'size_', '1) : cv::Range(start_', []],
        ['start_ +', 'size_', '', []]],
    None,
    '']
parse_name: cv.dnn._Range._Range with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::_Range::_Range namespace:cv::dnn classpath:_Range classname:_Range name:_Range
Registering an unknown type: start_ +
register (constructor) new in cv::dnn::_Range (ignored) (cv_dnn__Range__Range_int_int_start_ +)

--- Incoming ---
[   'cv.dnn.slice',
    'Mat',
    [],
    [['const Mat &', 'm', '', []], ['const _Range &', 'r0', '', []]],
    None,
    '']
parse_name: cv.dnn.slice with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::slice namespace:cv::dnn classpath: classname: name:slice
register (function) slice (cv_dnn_slice_Mat_Range)

--- Incoming ---
[   'cv.dnn.slice',
    'Mat',
    [],
    [   ['const Mat &', 'm', '', []],
        ['const _Range &', 'r0', '', []],
        ['const _Range &', 'r1', '', []]],
    None,
    '']
parse_name: cv.dnn.slice with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::slice namespace:cv::dnn classpath: classname: name:slice
register (function) slice (cv_dnn_slice_Mat_Range_Range)

--- Incoming ---
[   'cv.dnn.slice',
    'Mat',
    [],
    [   ['const Mat &', 'm', '', []],
        ['const _Range &', 'r0', '', []],
        ['const _Range &', 'r1', '', []],
        ['const _Range &', 'r2', '', []]],
    None,
    '']
parse_name: cv.dnn.slice with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::slice namespace:cv::dnn classpath: classname: name:slice
register (function) slice (cv_dnn_slice_Mat_Range_Range_Range)

--- Incoming ---
[   'cv.dnn.slice',
    'Mat',
    [],
    [   ['const Mat &', 'm', '', []],
        ['const _Range &', 'r0', '', []],
        ['const _Range &', 'r1', '', []],
        ['const _Range &', 'r2', '', []],
        ['const _Range &', 'r3', '', []]],
    None,
    '']
parse_name: cv.dnn.slice with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::slice namespace:cv::dnn classpath: classname: name:slice
register (function) slice (cv_dnn_slice_Mat_Range_Range_Range_Range)

--- Incoming ---
[   'cv.dnn.getPlane',
    'Mat',
    [],
    [['const Mat &', 'm', '', []], ['int', 'n', '', []], ['int', 'cn', '', []]],
    None,
    '']
parse_name: cv.dnn.getPlane with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::getPlane namespace:cv::dnn classpath: classname: name:getPlane
register (function) getPlane (cv_dnn_getPlane_Mat_int_int)

--- Incoming ---
[   'cv.dnn.shape',
    'MatShape',
    [],
    [['const int*', 'dims', '', []], ['const int', 'n', '', []]],
    None,
    '']
parse_name: cv.dnn.shape with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::shape namespace:cv::dnn classpath: classname: name:shape
register (function) shape (cv_dnn_shape_const_int_X_int)

--- Incoming ---
['cv.dnn.shape', 'MatShape', [], [['const Mat&', 'mat', '', []]], None, '']
parse_name: cv.dnn.shape with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::shape namespace:cv::dnn classpath: classname: name:shape
register (function) shape (cv_dnn_shape_Mat)

--- Incoming ---
['cv.dnn.shape', 'MatShape', [], [['const MatSize&', 'sz', '', []]], None, '']
parse_name: cv.dnn.shape with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::shape namespace:cv::dnn classpath: classname: name:shape
Registering an unknown type: MatSize
register (function) shape (cv_dnn_shape_MatSize)

--- Incoming ---
['cv.dnn.shape', 'MatShape', [], [['const UMat&', 'mat', '', []]], None, '']
parse_name: cv.dnn.shape with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::shape namespace:cv::dnn classpath: classname: name:shape
register (function) shape (cv_dnn_shape_UMat)

--- Incoming ---
['cv.dnn.<unnamed>.is_neg', 'bool', [], [['int', 'i', '', []]], None, '']
parse_name: cv.dnn.<unnamed>.is_neg with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::<unnamed>::is_neg namespace:cv::dnn::<unnamed> classpath: classname: name:is_neg
register (function) is_neg (cv_dnn_<unnamed>_is_neg_int)

--- Incoming ---
[   'cv.dnn.shape',
    'MatShape',
    [],
    [   ['int', 'a0', '', []],
        ['int', 'a1', '-1', []],
        ['int', 'a2', '-1', []],
        ['int', 'a3', '-1', []]],
    None,
    '']
parse_name: cv.dnn.shape with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::shape namespace:cv::dnn classpath: classname: name:shape
register (function) shape (cv_dnn_shape_int_int_int_int)

--- Incoming ---
[   'cv.dnn.total',
    'int',
    [],
    [   ['const MatShape&', 'shape', '', []],
        ['int', 'start', '-1', []],
        ['int', 'end', '-1', []]],
    None,
    '']
parse_name: cv.dnn.total with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::total namespace:cv::dnn classpath: classname: name:total
register (function) total (cv_dnn_total_MatShape_int_int)

--- Incoming ---
[   'cv.dnn.concat',
    'MatShape',
    [],
    [['const MatShape&', 'a', '', []], ['const MatShape&', 'b', '', []]],
    None,
    '']
parse_name: cv.dnn.concat with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::concat namespace:cv::dnn classpath: classname: name:concat
register (function) concat (cv_dnn_concat_MatShape_MatShape)

--- Incoming ---
[   'cv.dnn.toString',
    'std::string',
    [],
    [['const MatShape&', 'shape', '', []], ['const String&', 'name', '""', []]],
    None,
    '']
parse_name: cv.dnn.toString with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::toString namespace:cv::dnn classpath: classname: name:toString
register (function) toString (cv_dnn_toString_MatShape_String)

--- Incoming ---
[   'cv.dnn.print',
    'void',
    [],
    [['const MatShape&', 'shape', '', []], ['const String&', 'name', '""', []]],
    None,
    '']
parse_name: cv.dnn.print with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::print namespace:cv::dnn classpath: classname: name:print
register (function) print (cv_dnn_print_MatShape_String)

--- Incoming ---
[   'cv.dnn.operator <<',
    'std::ostream&',
    [],
    [['std::ostream &', 'out', '', []], ['const MatShape&', 'shape', '', []]],
    None,
    '']
parse_name: cv.dnn.operator << with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::operator << namespace:cv::dnn classpath: classname: name:operator <<
Registering an unknown type: std::ostream
ignore (function) operator << in None

--- Incoming ---
[   'cv.dnn.clamp',
    'int',
    [],
    [['int', 'ax', '', []], ['int', 'dims', '', []]],
    None,
    '']
parse_name: cv.dnn.clamp with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::clamp namespace:cv::dnn classpath: classname: name:clamp
register (function) clamp (cv_dnn_clamp_int_int)

--- Incoming ---
[   'cv.dnn.clamp',
    'int',
    [],
    [['int', 'ax', '', []], ['const MatShape&', 'shape', '', []]],
    None,
    '']
parse_name: cv.dnn.clamp with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::clamp namespace:cv::dnn classpath: classname: name:clamp
register (function) clamp (cv_dnn_clamp_int_MatShape)

--- Incoming ---
[   'cv.dnn.clamp',
    'Range',
    [],
    [['const Range&', 'r', '', []], ['int', 'axisSize', '', []]],
    None,
    '']
parse_name: cv.dnn.clamp with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::clamp namespace:cv::dnn classpath: classname: name:clamp
register (function) clamp (cv_dnn_clamp_Range_int)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn/utils/inference_engine.hpp ================


Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>']
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n', 'dnnLayerList': ' @defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))\n\n'}

--- Incoming ---
[   'cv.dnn.resetMyriadDevice',
    'void',
    [],
    [],
    None,
    '@brief Release a Myriad device (binded by OpenCV).\n'
    '*\n'
    '* Single Myriad device cannot be shared across multiple processes which '
    'uses\n'
    "* Inference Engine's Myriad plugin."]
parse_name: cv.dnn.resetMyriadDevice with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::resetMyriadDevice namespace:cv::dnn classpath: classname: name:resetMyriadDevice
register (function) resetMyriadDevice (cv_dnn_resetMyriadDevice)

--- Incoming ---
['const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_UNSPECIFIED', '""', [], [], '']
parse_name: const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_UNSPECIFIED with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:CV_DNN_INFERENCE_ENGINE_VPU_TYPE_UNSPECIFIED namespace: classpath: classname: name:CV_DNN_INFERENCE_ENGINE_VPU_TYPE_UNSPECIFIED

--- Incoming ---
['const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_2', '"Myriad2"', [], [], '']
parse_name: const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_2 with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_2 namespace: classpath: classname: name:CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_2

--- Incoming ---
['const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_X', '"MyriadX"', [], [], '']
parse_name: const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_X with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_X namespace: classpath: classname: name:CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_X

--- Incoming ---
[   'cv.dnn.getInferenceEngineVPUType',
    'cv::String',
    [],
    [],
    None,
    '@brief Returns Inference Engine VPU type.\n'
    '*\n'
    '* See values of `CV_DNN_INFERENCE_ENGINE_VPU_TYPE_*` macros.']
parse_name: cv.dnn.getInferenceEngineVPUType with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>'] -> fullname:cv::dnn::getInferenceEngineVPUType namespace:cv::dnn classpath: classname: name:getInferenceEngineVPUType
register (function) getInferenceEngineVPUType (cv_dnn_getInferenceEngineVPUType)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/dnn/version.hpp ================


Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>', 'cv.dnn.CV__DNN_INLINE_NS']
Comment: {'dnn': ' @defgroup dnn Deep Neural Network module\n@{\nThis module contains:\n- API for new layers creation, layers are building bricks of neural networks;\n- set of built-in most-useful Layers;\n- API to construct and modify comprehensive neural networks from layers;\n- functionality for loading serialized networks models from different frameworks.\n\nFunctionality of this module is designed only for forward pass computations (i.e. network testing).\nA network training is in principle not supported.\n@}\n\n', 'dnnLayerList': ' @defgroup dnnLayerList Partial List of Implemented Layers\n@{\nThis subsection of dnn module contains information about built-in layers and their descriptions.\n\nClasses listed here, in fact, provides C++ API for creating instances of built-in layers.\nIn addition to this way of layers instantiation, there is a more common factory API (see @ref dnnLayerFactory), it allows to create layers dynamically (by name) and register new ones.\nYou can use both API, but factory API is less convenient for native C++ programming and basically designed for use inside importers (see @ref readNetFromCaffe(), @ref readNetFromTorch(), @ref readNetFromTensorflow()).\n\nBuilt-in layers partially reproduce functionality of corresponding Caffe and Torch7 layers.\nIn particular, the following layers and Caffe importer were tested to reproduce <a href="http://caffe.berkeleyvision.org/tutorial/layers.html">Caffe</a> functionality:\n- Convolution\n- Deconvolution\n- Pooling\n- InnerProduct\n- TanH, ReLU, Sigmoid, BNLL, Power, AbsVal\n- Softmax\n- Reshape, Flatten, Slice, Split\n- LRN\n- MVN\n- Dropout (since it does nothing on forward pass -))\n\n'}

--- Incoming ---
['const OPENCV_DNN_API_VERSION', '20190621', [], [], '']
parse_name: const OPENCV_DNN_API_VERSION with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>', 'cv::dnn::CV__DNN_INLINE_NS'] -> fullname:OPENCV_DNN_API_VERSION namespace: classpath: classname: name:OPENCV_DNN_API_VERSION

--- Incoming ---
[   'const CV__DNN_INLINE_NS',
    '__CV_CAT(dnn4_v, OPENCV_DNN_API_VERSION)',
    [],
    [],
    '']
parse_name: const CV__DNN_INLINE_NS with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>', 'cv::dnn::CV__DNN_INLINE_NS'] -> fullname:CV__DNN_INLINE_NS namespace: classpath: classname: name:CV__DNN_INLINE_NS
ignored: CONST CV__DNN_INLINE_NS=__CV_CAT(dnn4_v, OPENCV_DNN_API_VERSION)

--- Incoming ---
['const CV__DNN_INLINE_NS_BEGIN', 'namespace CV__DNN_INLINE_NS {', [], [], '']
parse_name: const CV__DNN_INLINE_NS_BEGIN with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>', 'cv::dnn::CV__DNN_INLINE_NS'] -> fullname:CV__DNN_INLINE_NS_BEGIN namespace: classpath: classname: name:CV__DNN_INLINE_NS_BEGIN
ignored: CONST CV__DNN_INLINE_NS_BEGIN=namespace CV__DNN_INLINE_NS {

--- Incoming ---
['const CV__DNN_INLINE_NS_END', '}', [], [], '']
parse_name: const CV__DNN_INLINE_NS_END with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>', 'cv::dnn::CV__DNN_INLINE_NS'] -> fullname:CV__DNN_INLINE_NS_END namespace: classpath: classname: name:CV__DNN_INLINE_NS_END
ignored: CONST CV__DNN_INLINE_NS_END=}

--- Manual ---
('cv.dnn.LayerParams.LayerParams', '', [], [])
parse_name: cv.dnn.LayerParams.LayerParams with ['cv', 'cv::dnn', 'cv::dnn::<unnamed>', 'cv::dnn::CV__DNN_INLINE_NS'] -> fullname:cv::dnn::LayerParams::LayerParams namespace:cv::dnn classpath:LayerParams classname:LayerParams name:LayerParams
register (constructor) default in cv::dnn::LayerParams (cv_dnn_LayerParams_LayerParams)


===== Generating... =====
Generating func cv_dnn_<unnamed>_is_neg_int
  ignored: ignored by rename table
Generating func cv_dnn_NMSBoxes_VectorOfRect2d_VectorOffloat_float_float_VectorOfint_float_int
Generating func cv_dnn_NMSBoxes_VectorOfRect_VectorOffloat_float_float_VectorOfint_float_int
Generating func cv_dnn_NMSBoxes_VectorOfRotatedRect_VectorOffloat_float_float_VectorOfint_float_int
Generating func cv_dnn__const_iterator_begin_const
  ignored: return type class Unknown[std::map<String, DictValue>::const_iterator] is ignored
Generating func cv_dnn__const_iterator_end_const
  ignored: return type class Unknown[std::map<String, DictValue>::const_iterator] is ignored
Generating func cv_dnn_blobFromImage__InputArray__OutputArray_double_Size_Scalar_bool_bool_int
Generating func cv_dnn_blobFromImage__InputArray_double_Size_Scalar_bool_bool_int
Generating func cv_dnn_blobFromImages__InputArray__OutputArray_double_Size_Scalar_bool_bool_int
Generating func cv_dnn_blobFromImages__InputArray_double_Size_Scalar_bool_bool_int
Generating func cv_dnn_clamp_Range_int
Generating func cv_dnn_clamp_int_MatShape
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_clamp_int_int
Generating func cv_dnn_concat_MatShape_MatShape
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_getAvailableBackends
  ignored: return type class Vector[Unknown[std::pair<Backend, Target>]] is ignored
Generating func cv_dnn_getAvailableTargets_Backend
Generating func cv_dnn_getInferenceEngineVPUType
Generating func cv_dnn_getPlane_Mat_int_int
Generating func cv_dnn_imagesFromBlob_Mat__OutputArray
Generating func cv_dnn_print_MatShape_String
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_readNetFromCaffe_String_String
Generating func cv_dnn_readNetFromCaffe_VectorOfuchar_VectorOfuchar
Generating func cv_dnn_readNetFromCaffe_const_char_X_size_t_const_char_X_size_t
Generating func cv_dnn_readNetFromDarknet_String_String
Generating func cv_dnn_readNetFromDarknet_VectorOfuchar_VectorOfuchar
Generating func cv_dnn_readNetFromDarknet_const_char_X_size_t_const_char_X_size_t
Generating func cv_dnn_readNetFromModelOptimizer_String_String
Generating func cv_dnn_readNetFromONNX_String
Generating func cv_dnn_readNetFromONNX_VectorOfuchar
Generating func cv_dnn_readNetFromONNX_const_char_X_size_t
Generating func cv_dnn_readNetFromTensorflow_String_String
Generating func cv_dnn_readNetFromTensorflow_VectorOfuchar_VectorOfuchar
Generating func cv_dnn_readNetFromTensorflow_const_char_X_size_t_const_char_X_size_t
Generating func cv_dnn_readNetFromTorch_String_bool_bool
Generating func cv_dnn_readNet_String_String_String
Generating func cv_dnn_readNet_String_VectorOfuchar_VectorOfuchar
Generating func cv_dnn_readTensorFromONNX_String
Generating func cv_dnn_readTorchBlob_String_bool
Generating func cv_dnn_resetMyriadDevice
Generating func cv_dnn_shape_Mat
Generating func cv_dnn_shape_MatSize
  ignored: can not map type Unknown[MatSize] yet
Generating func cv_dnn_shape_UMat
Generating func cv_dnn_shape_const_int_X_int
Generating func cv_dnn_shape_int_int_int_int
Generating func cv_dnn_shrinkCaffeModel_String_String_VectorOfString
Generating func cv_dnn_slice_Mat_Range
Generating func cv_dnn_slice_Mat_Range_Range
Generating func cv_dnn_slice_Mat_Range_Range_Range
Generating func cv_dnn_slice_Mat_Range_Range_Range_Range
Generating func cv_dnn_toString_MatShape_String
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_total_MatShape_int_int
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_writeTextGraph_String_String
Ghost class cv::Algorithm (ghost, trait), ignoring
Ghost class cv::DMatch (simple, ghost), ignoring
Ghost class cv::DescriptorMatcher (ghost, trait), ignoring
Ghost class cv::Feature2D (ghost, trait), ignoring
Ghost class cv::FileNode (ghost), ignoring
Ghost class cv::FileStorage (ghost), ignoring
Ghost class cv::KeyPoint (simple, ghost), ignoring
Ghost class cv::Mat (ghost), ignoring
Ghost class cv::MatExpr (ghost), ignoring
Ghost class cv::Range (ghost), ignoring
Ghost class cv::RotatedRect (ghost), ignoring
Ghost class cv::TermCriteria (ghost), ignoring
Ghost class cv::UMat (ghost), ignoring
Ghost class cv::_InputArray (ghost, trait), ignoring
Ghost class cv::_InputOutputArray (ghost, trait), ignoring
Ghost class cv::_OutputArray (ghost, trait), ignoring
Generating box for cv::dnn::AbsLayer
Generating func cv_dnn_AbsLayer_create_LayerParams
Generating impl for trait cv::dnn::ActivationLayer (trait)
Generating func cv_dnn_ActivationLayer_forwardSlice_const_const_float_X_float_X_int_size_t_int_int
Generating box for cv::dnn::BNLLLayer
Generating func cv_dnn_BNLLLayer_create_LayerParams
Generating box for cv::dnn::BackendNode
Generating func cv_dnn_BackendNode_BackendNode_int
Generating impl for trait cv::dnn::BackendWrapper (trait)
Generating func cv_dnn_BackendWrapper_copyToHost
Generating func cv_dnn_BackendWrapper_setHostDirty
Generating impl for trait cv::dnn::BaseConvolutionLayer (trait)
Generating box for cv::dnn::BaseConvolutionLayer (trait)
Generating box for cv::dnn::BatchNormLayer
Generating func cv_dnn_BatchNormLayer_create_LayerParams
Generating box for cv::dnn::BlankLayer
Generating func cv_dnn_BlankLayer_create_LayerParams
Generating box for cv::dnn::ChannelsPReLULayer
Generating func cv_dnn_ChannelsPReLULayer_create_LayerParams
Generating box for cv::dnn::ConcatLayer
Generating func cv_dnn_ConcatLayer_create_LayerParams
Generating box for cv::dnn::ConstLayer
Generating func cv_dnn_ConstLayer_create_LayerParams
Generating box for cv::dnn::ConvolutionLayer
Generating func cv_dnn_ConvolutionLayer_create_LayerParams
Generating box for cv::dnn::CropAndResizeLayer
Generating func cv_dnn_CropAndResizeLayer_create_LayerParams
Generating box for cv::dnn::CropLayer
Generating func cv_dnn_CropLayer_create_LayerParams
Generating box for cv::dnn::DeconvolutionLayer
Generating func cv_dnn_DeconvolutionLayer_create_LayerParams
Generating box for cv::dnn::DetectionOutputLayer
Generating func cv_dnn_DetectionOutputLayer_create_LayerParams
Generating impl for trait cv::dnn::Dict (trait)
Generating func cv_dnn_Dict_has_const_String
Generating func cv_dnn_Dict_ptr_String
Generating func cv_dnn_Dict_ptr_const_String
Generating func cv_dnn_Dict_get_const_String
Generating func cv_dnn_Dict_get_const_String
  ignored: already there
Generating func cv_dnn_Dict_get_const_String_T
  ignored: return type class Unknown[template <typename T> T] is ignored
Generating func cv_dnn_Dict_set_String_DictValue
Generating func cv_dnn_Dict_erase_String
Generating box for cv::dnn::Dict (trait)
Generating func cv_dnn_Dict_has_const_String
  ignored: already there
Generating func cv_dnn_Dict_ptr_String
  ignored: already there
Generating func cv_dnn_Dict_ptr_const_String
  ignored: already there
Generating func cv_dnn_Dict_get_const_String
  ignored: already there
Generating func cv_dnn_Dict_get_const_String
  ignored: already there
Generating func cv_dnn_Dict_get_const_String_T
  ignored: return type class Unknown[template <typename T> T] is ignored
Generating func cv_dnn_Dict_set_String_DictValue
  ignored: already there
Generating func cv_dnn_Dict_erase_String
  ignored: already there
Generating box for cv::dnn::DictValue
Generating func cv_dnn_DictValue_DictValue_DictValue
Generating func cv_dnn_DictValue_DictValue_bool
Generating func cv_dnn_DictValue_DictValue_int64
Generating func cv_dnn_DictValue_DictValue_int
Generating func cv_dnn_DictValue_DictValue_unsigned
Generating func cv_dnn_DictValue_DictValue_double
Generating func cv_dnn_DictValue_DictValue_String
  ignored: ignored by rename table
Generating func cv_dnn_DictValue_DictValue_const_char_X
Generating func cv_dnn_DictValue_DictValue_arrayInt_TypeIter_int
  ignored: return type class Unknown[template<typename TypeIter> static DictValue] is ignored
Generating func cv_dnn_DictValue_DictValue_arrayReal_TypeIter_int
  ignored: return type class Unknown[template<typename TypeIter> static DictValue] is ignored
Generating func cv_dnn_DictValue_DictValue_arrayString_TypeIter_int
  ignored: return type class Unknown[template<typename TypeIter> static DictValue] is ignored
Generating func cv_dnn_DictValue_get_const_int
  ignored: return type class Unknown[template<typename T> T] is ignored
Generating func cv_dnn_DictValue_size_const
Generating func cv_dnn_DictValue_isInt_const
Generating func cv_dnn_DictValue_isString_const
Generating func cv_dnn_DictValue_isReal_const
Generating func cv_dnn_DictValue_getIntValue_const_int
Generating func cv_dnn_DictValue_getRealValue_const_int
Generating func cv_dnn_DictValue_getStringValue_const_int
Generating box for cv::dnn::ELULayer
Generating func cv_dnn_ELULayer_create_LayerParams
Generating box for cv::dnn::EltwiseLayer
Generating func cv_dnn_EltwiseLayer_create_LayerParams
Generating box for cv::dnn::FlattenLayer
Generating func cv_dnn_FlattenLayer_create_LayerParams
Generating box for cv::dnn::InnerProductLayer
Generating func cv_dnn_InnerProductLayer_create_LayerParams
Generating box for cv::dnn::InterpLayer
Generating func cv_dnn_InterpLayer_create_LayerParams
Generating box for cv::dnn::LRNLayer
Generating func cv_dnn_LRNLayer_create_LayerParams
Generating impl for trait cv::dnn::LSTMLayer (trait)
Generating func cv_dnn_LSTMLayer_setWeights_Mat_Mat_Mat
Generating func cv_dnn_LSTMLayer_setOutShape_MatShape
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_LSTMLayer_setUseTimstampsDim_bool
Generating func cv_dnn_LSTMLayer_setProduceCellOutput_bool
Generating func cv_dnn_LSTMLayer_inputNameToIndex_String
Generating func cv_dnn_LSTMLayer_outputNameToIndex_String
Generating func cv_dnn_LSTMLayer_create_LayerParams
Generating impl for trait cv::dnn::Layer (trait)
Generating func cv_dnn_Layer_blobs
Generating func cv_dnn_Layer_set_blobs_VectorOfMat
Generating func cv_dnn_Layer_name
Generating func cv_dnn_Layer_set_name_String
Generating func cv_dnn_Layer_type
Generating func cv_dnn_Layer_set_type_String
Generating func cv_dnn_Layer_preferableTarget_const
Generating func cv_dnn_Layer_void_finalize_std_vector<Mat*>_VectorOfMat
  ignored: return type class Unknown[_EXTERNAL void] is ignored
Generating func cv_dnn_Layer_finalize__InputArray__OutputArray
Generating func cv_dnn_Layer_void_forward_std_vector<Mat*>_VectorOfMat_VectorOfMat
  ignored: return type class Unknown[_EXTERNAL void] is ignored
Generating func cv_dnn_Layer_forward__InputArray__OutputArray__OutputArray
Generating func cv_dnn_Layer_forward_fallback__InputArray__OutputArray__OutputArray
Generating func cv_dnn_Layer_void_finalize_VectorOfMat_VectorOfMat
  ignored: return type class Unknown[_EXTERNAL void] is ignored
Generating func cv_dnn_Layer_finalize_VectorOfMat
Generating func cv_dnn_Layer_run_VectorOfMat_VectorOfMat_VectorOfMat
Generating func cv_dnn_Layer_inputNameToIndex_String
Generating func cv_dnn_Layer_outputNameToIndex_String
Generating func cv_dnn_Layer_supportBackend_int
Generating func cv_dnn_Layer_initHalide_VectorOfPtrOfBackendWrapper
Generating func cv_dnn_Layer_initInfEngine_VectorOfPtrOfBackendWrapper
Generating func cv_dnn_Layer_initVkCom_VectorOfPtrOfBackendWrapper
Generating func cv_dnn_Layer_applyHalideScheduler_const_PtrOfBackendNode_std_vector<Mat*>_VectorOfMat_int
  ignored: can not map type Vector[RawPtr[cv::Mat (boxed)]] yet
Generating func cv_dnn_Layer_tryAttach_PtrOfBackendNode
Generating func cv_dnn_Layer_setActivation_PtrOfActivationLayer
Generating func cv_dnn_Layer_tryFuse_PtrOfLayer
Generating func cv_dnn_Layer_getScaleShift_const_Mat_Mat
Generating func cv_dnn_Layer_unsetAttached
Generating func cv_dnn_Layer_getMemoryShapes_const_VectorOfVectorOfint_int_VectorOfVectorOfint_VectorOfVectorOfint
Generating func cv_dnn_Layer_getFLOPS_const_VectorOfVectorOfint_VectorOfVectorOfint
Generating func cv_dnn_Layer_setParamsFrom_LayerParams
Generating box for cv::dnn::Layer (trait)
Generating func cv_dnn_Layer_void_finalize_std_vector<Mat*>_VectorOfMat
  ignored: return type class Unknown[_EXTERNAL void] is ignored
Generating func cv_dnn_Layer_finalize__InputArray__OutputArray
  ignored: already there
Generating func cv_dnn_Layer_void_forward_std_vector<Mat*>_VectorOfMat_VectorOfMat
  ignored: return type class Unknown[_EXTERNAL void] is ignored
Generating func cv_dnn_Layer_forward__InputArray__OutputArray__OutputArray
  ignored: already there
Generating func cv_dnn_Layer_forward_fallback__InputArray__OutputArray__OutputArray
  ignored: already there
Generating func cv_dnn_Layer_void_finalize_VectorOfMat_VectorOfMat
  ignored: return type class Unknown[_EXTERNAL void] is ignored
Generating func cv_dnn_Layer_finalize_VectorOfMat
  ignored: already there
Generating func cv_dnn_Layer_run_VectorOfMat_VectorOfMat_VectorOfMat
  ignored: already there
Generating func cv_dnn_Layer_inputNameToIndex_String
  ignored: already there
Generating func cv_dnn_Layer_outputNameToIndex_String
  ignored: already there
Generating func cv_dnn_Layer_supportBackend_int
  ignored: already there
Generating func cv_dnn_Layer_initHalide_VectorOfPtrOfBackendWrapper
  ignored: already there
Generating func cv_dnn_Layer_initInfEngine_VectorOfPtrOfBackendWrapper
  ignored: already there
Generating func cv_dnn_Layer_initVkCom_VectorOfPtrOfBackendWrapper
  ignored: already there
Generating func cv_dnn_Layer_applyHalideScheduler_const_PtrOfBackendNode_std_vector<Mat*>_VectorOfMat_int
  ignored: can not map type Vector[RawPtr[cv::Mat (boxed)]] yet
Generating func cv_dnn_Layer_tryAttach_PtrOfBackendNode
  ignored: already there
Generating func cv_dnn_Layer_setActivation_PtrOfActivationLayer
  ignored: already there
Generating func cv_dnn_Layer_tryFuse_PtrOfLayer
  ignored: already there
Generating func cv_dnn_Layer_getScaleShift_const_Mat_Mat
  ignored: already there
Generating func cv_dnn_Layer_unsetAttached
  ignored: already there
Generating func cv_dnn_Layer_getMemoryShapes_const_VectorOfVectorOfint_int_VectorOfVectorOfint_VectorOfVectorOfint
  ignored: already there
Generating func cv_dnn_Layer_getFLOPS_const_VectorOfVectorOfint_VectorOfVectorOfint
  ignored: already there
Generating func cv_dnn_Layer_Layer
Generating func cv_dnn_Layer_Layer_LayerParams
Generating func cv_dnn_Layer_setParamsFrom_LayerParams
  ignored: already there
Generating box for cv::dnn::LayerFactory
Generating func cv_dnn_LayerFactory_registerLayer_String_Constructor
  ignored: can not map type Unknown[Constructor] yet
Generating func cv_dnn_LayerFactory_unregisterLayer_String
Generating func cv_dnn_LayerFactory_createLayerInstance_String_LayerParams
Generating box for cv::dnn::LayerParams
Generating func cv_dnn_LayerParams_blobs
Generating func cv_dnn_LayerParams_set_blobs_VectorOfMat
Generating func cv_dnn_LayerParams_name
Generating func cv_dnn_LayerParams_set_name_String
Generating func cv_dnn_LayerParams_type
Generating func cv_dnn_LayerParams_set_type_String
Generating func cv_dnn_LayerParams_LayerParams
Generating box for cv::dnn::MVNLayer
Generating func cv_dnn_MVNLayer_create_LayerParams
Generating box for cv::dnn::MaxUnpoolLayer
Generating func cv_dnn_MaxUnpoolLayer_create_LayerParams
Generating box for cv::dnn::Net
Generating func cv_dnn_Net_Net
Generating func cv_dnn_Net_readFromModelOptimizer_String_String
Generating func cv_dnn_Net_empty_const
Generating func cv_dnn_Net_dump
Generating func cv_dnn_Net_dumpToFile_String
Generating func cv_dnn_Net_addLayer_String_String_LayerParams
Generating func cv_dnn_Net_addLayerToPrev_String_String_LayerParams
Generating func cv_dnn_Net_getLayerId_String
Generating func cv_dnn_Net_getLayerNames_const
Generating func cv_dnn_Net_getLayer_DictValue
Generating func cv_dnn_Net_getLayerInputs_DictValue
Generating func cv_dnn_Net_connect_String_String
Generating func cv_dnn_Net_connect_int_int_int_int
Generating func cv_dnn_Net_setInputsNames_VectorOfString
Generating func cv_dnn_Net_forward_String
Generating func cv_dnn_Net_forwardAsync_String
  ignored: return type class Unknown[AsyncArray] is ignored
Generating func cv_dnn_Net_forward__OutputArray_String
Generating func cv_dnn_Net_forward__OutputArray_VectorOfString
Generating func cv_dnn_Net_forward_VectorOfVectorOfMat_VectorOfString
Generating func cv_dnn_Net_setHalideScheduler_String
Generating func cv_dnn_Net_setPreferableBackend_int
Generating func cv_dnn_Net_setPreferableTarget_int
Generating func cv_dnn_Net_setInput__InputArray_String_double_Scalar
Generating func cv_dnn_Net_setParam_DictValue_int_Mat
Generating func cv_dnn_Net_getParam_DictValue_int
Generating func cv_dnn_Net_getUnconnectedOutLayers_const
Generating func cv_dnn_Net_getUnconnectedOutLayersNames_const
Generating func cv_dnn_Net_getLayersShapes_const_VectorOfVectorOfint_VectorOfint_VectorOfVectorOfVectorOfint_VectorOfVectorOfVectorOfint
Generating func cv_dnn_Net_getLayersShapes_const_MatShape_VectorOfint_VectorOfVectorOfVectorOfint_VectorOfVectorOfVectorOfint
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_Net_getLayerShapes_const_MatShape_int_VectorOfVectorOfint_VectorOfVectorOfint
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_Net_getLayerShapes_const_VectorOfVectorOfint_int_VectorOfVectorOfint_VectorOfVectorOfint
Generating func cv_dnn_Net_getFLOPS_const_VectorOfVectorOfint
Generating func cv_dnn_Net_getFLOPS_const_MatShape
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_Net_getFLOPS_const_int_VectorOfVectorOfint
Generating func cv_dnn_Net_getFLOPS_const_int_MatShape
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_Net_getLayerTypes_const_VectorOfString
Generating func cv_dnn_Net_getLayersCount_const_String
Generating func cv_dnn_Net_getMemoryConsumption_const_VectorOfVectorOfint_size_t_size_t
Generating func cv_dnn_Net_getMemoryConsumption_const_MatShape_size_t_size_t
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_Net_getMemoryConsumption_const_int_VectorOfVectorOfint_size_t_size_t
Generating func cv_dnn_Net_getMemoryConsumption_const_int_MatShape_size_t_size_t
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_Net_getMemoryConsumption_const_VectorOfVectorOfint_VectorOfint_VectorOfsize_t_VectorOfsize_t
Generating func cv_dnn_Net_getMemoryConsumption_const_MatShape_VectorOfint_VectorOfsize_t_VectorOfsize_t
  ignored: can not map type Unknown[MatShape] yet
Generating func cv_dnn_Net_enableFusion_bool
Generating func cv_dnn_Net_getPerfProfile_VectorOfdouble
Generating box for cv::dnn::NormalizeBBoxLayer
Generating func cv_dnn_NormalizeBBoxLayer_create_LayerParams
Generating box for cv::dnn::PaddingLayer
Generating func cv_dnn_PaddingLayer_create_LayerParams
Generating box for cv::dnn::PermuteLayer
Generating func cv_dnn_PermuteLayer_create_LayerParams
Generating box for cv::dnn::PoolingLayer
Generating func cv_dnn_PoolingLayer_create_LayerParams
Generating box for cv::dnn::PowerLayer
Generating func cv_dnn_PowerLayer_create_LayerParams
Generating box for cv::dnn::PriorBoxLayer
Generating func cv_dnn_PriorBoxLayer_create_LayerParams
Generating box for cv::dnn::ProposalLayer
Generating func cv_dnn_ProposalLayer_create_LayerParams
Generating impl for trait cv::dnn::RNNLayer (trait)
Generating func cv_dnn_RNNLayer_setWeights_Mat_Mat_Mat_Mat_Mat
Generating func cv_dnn_RNNLayer_setProduceHiddenOutput_bool
Generating func cv_dnn_RNNLayer_create_LayerParams
Generating box for cv::dnn::ReLU6Layer
Generating func cv_dnn_ReLU6Layer_create_LayerParams
Generating box for cv::dnn::ReLULayer
Generating func cv_dnn_ReLULayer_create_LayerParams
Generating box for cv::dnn::RegionLayer
Generating func cv_dnn_RegionLayer_create_LayerParams
Generating box for cv::dnn::ReorgLayer
Generating func cv_dnn_ReorgLayer_create_LayerParams
Generating box for cv::dnn::ReshapeLayer
Generating func cv_dnn_ReshapeLayer_create_LayerParams
Generating box for cv::dnn::ResizeLayer
Generating func cv_dnn_ResizeLayer_create_LayerParams
Generating box for cv::dnn::ScaleLayer
Generating func cv_dnn_ScaleLayer_create_LayerParams
Generating box for cv::dnn::ShiftLayer
Generating func cv_dnn_ShiftLayer_create_LayerParams
Generating box for cv::dnn::ShuffleChannelLayer
Generating func cv_dnn_ShuffleChannelLayer_create_LayerParams
Generating box for cv::dnn::SigmoidLayer
Generating func cv_dnn_SigmoidLayer_create_LayerParams
Generating box for cv::dnn::SliceLayer
Generating func cv_dnn_SliceLayer_create_LayerParams
Generating box for cv::dnn::SoftmaxLayer
Generating func cv_dnn_SoftmaxLayer_create_LayerParams
Generating box for cv::dnn::SplitLayer
Generating func cv_dnn_SplitLayer_create_LayerParams
Generating box for cv::dnn::TanHLayer
Generating func cv_dnn_TanHLayer_create_LayerParams
Manual ignore class cv::dnn::_Range (ignored)
Ghost class cv::utils::logging::LogTag (ghost), ignoring
