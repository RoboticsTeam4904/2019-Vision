
--- Manual ---
('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']])
parse_name: class cv.Vec8i with ['cv'] -> fullname:cv::Vec8i namespace:cv classpath: classname: name:Vec8i
register class cv::Vec8i (('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']]))

--- Manual ---
('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6d with ['cv'] -> fullname:cv::Vec6d namespace:cv classpath: classname: name:Vec6d
register class cv::Vec6d (('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6f with ['cv'] -> fullname:cv::Vec6f namespace:cv classpath: classname: name:Vec6f
register class cv::Vec6f (('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6i with ['cv'] -> fullname:cv::Vec6i namespace:cv classpath: classname: name:Vec6i
register class cv::Vec6i (('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4d with ['cv'] -> fullname:cv::Vec4d namespace:cv classpath: classname: name:Vec4d
register class cv::Vec4d (('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4f with ['cv'] -> fullname:cv::Vec4f namespace:cv classpath: classname: name:Vec4f
register class cv::Vec4f (('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4i with ['cv'] -> fullname:cv::Vec4i namespace:cv classpath: classname: name:Vec4i
register class cv::Vec4i (('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4w with ['cv'] -> fullname:cv::Vec4w namespace:cv classpath: classname: name:Vec4w
register class cv::Vec4w (('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4s with ['cv'] -> fullname:cv::Vec4s namespace:cv classpath: classname: name:Vec4s
register class cv::Vec4s (('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4b with ['cv'] -> fullname:cv::Vec4b namespace:cv classpath: classname: name:Vec4b
register class cv::Vec4b (('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3d with ['cv'] -> fullname:cv::Vec3d namespace:cv classpath: classname: name:Vec3d
register class cv::Vec3d (('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3f with ['cv'] -> fullname:cv::Vec3f namespace:cv classpath: classname: name:Vec3f
register class cv::Vec3f (('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3i with ['cv'] -> fullname:cv::Vec3i namespace:cv classpath: classname: name:Vec3i
register class cv::Vec3i (('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3w with ['cv'] -> fullname:cv::Vec3w namespace:cv classpath: classname: name:Vec3w
register class cv::Vec3w (('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3s with ['cv'] -> fullname:cv::Vec3s namespace:cv classpath: classname: name:Vec3s
register class cv::Vec3s (('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3b with ['cv'] -> fullname:cv::Vec3b namespace:cv classpath: classname: name:Vec3b
register class cv::Vec3b (('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2d with ['cv'] -> fullname:cv::Vec2d namespace:cv classpath: classname: name:Vec2d
register class cv::Vec2d (('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2d',
    '',
    ['/Simple'],
    [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']])
parse_name: class cv.Size2d with ['cv'] -> fullname:cv::Size2d namespace:cv classpath: classname: name:Size2d
register class cv::Size2d (('class cv.Size2d', '', ['/Simple'], [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2d',
    '',
    ['/Simple'],
    [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']])
parse_name: class cv.Point2d with ['cv'] -> fullname:cv::Point2d namespace:cv classpath: classname: name:Point2d
register class cv::Point2d (('class cv.Point2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2d',
    '',
    ['/Simple'],
    [   ['double', 'x', '', '/RW'],
        ['double', 'y', '', '/RW'],
        ['double', 'width', '', '/RW'],
        ['double', 'height', '', '/RW']])
parse_name: class cv.Rect2d with ['cv'] -> fullname:cv::Rect2d namespace:cv classpath: classname: name:Rect2d
register class cv::Rect2d (('class cv.Rect2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW'], ['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2f with ['cv'] -> fullname:cv::Vec2f namespace:cv classpath: classname: name:Vec2f
register class cv::Vec2f (('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2f',
    '',
    ['/Simple'],
    [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']])
parse_name: class cv.Size2f with ['cv'] -> fullname:cv::Size2f namespace:cv classpath: classname: name:Size2f
register class cv::Size2f (('class cv.Size2f', '', ['/Simple'], [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2f',
    '',
    ['/Simple'],
    [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']])
parse_name: class cv.Point2f with ['cv'] -> fullname:cv::Point2f namespace:cv classpath: classname: name:Point2f
register class cv::Point2f (('class cv.Point2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2f',
    '',
    ['/Simple'],
    [   ['float', 'x', '', '/RW'],
        ['float', 'y', '', '/RW'],
        ['float', 'width', '', '/RW'],
        ['float', 'height', '', '/RW']])
parse_name: class cv.Rect2f with ['cv'] -> fullname:cv::Rect2f namespace:cv classpath: classname: name:Rect2f
register class cv::Rect2f (('class cv.Rect2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW'], ['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size2l',
    '',
    ['/Simple'],
    [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']])
parse_name: class cv.Size2l with ['cv'] -> fullname:cv::Size2l namespace:cv classpath: classname: name:Size2l
register class cv::Size2l (('class cv.Size2l', '', ['/Simple'], [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2l',
    '',
    ['/Simple'],
    [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']])
parse_name: class cv.Point2l with ['cv'] -> fullname:cv::Point2l namespace:cv classpath: classname: name:Point2l
register class cv::Point2l (('class cv.Point2l', '', ['/Simple'], [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']]))

--- Manual ---
('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2i with ['cv'] -> fullname:cv::Vec2i namespace:cv classpath: classname: name:Vec2i
register class cv::Vec2i (('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2i',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size2i with ['cv'] -> fullname:cv::Size2i namespace:cv classpath: classname: name:Size2i
register class cv::Size2i (('class cv.Size2i', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2i',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point2i with ['cv'] -> fullname:cv::Point2i namespace:cv classpath: classname: name:Point2i
register class cv::Point2i (('class cv.Point2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2i',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect2i with ['cv'] -> fullname:cv::Rect2i namespace:cv classpath: classname: name:Rect2i
register class cv::Rect2i (('class cv.Rect2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size with ['cv'] -> fullname:cv::Size namespace:cv classpath: classname: name:Size
register class cv::Size (('class cv.Size', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point with ['cv'] -> fullname:cv::Point namespace:cv classpath: classname: name:Point
register class cv::Point (('class cv.Point', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect with ['cv'] -> fullname:cv::Rect namespace:cv classpath: classname: name:Rect
register class cv::Rect (('class cv.Rect', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2w with ['cv'] -> fullname:cv::Vec2w namespace:cv classpath: classname: name:Vec2w
register class cv::Vec2w (('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2s with ['cv'] -> fullname:cv::Vec2s namespace:cv classpath: classname: name:Vec2s
register class cv::Vec2s (('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2b with ['cv'] -> fullname:cv::Vec2b namespace:cv classpath: classname: name:Vec2b
register class cv::Vec2b (('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Scalar with ['cv'] -> fullname:cv::Scalar namespace:cv classpath: classname: name:Scalar
register class cv::Scalar (('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv._InputArray', '', ['/Ghost'], [])
parse_name: class cv._InputArray with ['cv'] -> fullname:cv::_InputArray namespace:cv classpath: classname: name:_InputArray
register class cv::_InputArray (('class cv._InputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputArray', 'const _InputArray&', [], [])
parse_name: typedef cv.InputArray with ['cv'] -> fullname:cv::InputArray namespace:cv classpath: classname: name:InputArray
Registering an unknown type: InputArray

--- Manual ---
('class cv._OutputArray', '', ['/Ghost'], [])
parse_name: class cv._OutputArray with ['cv'] -> fullname:cv::_OutputArray namespace:cv classpath: classname: name:_OutputArray
register class cv::_OutputArray (('class cv._OutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.OutputArray', '_OutputArray&', [], [])
parse_name: typedef cv.OutputArray with ['cv'] -> fullname:cv::OutputArray namespace:cv classpath: classname: name:OutputArray
Registering an unknown type: OutputArray

--- Manual ---
('class cv._InputOutputArray', '', ['/Ghost'], [])
parse_name: class cv._InputOutputArray with ['cv'] -> fullname:cv::_InputOutputArray namespace:cv classpath: classname: name:_InputOutputArray
register class cv::_InputOutputArray (('class cv._InputOutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputOutputArray', '_InputOutputArray&', [], [])
parse_name: typedef cv.InputOutputArray with ['cv'] -> fullname:cv::InputOutputArray namespace:cv classpath: classname: name:InputOutputArray
Registering an unknown type: InputOutputArray

--- Manual ---
('typedef cv.InputArrayOfArrays', 'InputArray', [], [])
parse_name: typedef cv.InputArrayOfArrays with ['cv'] -> fullname:cv::InputArrayOfArrays namespace:cv classpath: classname: name:InputArrayOfArrays
Registering an unknown type: InputArrayOfArrays

--- Manual ---
('typedef cv.OutputArrayOfArrays', 'OutputArray', [], [])
parse_name: typedef cv.OutputArrayOfArrays with ['cv'] -> fullname:cv::OutputArrayOfArrays namespace:cv classpath: classname: name:OutputArrayOfArrays
Registering an unknown type: OutputArrayOfArrays

--- Manual ---
('typedef cv.InputOutputArrayOfArrays', 'InputOutputArray', [], [])
parse_name: typedef cv.InputOutputArrayOfArrays with ['cv'] -> fullname:cv::InputOutputArrayOfArrays namespace:cv classpath: classname: name:InputOutputArrayOfArrays
Registering an unknown type: InputOutputArrayOfArrays

--- Manual ---
('class cv.Range', '', ['/Ghost'], [])
parse_name: class cv.Range with ['cv'] -> fullname:cv::Range namespace:cv classpath: classname: name:Range
register class cv::Range (('class cv.Range', '', ['/Ghost'], []))

--- Manual ---
('class cv.MatExpr', '', ['/Ghost'], [])
parse_name: class cv.MatExpr with ['cv'] -> fullname:cv::MatExpr namespace:cv classpath: classname: name:MatExpr
register class cv::MatExpr (('class cv.MatExpr', '', ['/Ghost'], []))

--- Manual ---
('class cv.Mat', '', ['/Ghost'], [])
parse_name: class cv.Mat with ['cv'] -> fullname:cv::Mat namespace:cv classpath: classname: name:Mat
register class cv::Mat (('class cv.Mat', '', ['/Ghost'], []))

--- Manual ---
('class cv.UMat', '', ['/Ghost'], [])
parse_name: class cv.UMat with ['cv'] -> fullname:cv::UMat namespace:cv classpath: classname: name:UMat
register class cv::UMat (('class cv.UMat', '', ['/Ghost'], []))

--- Manual ---
('class cv.Algorithm', '', ['/Ghost'], [])
parse_name: class cv.Algorithm with ['cv'] -> fullname:cv::Algorithm namespace:cv classpath: classname: name:Algorithm
register class cv::Algorithm (('class cv.Algorithm', '', ['/Ghost'], []))

--- Manual ---
('class cv.DMatch', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.DMatch with ['cv'] -> fullname:cv::DMatch namespace:cv classpath: classname: name:DMatch
register class cv::DMatch (('class cv.DMatch', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.KeyPoint', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.KeyPoint with ['cv'] -> fullname:cv::KeyPoint namespace:cv classpath: classname: name:KeyPoint
register class cv::KeyPoint (('class cv.KeyPoint', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.RotatedRect', '', ['/Ghost'], [])
parse_name: class cv.RotatedRect with ['cv'] -> fullname:cv::RotatedRect namespace:cv classpath: classname: name:RotatedRect
register class cv::RotatedRect (('class cv.RotatedRect', '', ['/Ghost'], []))

--- Manual ---
('class cv.TermCriteria', '', ['/Ghost'], [])
parse_name: class cv.TermCriteria with ['cv'] -> fullname:cv::TermCriteria namespace:cv classpath: classname: name:TermCriteria
register class cv::TermCriteria (('class cv.TermCriteria', '', ['/Ghost'], []))

--- Manual ---
('class cv.utils.logging.LogTag', '', ['/Ghost'], [])
parse_name: class cv.utils.logging.LogTag with ['cv'] -> fullname:cv::utils::logging::LogTag namespace:cv classpath:utils::logging classname:logging name:LogTag
register class cv::utils::logging::LogTag (('class cv.utils.logging.LogTag', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileNode', '', ['/Ghost'], [])
parse_name: class cv.FileNode with ['cv'] -> fullname:cv::FileNode namespace:cv classpath: classname: name:FileNode
register class cv::FileNode (('class cv.FileNode', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileStorage', '', ['/Ghost'], [])
parse_name: class cv.FileStorage with ['cv'] -> fullname:cv::FileStorage namespace:cv classpath: classname: name:FileStorage
register class cv::FileStorage (('class cv.FileStorage', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.LayerParams', '', ['/Ghost'], [])
parse_name: class cv.dnn.LayerParams with ['cv'] -> fullname:cv::dnn::LayerParams namespace:cv classpath:dnn classname:dnn name:LayerParams
register class cv::dnn::LayerParams (('class cv.dnn.LayerParams', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.Layer', '', ['/Ghost'], [])
parse_name: class cv.dnn.Layer with ['cv'] -> fullname:cv::dnn::Layer namespace:cv classpath:dnn classname:dnn name:Layer
register class cv::dnn::Layer (('class cv.dnn.Layer', '', ['/Ghost'], []))

--- Manual ---
('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])
parse_name: class cv.Feature2D with ['cv'] -> fullname:cv::Feature2D namespace:cv classpath: classname: name:Feature2D
register class cv::Feature2D (('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])) impl:cv::Algorithm

--- Manual ---
('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])
parse_name: class cv.DescriptorMatcher with ['cv'] -> fullname:cv::DescriptorMatcher namespace:cv classpath: classname: name:DescriptorMatcher
register class cv::DescriptorMatcher (('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])) impl:cv::Algorithm

--- Manual ---
('typedef cv.FeatureDetector', 'Feature2D', [], [])
parse_name: typedef cv.FeatureDetector with ['cv'] -> fullname:cv::FeatureDetector namespace:cv classpath: classname: name:FeatureDetector
Registering an unknown type: FeatureDetector

--- Manual ---
('typedef cv.DescriptorExtractor', 'Feature2D', [], [])
parse_name: typedef cv.DescriptorExtractor with ['cv'] -> fullname:cv::DescriptorExtractor namespace:cv classpath: classname: name:DescriptorExtractor
Registering an unknown type: DescriptorExtractor

--- Manual ---
('enum cv.InterpolationFlags', '', ['/Ghost'], [])
parse_name: enum cv.InterpolationFlags with ['cv'] -> fullname:cv::InterpolationFlags namespace:cv classpath: classname: name:InterpolationFlags


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/ml.hpp ================


Namespaces: ['cv', 'cv.ml']
Comment: {'ml': '\n@defgroup ml Machine Learning\n\nThe Machine Learning Library (MLL) is a set of classes and functions for statistical\nclassification, regression, and clustering of data.\n\nMost of the classification and regression algorithms are implemented as C++ classes. As the\nalgorithms have different sets of features (like an ability to handle missing measurements or\ncategorical input variables), there is a little common ground between the classes. This common\nground is defined by the class cv::ml::StatModel that all the other ML classes are derived from.\n\nSee detailed overview here: @ref ml_intro.\n\n'}

--- Incoming ---
[   'enum cv.ml.VariableTypes',
    '',
    [],
    [   [   'const cv.ml.VAR_NUMERICAL',
            '0',
            [],
            [],
            None,
            'same as VAR_ORDERED\n'],
        ['const cv.ml.VAR_ORDERED', '0', [], [], None, 'ordered variables\n'],
        [   'const cv.ml.VAR_CATEGORICAL',
            '1',
            [],
            [],
            None,
            'categorical variables\n']],
    None,
    '@brief Variable types']
parse_name: const cv.ml.VAR_NUMERICAL with ['cv', 'cv::ml'] -> fullname:cv::ml::VAR_NUMERICAL namespace:cv::ml classpath: classname: name:VAR_NUMERICAL
parse_name: const cv.ml.VAR_ORDERED with ['cv', 'cv::ml'] -> fullname:cv::ml::VAR_ORDERED namespace:cv::ml classpath: classname: name:VAR_ORDERED
parse_name: const cv.ml.VAR_CATEGORICAL with ['cv', 'cv::ml'] -> fullname:cv::ml::VAR_CATEGORICAL namespace:cv::ml classpath: classname: name:VAR_CATEGORICAL
parse_name: enum cv.ml.VariableTypes with ['cv', 'cv::ml'] -> fullname:cv::ml::VariableTypes namespace:cv::ml classpath: classname: name:VariableTypes
parse_name: const cv.ml.VAR_NUMERICAL with ['cv', 'cv::ml'] -> fullname:cv::ml::VAR_NUMERICAL namespace:cv::ml classpath: classname: name:VAR_NUMERICAL
parse_name: const cv.ml.VAR_ORDERED with ['cv', 'cv::ml'] -> fullname:cv::ml::VAR_ORDERED namespace:cv::ml classpath: classname: name:VAR_ORDERED
parse_name: const cv.ml.VAR_CATEGORICAL with ['cv', 'cv::ml'] -> fullname:cv::ml::VAR_CATEGORICAL namespace:cv::ml classpath: classname: name:VAR_CATEGORICAL

--- Incoming ---
[   'enum cv.ml.ErrorTypes',
    '',
    [],
    [   ['const cv.ml.TEST_ERROR', '0', [], [], None, ''],
        ['const cv.ml.TRAIN_ERROR', '1', [], [], None, '']],
    None,
    '@brief %Error types']
parse_name: const cv.ml.TEST_ERROR with ['cv', 'cv::ml'] -> fullname:cv::ml::TEST_ERROR namespace:cv::ml classpath: classname: name:TEST_ERROR
parse_name: const cv.ml.TRAIN_ERROR with ['cv', 'cv::ml'] -> fullname:cv::ml::TRAIN_ERROR namespace:cv::ml classpath: classname: name:TRAIN_ERROR
parse_name: enum cv.ml.ErrorTypes with ['cv', 'cv::ml'] -> fullname:cv::ml::ErrorTypes namespace:cv::ml classpath: classname: name:ErrorTypes
parse_name: const cv.ml.TEST_ERROR with ['cv', 'cv::ml'] -> fullname:cv::ml::TEST_ERROR namespace:cv::ml classpath: classname: name:TEST_ERROR
parse_name: const cv.ml.TRAIN_ERROR with ['cv', 'cv::ml'] -> fullname:cv::ml::TRAIN_ERROR namespace:cv::ml classpath: classname: name:TRAIN_ERROR

--- Incoming ---
[   'enum cv.ml.SampleTypes',
    '',
    [],
    [   [   'const cv.ml.ROW_SAMPLE',
            '0',
            [],
            [],
            None,
            'each training sample is a row of samples\n'],
        [   'const cv.ml.COL_SAMPLE',
            '1',
            [],
            [],
            None,
            'each training sample occupies a column of samples\n']],
    None,
    '@brief Sample types']
parse_name: const cv.ml.ROW_SAMPLE with ['cv', 'cv::ml'] -> fullname:cv::ml::ROW_SAMPLE namespace:cv::ml classpath: classname: name:ROW_SAMPLE
parse_name: const cv.ml.COL_SAMPLE with ['cv', 'cv::ml'] -> fullname:cv::ml::COL_SAMPLE namespace:cv::ml classpath: classname: name:COL_SAMPLE
parse_name: enum cv.ml.SampleTypes with ['cv', 'cv::ml'] -> fullname:cv::ml::SampleTypes namespace:cv::ml classpath: classname: name:SampleTypes
parse_name: const cv.ml.ROW_SAMPLE with ['cv', 'cv::ml'] -> fullname:cv::ml::ROW_SAMPLE namespace:cv::ml classpath: classname: name:ROW_SAMPLE
parse_name: const cv.ml.COL_SAMPLE with ['cv', 'cv::ml'] -> fullname:cv::ml::COL_SAMPLE namespace:cv::ml classpath: classname: name:COL_SAMPLE

--- Incoming ---
[   'class cv.ml.ParamGrid',
    '',
    [],
    [   [   'double',
            'minVal',
            'Minimum value of the statmodel parameter. Default value is 0.',
            ['/RW']],
        [   'double',
            'maxVal',
            'Maximum value of the statmodel parameter. Default value is 0.',
            ['/RW']],
        [   'double',
            'logStep',
            '@brief Logarithmic step for iterating the statmodel parameter.\n'
            '\n'
            'The grid determines the following iteration sequence of the '
            'statmodel parameter values:\n'
            '\\f[(minVal, minVal*step, minVal*{step}^2, \\dots,  '
            'minVal*{logStep}^n),\\f]\n'
            'where \\f$n\\f$ is the maximal index satisfying\n'
            '\\f[\\texttt{minVal} * \\texttt{logStep} ^n <  '
            '\\texttt{maxVal}\\f]\n'
            'The grid is logarithmic, so logStep must always be greater than '
            '1. Default value is 1.',
            ['/RW']]],
    None,
    '@brief The structure represents the logarithmic grid range of statmodel '
    'parameters.\n'
    '\n'
    'It is used for optimizing statmodel accuracy by varying model parameters, '
    'the accuracy estimate\n'
    'being computed by cross-validation.']
parse_name: class cv.ml.ParamGrid with ['cv', 'cv::ml'] -> fullname:cv::ml::ParamGrid namespace:cv::ml classpath: classname: name:ParamGrid
register class cv::ml::ParamGrid (['class cv.ml.ParamGrid', '', [], [['double', 'minVal', 'Minimum value of the statmodel parameter. Default value is 0.', ['/RW']], ['double', 'maxVal', 'Maximum value of the statmodel parameter. Default value is 0.', ['/RW']], ['double', 'logStep', '@brief Logarithmic step for iterating the statmodel parameter.\n\nThe grid determines the following iteration sequence of the statmodel parameter values:\n\\f[(minVal, minVal*step, minVal*{step}^2, \\dots,  minVal*{logStep}^n),\\f]\nwhere \\f$n\\f$ is the maximal index satisfying\n\\f[\\texttt{minVal} * \\texttt{logStep} ^n <  \\texttt{maxVal}\\f]\nThe grid is logarithmic, so logStep must always be greater than 1. Default value is 1.', ['/RW']]], None, '@brief The structure represents the logarithmic grid range of statmodel parameters.\n\nIt is used for optimizing statmodel accuracy by varying model parameters, the accuracy estimate\nbeing computed by cross-validation.'])
parse_name: cv.ml.ParamGrid.minVal with ['cv', 'cv::ml'] -> fullname:cv::ml::ParamGrid::minVal namespace:cv::ml classpath:ParamGrid classname:ParamGrid name:minVal
register (method) minVal in cv::ml::ParamGrid (cv_ml_ParamGrid_minVal_const)
parse_name: cv.ml.ParamGrid.maxVal with ['cv', 'cv::ml'] -> fullname:cv::ml::ParamGrid::maxVal namespace:cv::ml classpath:ParamGrid classname:ParamGrid name:maxVal
register (method) maxVal in cv::ml::ParamGrid (cv_ml_ParamGrid_maxVal_const)
parse_name: cv.ml.ParamGrid.logStep with ['cv', 'cv::ml'] -> fullname:cv::ml::ParamGrid::logStep namespace:cv::ml classpath:ParamGrid classname:ParamGrid name:logStep
register (method) logStep in cv::ml::ParamGrid (cv_ml_ParamGrid_logStep_const)

--- Incoming ---
['cv.ml.ParamGrid.ParamGrid', 'P', [], [], None, '@brief Default constructor']
parse_name: cv.ml.ParamGrid.ParamGrid with ['cv', 'cv::ml'] -> fullname:cv::ml::ParamGrid::ParamGrid namespace:cv::ml classpath:ParamGrid classname:ParamGrid name:ParamGrid
register (constructor) default in cv::ml::ParamGrid (cv_ml_ParamGrid_ParamGrid)

--- Incoming ---
[   'cv.ml.ParamGrid.ParamGrid',
    'P',
    [],
    [   ['double', '_minVal', '', []],
        ['double', '_maxVal', '', []],
        ['double', '_logStep', '', []]],
    None,
    '@brief Constructor with parameters']
parse_name: cv.ml.ParamGrid.ParamGrid with ['cv', 'cv::ml'] -> fullname:cv::ml::ParamGrid::ParamGrid namespace:cv::ml classpath:ParamGrid classname:ParamGrid name:ParamGrid
register (constructor) new in cv::ml::ParamGrid (cv_ml_ParamGrid_ParamGrid_double_double_double)

--- Incoming ---
[   'cv.ml.ParamGrid.create',
    'Ptr<ParamGrid>',
    ['/S'],
    [   ['double', 'minVal', '0.', []],
        ['double', 'maxVal', '0.', []],
        ['double', 'logstep', '1.', []]],
    None,
    '@brief Creates a ParamGrid Ptr that can be given to the %SVM::trainAuto '
    'method\n'
    '\n'
    '@param minVal minimum value of the parameter grid\n'
    '@param maxVal maximum value of the parameter grid\n'
    '@param logstep Logarithmic step for iterating the statmodel parameter']
parse_name: cv.ml.ParamGrid.create with ['cv', 'cv::ml'] -> fullname:cv::ml::ParamGrid::create namespace:cv::ml classpath:ParamGrid classname:ParamGrid name:create
register (method) create in cv::ml::ParamGrid (cv_ml_ParamGrid_create_double_double_double)

--- Incoming ---
[   'class cv.ml.TrainData',
    '',
    [],
    [],
    None,
    '@brief Class encapsulating training data.\n'
    '\n'
    'Please note that the class only specifies the interface of training data, '
    'but not implementation.\n'
    'All the statistical model classes in _ml_ module accepts '
    'Ptr\\<TrainData\\> as parameter. In other\n'
    'words, you can create your own class derived from TrainData and pass '
    'smart pointer to the instance\n'
    'of this class into StatModel::train.\n'
    '\n'
    '@sa @ref ml_intro_data']
parse_name: class cv.ml.TrainData with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData namespace:cv::ml classpath: classname: name:TrainData
register class cv::ml::TrainData (['class cv.ml.TrainData', '', [], [], None, '@brief Class encapsulating training data.\n\nPlease note that the class only specifies the interface of training data, but not implementation.\nAll the statistical model classes in _ml_ module accepts Ptr\\<TrainData\\> as parameter. In other\nwords, you can create your own class derived from TrainData and pass smart pointer to the instance\nof this class into StatModel::train.\n\n@sa @ref ml_intro_data'])

--- Incoming ---
['cv.ml.TrainData.missingValue', 'float', [], [], None, '']
parse_name: cv.ml.TrainData.missingValue with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::missingValue namespace:cv::ml classpath:TrainData classname:TrainData name:missingValue
register (method) missingValue in cv::ml::TrainData (cv_ml_TrainData_missingValue)

--- Incoming ---
['cv.ml.TrainData.~TrainData', '~', [], [], None, '']
parse_name: cv.ml.TrainData.~TrainData with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::~TrainData namespace:cv::ml classpath:TrainData classname:TrainData name:~TrainData
Registering an unknown type: ~
ignore destructor (method) ~TrainData in cv::ml::TrainData

--- Incoming ---
['cv.ml.TrainData.getLayout', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getLayout with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getLayout namespace:cv::ml classpath:TrainData classname:TrainData name:getLayout
register (method) getLayout in cv::ml::TrainData (trait) (cv_ml_TrainData_getLayout_const)

--- Incoming ---
['cv.ml.TrainData.getNTrainSamples', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getNTrainSamples with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNTrainSamples namespace:cv::ml classpath:TrainData classname:TrainData name:getNTrainSamples
register (method) getNTrainSamples in cv::ml::TrainData (trait) (cv_ml_TrainData_getNTrainSamples_const)

--- Incoming ---
['cv.ml.TrainData.getNTestSamples', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getNTestSamples with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNTestSamples namespace:cv::ml classpath:TrainData classname:TrainData name:getNTestSamples
register (method) getNTestSamples in cv::ml::TrainData (trait) (cv_ml_TrainData_getNTestSamples_const)

--- Incoming ---
['cv.ml.TrainData.getNSamples', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getNSamples with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNSamples namespace:cv::ml classpath:TrainData classname:TrainData name:getNSamples
register (method) getNSamples in cv::ml::TrainData (trait) (cv_ml_TrainData_getNSamples_const)

--- Incoming ---
['cv.ml.TrainData.getNVars', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getNVars with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNVars namespace:cv::ml classpath:TrainData classname:TrainData name:getNVars
register (method) getNVars in cv::ml::TrainData (trait) (cv_ml_TrainData_getNVars_const)

--- Incoming ---
['cv.ml.TrainData.getNAllVars', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getNAllVars with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNAllVars namespace:cv::ml classpath:TrainData classname:TrainData name:getNAllVars
register (method) getNAllVars in cv::ml::TrainData (trait) (cv_ml_TrainData_getNAllVars_const)

--- Incoming ---
[   'cv.ml.TrainData.getSample',
    'void',
    ['/A', '/C'],
    [   ['InputArray', 'varIdx', '', []],
        ['int', 'sidx', '', []],
        ['float*', 'buf', '', []]],
    None,
    '']
parse_name: cv.ml.TrainData.getSample with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getSample namespace:cv::ml classpath:TrainData classname:TrainData name:getSample
register (method) getSample in cv::ml::TrainData (trait) (cv_ml_TrainData_getSample_const__InputArray_int_float_X)

--- Incoming ---
['cv.ml.TrainData.getSamples', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getSamples with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getSamples namespace:cv::ml classpath:TrainData classname:TrainData name:getSamples
register (method) getSamples in cv::ml::TrainData (trait) (cv_ml_TrainData_getSamples_const)

--- Incoming ---
['cv.ml.TrainData.getMissing', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getMissing with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getMissing namespace:cv::ml classpath:TrainData classname:TrainData name:getMissing
register (method) getMissing in cv::ml::TrainData (trait) (cv_ml_TrainData_getMissing_const)

--- Incoming ---
[   'cv.ml.TrainData.getTrainSamples',
    'Mat',
    ['/A', '/C'],
    [   ['int', 'layout', 'ROW_SAMPLE', []],
        ['bool', 'compressSamples', 'true', []],
        ['bool', 'compressVars', 'true', []]],
    None,
    '@brief Returns matrix of train samples\n'
    '\n'
    "@param layout The requested layout. If it's different from the initial "
    'one, the matrix is\n'
    'transposed. See ml::SampleTypes.\n'
    '@param compressSamples if true, the function returns only the training '
    'samples (specified by\n'
    'sampleIdx)\n'
    '@param compressVars if true, the function returns the shorter training '
    'samples, containing only\n'
    'the active variables.\n'
    '\n'
    'In current implementation the function tries to avoid physical data '
    'copying and returns the\n'
    'matrix stored inside TrainData (unless the transposition or compression '
    'is needed).']
parse_name: cv.ml.TrainData.getTrainSamples with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTrainSamples namespace:cv::ml classpath:TrainData classname:TrainData name:getTrainSamples
register (method) getTrainSamples in cv::ml::TrainData (trait) (cv_ml_TrainData_getTrainSamples_const_int_bool_bool)

--- Incoming ---
[   'cv.ml.TrainData.getTrainResponses',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns the vector of responses\n'
    '\n'
    'The function returns ordered or the original categorical responses. '
    "Usually it's used in\n"
    'regression algorithms.']
parse_name: cv.ml.TrainData.getTrainResponses with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTrainResponses namespace:cv::ml classpath:TrainData classname:TrainData name:getTrainResponses
register (method) getTrainResponses in cv::ml::TrainData (trait) (cv_ml_TrainData_getTrainResponses_const)

--- Incoming ---
[   'cv.ml.TrainData.getTrainNormCatResponses',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns the vector of normalized categorical responses\n'
    '\n'
    'The function returns vector of responses. Each response is integer from '
    '`0` to `<number of\n'
    'classes>-1`. The actual label value can be retrieved then from the class '
    'label vector, see\n'
    'TrainData::getClassLabels.']
parse_name: cv.ml.TrainData.getTrainNormCatResponses with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTrainNormCatResponses namespace:cv::ml classpath:TrainData classname:TrainData name:getTrainNormCatResponses
register (method) getTrainNormCatResponses in cv::ml::TrainData (trait) (cv_ml_TrainData_getTrainNormCatResponses_const)

--- Incoming ---
['cv.ml.TrainData.getTestResponses', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getTestResponses with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTestResponses namespace:cv::ml classpath:TrainData classname:TrainData name:getTestResponses
register (method) getTestResponses in cv::ml::TrainData (trait) (cv_ml_TrainData_getTestResponses_const)

--- Incoming ---
['cv.ml.TrainData.getTestNormCatResponses', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getTestNormCatResponses with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTestNormCatResponses namespace:cv::ml classpath:TrainData classname:TrainData name:getTestNormCatResponses
register (method) getTestNormCatResponses in cv::ml::TrainData (trait) (cv_ml_TrainData_getTestNormCatResponses_const)

--- Incoming ---
['cv.ml.TrainData.getResponses', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getResponses with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getResponses namespace:cv::ml classpath:TrainData classname:TrainData name:getResponses
register (method) getResponses in cv::ml::TrainData (trait) (cv_ml_TrainData_getResponses_const)

--- Incoming ---
['cv.ml.TrainData.getNormCatResponses', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getNormCatResponses with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNormCatResponses namespace:cv::ml classpath:TrainData classname:TrainData name:getNormCatResponses
register (method) getNormCatResponses in cv::ml::TrainData (trait) (cv_ml_TrainData_getNormCatResponses_const)

--- Incoming ---
['cv.ml.TrainData.getSampleWeights', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getSampleWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getSampleWeights namespace:cv::ml classpath:TrainData classname:TrainData name:getSampleWeights
register (method) getSampleWeights in cv::ml::TrainData (trait) (cv_ml_TrainData_getSampleWeights_const)

--- Incoming ---
['cv.ml.TrainData.getTrainSampleWeights', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getTrainSampleWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTrainSampleWeights namespace:cv::ml classpath:TrainData classname:TrainData name:getTrainSampleWeights
register (method) getTrainSampleWeights in cv::ml::TrainData (trait) (cv_ml_TrainData_getTrainSampleWeights_const)

--- Incoming ---
['cv.ml.TrainData.getTestSampleWeights', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getTestSampleWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTestSampleWeights namespace:cv::ml classpath:TrainData classname:TrainData name:getTestSampleWeights
register (method) getTestSampleWeights in cv::ml::TrainData (trait) (cv_ml_TrainData_getTestSampleWeights_const)

--- Incoming ---
['cv.ml.TrainData.getVarIdx', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getVarIdx with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getVarIdx namespace:cv::ml classpath:TrainData classname:TrainData name:getVarIdx
register (method) getVarIdx in cv::ml::TrainData (trait) (cv_ml_TrainData_getVarIdx_const)

--- Incoming ---
['cv.ml.TrainData.getVarType', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getVarType with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getVarType namespace:cv::ml classpath:TrainData classname:TrainData name:getVarType
register (method) getVarType in cv::ml::TrainData (trait) (cv_ml_TrainData_getVarType_const)

--- Incoming ---
['cv.ml.TrainData.getVarSymbolFlags', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getVarSymbolFlags with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getVarSymbolFlags namespace:cv::ml classpath:TrainData classname:TrainData name:getVarSymbolFlags
register (method) getVarSymbolFlags in cv::ml::TrainData (trait) (cv_ml_TrainData_getVarSymbolFlags_const)

--- Incoming ---
['cv.ml.TrainData.getResponseType', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getResponseType with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getResponseType namespace:cv::ml classpath:TrainData classname:TrainData name:getResponseType
register (method) getResponseType in cv::ml::TrainData (trait) (cv_ml_TrainData_getResponseType_const)

--- Incoming ---
['cv.ml.TrainData.getTrainSampleIdx', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getTrainSampleIdx with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTrainSampleIdx namespace:cv::ml classpath:TrainData classname:TrainData name:getTrainSampleIdx
register (method) getTrainSampleIdx in cv::ml::TrainData (trait) (cv_ml_TrainData_getTrainSampleIdx_const)

--- Incoming ---
['cv.ml.TrainData.getTestSampleIdx', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getTestSampleIdx with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTestSampleIdx namespace:cv::ml classpath:TrainData classname:TrainData name:getTestSampleIdx
register (method) getTestSampleIdx in cv::ml::TrainData (trait) (cv_ml_TrainData_getTestSampleIdx_const)

--- Incoming ---
[   'cv.ml.TrainData.getValues',
    'void',
    ['/A', '/C'],
    [   ['int', 'vi', '', []],
        ['InputArray', 'sidx', '', []],
        ['float*', 'values', '', []]],
    None,
    '']
parse_name: cv.ml.TrainData.getValues with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getValues namespace:cv::ml classpath:TrainData classname:TrainData name:getValues
register (method) getValues in cv::ml::TrainData (trait) (cv_ml_TrainData_getValues_const_int__InputArray_float_X)

--- Incoming ---
[   'cv.ml.TrainData.getNormCatValues',
    'void',
    ['/A', '/C'],
    [   ['int', 'vi', '', []],
        ['InputArray', 'sidx', '', []],
        ['int*', 'values', '', []]],
    None,
    '']
parse_name: cv.ml.TrainData.getNormCatValues with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNormCatValues namespace:cv::ml classpath:TrainData classname:TrainData name:getNormCatValues
register (method) getNormCatValues in cv::ml::TrainData (trait) (cv_ml_TrainData_getNormCatValues_const_int__InputArray_int_X)

--- Incoming ---
['cv.ml.TrainData.getDefaultSubstValues', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getDefaultSubstValues with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getDefaultSubstValues namespace:cv::ml classpath:TrainData classname:TrainData name:getDefaultSubstValues
register (method) getDefaultSubstValues in cv::ml::TrainData (trait) (cv_ml_TrainData_getDefaultSubstValues_const)

--- Incoming ---
[   'cv.ml.TrainData.getCatCount',
    'int',
    ['/A', '/C'],
    [['int', 'vi', '', []]],
    None,
    '']
parse_name: cv.ml.TrainData.getCatCount with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getCatCount namespace:cv::ml classpath:TrainData classname:TrainData name:getCatCount
register (method) getCatCount in cv::ml::TrainData (trait) (cv_ml_TrainData_getCatCount_const_int)

--- Incoming ---
[   'cv.ml.TrainData.getClassLabels',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns the vector of class labels\n'
    '\n'
    'The function returns vector of unique labels occurred in the responses.']
parse_name: cv.ml.TrainData.getClassLabels with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getClassLabels namespace:cv::ml classpath:TrainData classname:TrainData name:getClassLabels
register (method) getClassLabels in cv::ml::TrainData (trait) (cv_ml_TrainData_getClassLabels_const)

--- Incoming ---
['cv.ml.TrainData.getCatOfs', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getCatOfs with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getCatOfs namespace:cv::ml classpath:TrainData classname:TrainData name:getCatOfs
register (method) getCatOfs in cv::ml::TrainData (trait) (cv_ml_TrainData_getCatOfs_const)

--- Incoming ---
['cv.ml.TrainData.getCatMap', 'Mat', ['/A', '/C'], [], None, '']
parse_name: cv.ml.TrainData.getCatMap with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getCatMap namespace:cv::ml classpath:TrainData classname:TrainData name:getCatMap
register (method) getCatMap in cv::ml::TrainData (trait) (cv_ml_TrainData_getCatMap_const)

--- Incoming ---
[   'cv.ml.TrainData.setTrainTestSplit',
    'void',
    ['/A'],
    [['int', 'count', '', []], ['bool', 'shuffle', 'true', []]],
    None,
    '@brief Splits the training data into the training and test parts\n'
    '@sa TrainData::setTrainTestSplitRatio']
parse_name: cv.ml.TrainData.setTrainTestSplit with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::setTrainTestSplit namespace:cv::ml classpath:TrainData classname:TrainData name:setTrainTestSplit
register (method) setTrainTestSplit in cv::ml::TrainData (trait) (cv_ml_TrainData_setTrainTestSplit_int_bool)

--- Incoming ---
[   'cv.ml.TrainData.setTrainTestSplitRatio',
    'void',
    ['/A'],
    [['double', 'ratio', '', []], ['bool', 'shuffle', 'true', []]],
    None,
    '@brief Splits the training data into the training and test parts\n'
    '\n'
    'The function selects a subset of specified relative size and then returns '
    'it as the training\n'
    'set. If the function is not called, all the data is used for training. '
    'Please, note that for\n'
    'each of TrainData::getTrain\\* there is corresponding '
    'TrainData::getTest\\*, so that the test\n'
    'subset can be retrieved and processed as well.\n'
    '@sa TrainData::setTrainTestSplit']
parse_name: cv.ml.TrainData.setTrainTestSplitRatio with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::setTrainTestSplitRatio namespace:cv::ml classpath:TrainData classname:TrainData name:setTrainTestSplitRatio
register (method) setTrainTestSplitRatio in cv::ml::TrainData (trait) (cv_ml_TrainData_setTrainTestSplitRatio_double_bool)

--- Incoming ---
['cv.ml.TrainData.shuffleTrainTest', 'void', ['/A'], [], None, '']
parse_name: cv.ml.TrainData.shuffleTrainTest with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::shuffleTrainTest namespace:cv::ml classpath:TrainData classname:TrainData name:shuffleTrainTest
register (method) shuffleTrainTest in cv::ml::TrainData (trait) (cv_ml_TrainData_shuffleTrainTest)

--- Incoming ---
[   'cv.ml.TrainData.getTestSamples',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns matrix of test samples']
parse_name: cv.ml.TrainData.getTestSamples with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getTestSamples namespace:cv::ml classpath:TrainData classname:TrainData name:getTestSamples
register (method) getTestSamples in cv::ml::TrainData (trait) (cv_ml_TrainData_getTestSamples_const)

--- Incoming ---
[   'cv.ml.TrainData.getNames',
    'void',
    ['/A', '/C'],
    [['std::vector<String>&', 'names', '', []]],
    None,
    '@brief Returns vector of symbolic names captured in loadFromCSV()']
parse_name: cv.ml.TrainData.getNames with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getNames namespace:cv::ml classpath:TrainData classname:TrainData name:getNames
register (method) getNames in cv::ml::TrainData (trait) (cv_ml_TrainData_getNames_const_VectorOfString)

--- Incoming ---
[   'cv.ml.TrainData.getSubVector',
    'Mat',
    ['/S'],
    [['const Mat&', 'vec', '', []], ['const Mat&', 'idx', '', []]],
    None,
    '@brief Extract from 1D vector elements specified by passed indexes.\n'
    '@param vec input vector (supported types: CV_32S, CV_32F, CV_64F)\n'
    '@param idx 1D index vector']
parse_name: cv.ml.TrainData.getSubVector with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getSubVector namespace:cv::ml classpath:TrainData classname:TrainData name:getSubVector
register (method) getSubVector in cv::ml::TrainData (trait) (cv_ml_TrainData_getSubVector_Mat_Mat)

--- Incoming ---
[   'cv.ml.TrainData.getSubMatrix',
    'Mat',
    ['/S'],
    [   ['const Mat&', 'matrix', '', []],
        ['const Mat&', 'idx', '', []],
        ['int', 'layout', '', []]],
    None,
    '@brief Extract from matrix rows/cols specified by passed indexes.\n'
    '@param matrix input matrix (supported types: CV_32S, CV_32F, CV_64F)\n'
    '@param idx 1D index vector\n'
    '@param layout specifies to extract rows (cv::ml::ROW_SAMPLES) or to '
    'extract columns (cv::ml::COL_SAMPLES)']
parse_name: cv.ml.TrainData.getSubMatrix with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::getSubMatrix namespace:cv::ml classpath:TrainData classname:TrainData name:getSubMatrix
register (method) getSubMatrix in cv::ml::TrainData (trait) (cv_ml_TrainData_getSubMatrix_Mat_Mat_int)

--- Incoming ---
[   'cv.ml.TrainData.loadFromCSV',
    'Ptr<TrainData>',
    ['/S'],
    [   ['const String&', 'filename', '', []],
        ['int', 'headerLineCount', '', []],
        ['int', 'responseStartIdx', '-1', []],
        ['int', 'responseEndIdx', '-1', []],
        ['const String&', 'varTypeSpec', 'String()', []],
        ['char', 'delimiter', "'", []],
        ["'", '', '', []],
        ['char', 'missch', "'?'", []]],
    None,
    '@brief Reads the dataset from a .csv file and returns the ready-to-use '
    'training data.\n'
    '\n'
    '@param filename The input file name\n'
    '@param headerLineCount The number of lines in the beginning to skip; '
    'besides the header, the\n'
    'function also skips empty lines and lines staring with `#`\n'
    '@param responseStartIdx Index of the first output variable. If -1, the '
    'function considers the\n'
    'last variable as the response\n'
    '@param responseEndIdx Index of the last output variable + 1. If -1, then '
    'there is single\n'
    'response variable at responseStartIdx.\n'
    "@param varTypeSpec The optional text string that specifies the variables' "
    'types. It has the\n'
    'format `ord[n1-n2,n3,n4-n5,...]cat[n6,n7-n8,...]`. That is, variables '
    'from `n1 to n2`\n'
    '(inclusive range), `n3`, `n4 to n5` ... are considered ordered and `n6`, '
    '`n7 to n8` ... are\n'
    'considered as categorical. The range `[n1..n2] + [n3] + [n4..n5] + ... + '
    '[n6] + [n7..n8]`\n'
    'should cover all the variables. If varTypeSpec is not specified, then '
    'algorithm uses the\n'
    'following rules:\n'
    '- all input variables are considered ordered by default. If some column '
    'contains has non-\n'
    "numerical values, e.g. 'apple', 'pear', 'apple', 'apple', 'mango', the "
    'corresponding\n'
    'variable is considered categorical.\n'
    '- if there are several output variables, they are all considered as '
    'ordered. Error is\n'
    'reported when non-numerical values are used.\n'
    '- if there is a single output variable, then if its values are '
    'non-numerical or are all\n'
    "integers, then it's considered categorical. Otherwise, it's considered "
    'ordered.\n'
    '@param delimiter The character used to separate values in each line.\n'
    '@param missch The character used to specify missing measurements. It '
    'should not be a digit.\n'
    "Although it's a non-numerical value, it surely does not affect the "
    'decision of whether the\n'
    'variable ordered or categorical.\n'
    '@note If the dataset only contains input variables and no responses, use '
    'responseStartIdx = -2\n'
    'and responseEndIdx = 0. The output variables vector will just contain '
    'zeros.']
parse_name: cv.ml.TrainData.loadFromCSV with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::loadFromCSV namespace:cv::ml classpath:TrainData classname:TrainData name:loadFromCSV
register (method) loadFromCSV in cv::ml::TrainData (trait) (cv_ml_TrainData_loadFromCSV_String_int_int_int_String_char_char)

--- Incoming ---
[   'cv.ml.TrainData.create',
    'Ptr<TrainData>',
    ['/S'],
    [   ['InputArray', 'samples', '', []],
        ['int', 'layout', '', []],
        ['InputArray', 'responses', '', []],
        ['InputArray', 'varIdx', 'noArray()', []],
        ['InputArray', 'sampleIdx', 'noArray()', []],
        ['InputArray', 'sampleWeights', 'noArray()', []],
        ['InputArray', 'varType', 'noArray()', []]],
    None,
    '@brief Creates training data from in-memory arrays.\n'
    '\n'
    '@param samples matrix of samples. It should have CV_32F type.\n'
    '@param layout see ml::SampleTypes.\n'
    '@param responses matrix of responses. If the responses are scalar, they '
    'should be stored as a\n'
    'single row or as a single column. The matrix should have type CV_32F or '
    'CV_32S (in the\n'
    'former case the responses are considered as ordered by default; in the '
    'latter case - as\n'
    'categorical)\n'
    '@param varIdx vector specifying which variables to use for training. It '
    'can be an integer vector\n'
    '(CV_32S) containing 0-based variable indices or byte vector (CV_8U) '
    'containing a mask of\n'
    'active variables.\n'
    '@param sampleIdx vector specifying which samples to use for training. It '
    'can be an integer\n'
    'vector (CV_32S) containing 0-based sample indices or byte vector (CV_8U) '
    'containing a mask\n'
    'of training samples.\n'
    '@param sampleWeights optional vector with weights for each sample. It '
    'should have CV_32F type.\n'
    '@param varType optional vector of type CV_8U and size '
    '`<number_of_variables_in_samples> +\n'
    '<number_of_variables_in_responses>`, containing types of each input and '
    'output variable. See\n'
    'ml::VariableTypes.']
parse_name: cv.ml.TrainData.create with ['cv', 'cv::ml'] -> fullname:cv::ml::TrainData::create namespace:cv::ml classpath:TrainData classname:TrainData name:create
register (method) create in cv::ml::TrainData (trait) (cv_ml_TrainData_create__InputArray_int__InputArray__InputArray__InputArray__InputArray__InputArray)

--- Incoming ---
[   'class cv.ml.StatModel',
    ': cv::Algorithm',
    [],
    [],
    None,
    '@brief Base class for statistical models in OpenCV ML.']
parse_name: class cv.ml.StatModel with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel namespace:cv::ml classpath: classname: name:StatModel
register class cv::ml::StatModel (['class cv.ml.StatModel', ': cv::Algorithm', [], [], None, '@brief Base class for statistical models in OpenCV ML.']) impl:cv::Algorithm

--- Incoming ---
[   'enum cv.ml.StatModel.Flags',
    '',
    [],
    [   ['const cv.ml.StatModel.UPDATE_MODEL', '1', [], [], None, ''],
        [   'const cv.ml.StatModel.RAW_OUTPUT',
            '1',
            [],
            [],
            None,
            'makes the method return the raw results (the sum), not the class '
            'label\n'],
        ['const cv.ml.StatModel.COMPRESSED_INPUT', '2', [], [], None, ''],
        ['const cv.ml.StatModel.PREPROCESSED_INPUT', '4', [], [], None, '']],
    None,
    'Predict options']
parse_name: const cv.ml.StatModel.UPDATE_MODEL with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::UPDATE_MODEL namespace:cv::ml classpath:StatModel classname:StatModel name:UPDATE_MODEL
parse_name: const cv.ml.StatModel.RAW_OUTPUT with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::RAW_OUTPUT namespace:cv::ml classpath:StatModel classname:StatModel name:RAW_OUTPUT
parse_name: const cv.ml.StatModel.COMPRESSED_INPUT with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::COMPRESSED_INPUT namespace:cv::ml classpath:StatModel classname:StatModel name:COMPRESSED_INPUT
parse_name: const cv.ml.StatModel.PREPROCESSED_INPUT with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::PREPROCESSED_INPUT namespace:cv::ml classpath:StatModel classname:StatModel name:PREPROCESSED_INPUT
parse_name: enum cv.ml.StatModel.Flags with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::Flags namespace:cv::ml classpath:StatModel classname:StatModel name:Flags
parse_name: const cv.ml.StatModel.UPDATE_MODEL with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::UPDATE_MODEL namespace:cv::ml classpath:StatModel classname:StatModel name:UPDATE_MODEL
parse_name: const cv.ml.StatModel.RAW_OUTPUT with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::RAW_OUTPUT namespace:cv::ml classpath:StatModel classname:StatModel name:RAW_OUTPUT
parse_name: const cv.ml.StatModel.COMPRESSED_INPUT with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::COMPRESSED_INPUT namespace:cv::ml classpath:StatModel classname:StatModel name:COMPRESSED_INPUT
parse_name: const cv.ml.StatModel.PREPROCESSED_INPUT with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::PREPROCESSED_INPUT namespace:cv::ml classpath:StatModel classname:StatModel name:PREPROCESSED_INPUT

--- Incoming ---
[   'cv.ml.StatModel.getVarCount',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns the number of variables in training samples']
parse_name: cv.ml.StatModel.getVarCount with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::getVarCount namespace:cv::ml classpath:StatModel classname:StatModel name:getVarCount
register (method) getVarCount in cv::ml::StatModel (trait) (cv_ml_StatModel_getVarCount_const)

--- Incoming ---
['cv.ml.StatModel.empty', 'bool', ['/C'], [], None, '']
parse_name: cv.ml.StatModel.empty with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::empty namespace:cv::ml classpath:StatModel classname:StatModel name:empty
register (method) empty in cv::ml::StatModel (trait) (cv_ml_StatModel_empty_const)

--- Incoming ---
[   'cv.ml.StatModel.isTrained',
    'bool',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns true if the model is trained']
parse_name: cv.ml.StatModel.isTrained with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::isTrained namespace:cv::ml classpath:StatModel classname:StatModel name:isTrained
register (method) isTrained in cv::ml::StatModel (trait) (cv_ml_StatModel_isTrained_const)

--- Incoming ---
[   'cv.ml.StatModel.isClassifier',
    'bool',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns true if the model is classifier']
parse_name: cv.ml.StatModel.isClassifier with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::isClassifier namespace:cv::ml classpath:StatModel classname:StatModel name:isClassifier
register (method) isClassifier in cv::ml::StatModel (trait) (cv_ml_StatModel_isClassifier_const)

--- Incoming ---
[   'cv.ml.StatModel.train',
    'bool',
    [],
    [['const Ptr<TrainData>&', 'trainData', '', []], ['int', 'flags', '0', []]],
    None,
    '@brief Trains the statistical model\n'
    '\n'
    '@param trainData training data that can be loaded from file using '
    'TrainData::loadFromCSV or\n'
    'created with TrainData::create.\n'
    '@param flags optional flags, depending on the model. Some of the models '
    'can be updated with the\n'
    'new training samples, not completely overwritten (such as '
    'NormalBayesClassifier or ANN_MLP).']
parse_name: cv.ml.StatModel.train with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::train namespace:cv::ml classpath:StatModel classname:StatModel name:train
register (method) train in cv::ml::StatModel (trait) (cv_ml_StatModel_train_PtrOfTrainData_int)

--- Incoming ---
[   'cv.ml.StatModel.train',
    'bool',
    [],
    [   ['InputArray', 'samples', '', []],
        ['int', 'layout', '', []],
        ['InputArray', 'responses', '', []]],
    None,
    '@brief Trains the statistical model\n'
    '\n'
    '@param samples training samples\n'
    '@param layout See ml::SampleTypes.\n'
    '@param responses vector of responses associated with the training '
    'samples.']
parse_name: cv.ml.StatModel.train with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::train namespace:cv::ml classpath:StatModel classname:StatModel name:train
register (method) train in cv::ml::StatModel (trait) (cv_ml_StatModel_train__InputArray_int__InputArray)

--- Incoming ---
[   'cv.ml.StatModel.calcError',
    'float',
    ['/C'],
    [   ['const Ptr<TrainData>&', 'data', '', []],
        ['bool', 'test', '', []],
        ['OutputArray', 'resp', '', []]],
    None,
    '@brief Computes error on the training or test dataset\n'
    '\n'
    '@param data the training data\n'
    '@param test if true, the error is computed over the test subset of the '
    "data, otherwise it's\n"
    'computed over the training subset of the data. Please note that if you '
    'loaded a completely\n'
    'different dataset to evaluate already trained classifier, you will '
    'probably want not to set\n'
    'the test subset at all with TrainData::setTrainTestSplitRatio and specify '
    'test=false, so\n'
    'that the error is computed for the whole new set. Yes, this sounds a bit '
    'confusing.\n'
    '@param resp the optional output responses.\n'
    '\n'
    'The method uses StatModel::predict to compute the error. For regression '
    'models the error is\n'
    'computed as RMS, for classifiers - as a percent of missclassified samples '
    '(0%-100%).']
parse_name: cv.ml.StatModel.calcError with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::calcError namespace:cv::ml classpath:StatModel classname:StatModel name:calcError
register (method) calcError in cv::ml::StatModel (trait) (cv_ml_StatModel_calcError_const_PtrOfTrainData_bool__OutputArray)

--- Incoming ---
[   'cv.ml.StatModel.predict',
    'float',
    ['/A', '/C'],
    [   ['InputArray', 'samples', '', []],
        ['OutputArray', 'results', 'noArray()', []],
        ['int', 'flags', '0', []]],
    None,
    '@brief Predicts response(s) for the provided sample(s)\n'
    '\n'
    '@param samples The input samples, floating-point matrix\n'
    '@param results The optional output matrix of results.\n'
    '@param flags The optional flags, model-dependent. See '
    'cv::ml::StatModel::Flags.']
parse_name: cv.ml.StatModel.predict with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::predict namespace:cv::ml classpath:StatModel classname:StatModel name:predict
register (method) predict in cv::ml::StatModel (trait) (cv_ml_StatModel_predict_const__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.ml.StatModel.Ptr < _Tp > train',
    'template<typename _Tp> static Ptr<_Tp>',
    [],
    [['const Ptr<TrainData>&', 'data', '', []], ['int', 'flags', '0', []]],
    None,
    '@brief Create and train model with default parameters\n'
    '\n'
    'The class must implement static `create()` method with no parameters or '
    'with all default parameter values']
parse_name: cv.ml.StatModel.Ptr < _Tp > train with ['cv', 'cv::ml'] -> fullname:cv::ml::StatModel::Ptr < _Tp > train namespace:cv::ml classpath:StatModel classname:StatModel name:Ptr < _Tp > train
Registering an unknown type: template<typename _Tp> static Ptr<_Tp>
register (method) Ptr < _Tp > train in cv::ml::StatModel (trait) (cv_ml_StatModel_Ptr_<__Tp_>_train_PtrOfTrainData_int)

--- Incoming ---
[   'class cv.ml.NormalBayesClassifier',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '@brief Bayes classifier for normally distributed data.\n'
    '\n'
    '@sa @ref ml_intro_bayes']
parse_name: class cv.ml.NormalBayesClassifier with ['cv', 'cv::ml'] -> fullname:cv::ml::NormalBayesClassifier namespace:cv::ml classpath: classname: name:NormalBayesClassifier
register class cv::ml::NormalBayesClassifier (['class cv.ml.NormalBayesClassifier', ': cv::ml::StatModel', [], [], None, '@brief Bayes classifier for normally distributed data.\n\n@sa @ref ml_intro_bayes']) impl:cv::ml::StatModel

--- Incoming ---
[   'cv.ml.NormalBayesClassifier.predictProb',
    'float',
    ['/A', '/C'],
    [   ['InputArray', 'inputs', '', []],
        ['OutputArray', 'outputs', '', []],
        ['OutputArray', 'outputProbs', '', []],
        ['int', 'flags', '0', []]],
    None,
    '@brief Predicts the response for sample(s).\n'
    '\n'
    'The method estimates the most probable classes for input vectors. Input '
    'vectors (one or more)\n'
    'are stored as rows of the matrix inputs. In case of multiple input '
    'vectors, there should be one\n'
    'output vector outputs. The predicted class for a single input vector is '
    'returned by the method.\n'
    'The vector outputProbs contains the output probabilities corresponding to '
    'each element of\n'
    'result.']
parse_name: cv.ml.NormalBayesClassifier.predictProb with ['cv', 'cv::ml'] -> fullname:cv::ml::NormalBayesClassifier::predictProb namespace:cv::ml classpath:NormalBayesClassifier classname:NormalBayesClassifier name:predictProb
register (method) predictProb in cv::ml::NormalBayesClassifier (trait) (cv_ml_NormalBayesClassifier_predictProb_const__InputArray__OutputArray__OutputArray_int)

--- Incoming ---
[   'cv.ml.NormalBayesClassifier.create',
    'Ptr<NormalBayesClassifier>',
    ['/S'],
    [],
    None,
    'Creates empty model\n'
    'Use StatModel::train to train the model after creation.']
parse_name: cv.ml.NormalBayesClassifier.create with ['cv', 'cv::ml'] -> fullname:cv::ml::NormalBayesClassifier::create namespace:cv::ml classpath:NormalBayesClassifier classname:NormalBayesClassifier name:create
register (method) create in cv::ml::NormalBayesClassifier (trait) (cv_ml_NormalBayesClassifier_create)

--- Incoming ---
[   'cv.ml.NormalBayesClassifier.load',
    'Ptr<NormalBayesClassifier>',
    ['/S'],
    [   ['const String&', 'filepath', '', []],
        ['const String&', 'nodeName', 'String()', []]],
    None,
    '@brief Loads and creates a serialized NormalBayesClassifier from a file\n'
    '*\n'
    '* Use NormalBayesClassifier::save to serialize and store an '
    'NormalBayesClassifier to disk.\n'
    '* Load the NormalBayesClassifier from this file again, by calling this '
    'function with the path to the file.\n'
    '* Optionally specify the node for the file containing the classifier\n'
    '*\n'
    '* @param filepath path to serialized NormalBayesClassifier\n'
    '* @param nodeName name of node containing the classifier']
parse_name: cv.ml.NormalBayesClassifier.load with ['cv', 'cv::ml'] -> fullname:cv::ml::NormalBayesClassifier::load namespace:cv::ml classpath:NormalBayesClassifier classname:NormalBayesClassifier name:load
register (method) load in cv::ml::NormalBayesClassifier (trait) (cv_ml_NormalBayesClassifier_load_String_String)

--- Incoming ---
[   'class cv.ml.KNearest',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '@brief The class implements K-Nearest Neighbors model\n'
    '\n'
    '@sa @ref ml_intro_knn']
parse_name: class cv.ml.KNearest with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest namespace:cv::ml classpath: classname: name:KNearest
register class cv::ml::KNearest (['class cv.ml.KNearest', ': cv::ml::StatModel', [], [], None, '@brief The class implements K-Nearest Neighbors model\n\n@sa @ref ml_intro_knn']) impl:cv::ml::StatModel

--- Incoming ---
[   'cv.ml.KNearest.getDefaultK',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setDefaultK']
parse_name: cv.ml.KNearest.getDefaultK with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::getDefaultK namespace:cv::ml classpath:KNearest classname:KNearest name:getDefaultK
register (method) getDefaultK in cv::ml::KNearest (trait) (cv_ml_KNearest_getDefaultK_const)

--- Incoming ---
[   'cv.ml.KNearest.setDefaultK',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getDefaultK @see getDefaultK']
parse_name: cv.ml.KNearest.setDefaultK with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::setDefaultK namespace:cv::ml classpath:KNearest classname:KNearest name:setDefaultK
register (method) setDefaultK in cv::ml::KNearest (trait) (cv_ml_KNearest_setDefaultK_int)

--- Incoming ---
[   'cv.ml.KNearest.getIsClassifier',
    'bool',
    ['/A', '/C'],
    [],
    None,
    '@see setIsClassifier']
parse_name: cv.ml.KNearest.getIsClassifier with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::getIsClassifier namespace:cv::ml classpath:KNearest classname:KNearest name:getIsClassifier
register (method) getIsClassifier in cv::ml::KNearest (trait) (cv_ml_KNearest_getIsClassifier_const)

--- Incoming ---
[   'cv.ml.KNearest.setIsClassifier',
    'void',
    ['/A'],
    [['bool', 'val', '', []]],
    None,
    '@copybrief getIsClassifier @see getIsClassifier']
parse_name: cv.ml.KNearest.setIsClassifier with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::setIsClassifier namespace:cv::ml classpath:KNearest classname:KNearest name:setIsClassifier
register (method) setIsClassifier in cv::ml::KNearest (trait) (cv_ml_KNearest_setIsClassifier_bool)

--- Incoming ---
['cv.ml.KNearest.getEmax', 'int', ['/A', '/C'], [], None, '@see setEmax']
parse_name: cv.ml.KNearest.getEmax with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::getEmax namespace:cv::ml classpath:KNearest classname:KNearest name:getEmax
register (method) getEmax in cv::ml::KNearest (trait) (cv_ml_KNearest_getEmax_const)

--- Incoming ---
[   'cv.ml.KNearest.setEmax',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getEmax @see getEmax']
parse_name: cv.ml.KNearest.setEmax with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::setEmax namespace:cv::ml classpath:KNearest classname:KNearest name:setEmax
register (method) setEmax in cv::ml::KNearest (trait) (cv_ml_KNearest_setEmax_int)

--- Incoming ---
[   'cv.ml.KNearest.getAlgorithmType',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setAlgorithmType']
parse_name: cv.ml.KNearest.getAlgorithmType with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::getAlgorithmType namespace:cv::ml classpath:KNearest classname:KNearest name:getAlgorithmType
register (method) getAlgorithmType in cv::ml::KNearest (trait) (cv_ml_KNearest_getAlgorithmType_const)

--- Incoming ---
[   'cv.ml.KNearest.setAlgorithmType',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getAlgorithmType @see getAlgorithmType']
parse_name: cv.ml.KNearest.setAlgorithmType with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::setAlgorithmType namespace:cv::ml classpath:KNearest classname:KNearest name:setAlgorithmType
register (method) setAlgorithmType in cv::ml::KNearest (trait) (cv_ml_KNearest_setAlgorithmType_int)

--- Incoming ---
[   'cv.ml.KNearest.findNearest',
    'float',
    ['/A', '/C'],
    [   ['InputArray', 'samples', '', []],
        ['int', 'k', '', []],
        ['OutputArray', 'results', '', []],
        ['OutputArray', 'neighborResponses', 'noArray()', []],
        ['OutputArray', 'dist', 'noArray()', []]],
    None,
    '@brief Finds the neighbors and predicts responses for input vectors.\n'
    '\n'
    '@param samples Input samples stored by rows. It is a single-precision '
    'floating-point matrix of\n'
    '`<number_of_samples> * k` size.\n'
    '@param k Number of used nearest neighbors. Should be greater than 1.\n'
    '@param results Vector with results of prediction (regression or '
    'classification) for each input\n'
    'sample. It is a single-precision floating-point vector with '
    '`<number_of_samples>` elements.\n'
    '@param neighborResponses Optional output values for corresponding '
    'neighbors. It is a single-\n'
    'precision floating-point matrix of `<number_of_samples> * k` size.\n'
    '@param dist Optional output distances from the input vectors to the '
    'corresponding neighbors. It\n'
    'is a single-precision floating-point matrix of `<number_of_samples> * k` '
    'size.\n'
    '\n'
    'For each input vector (a row of the matrix samples), the method finds the '
    'k nearest neighbors.\n'
    'In case of regression, the predicted result is a mean value of the '
    "particular vector's neighbor\n"
    'responses. In case of classification, the class is determined by voting.\n'
    '\n'
    'For each input vector, the neighbors are sorted by their distances to the '
    'vector.\n'
    '\n'
    'In case of C++ interface you can use output pointers to empty matrices '
    'and the function will\n'
    'allocate memory itself.\n'
    '\n'
    'If only a single input vector is passed, all output matrices are optional '
    'and the predicted\n'
    'value is returned by the method.\n'
    '\n'
    'The function is parallelized with the TBB library.']
parse_name: cv.ml.KNearest.findNearest with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::findNearest namespace:cv::ml classpath:KNearest classname:KNearest name:findNearest
register (method) findNearest in cv::ml::KNearest (trait) (cv_ml_KNearest_findNearest_const__InputArray_int__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'enum cv.ml.KNearest.Types',
    '',
    [],
    [   ['const cv.ml.KNearest.BRUTE_FORCE', '1', [], [], None, ''],
        ['const cv.ml.KNearest.KDTREE', '2', [], [], None, '']],
    None,
    '@brief Implementations of KNearest algorithm']
parse_name: const cv.ml.KNearest.BRUTE_FORCE with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::BRUTE_FORCE namespace:cv::ml classpath:KNearest classname:KNearest name:BRUTE_FORCE
parse_name: const cv.ml.KNearest.KDTREE with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::KDTREE namespace:cv::ml classpath:KNearest classname:KNearest name:KDTREE
parse_name: enum cv.ml.KNearest.Types with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::Types namespace:cv::ml classpath:KNearest classname:KNearest name:Types
parse_name: const cv.ml.KNearest.BRUTE_FORCE with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::BRUTE_FORCE namespace:cv::ml classpath:KNearest classname:KNearest name:BRUTE_FORCE
parse_name: const cv.ml.KNearest.KDTREE with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::KDTREE namespace:cv::ml classpath:KNearest classname:KNearest name:KDTREE

--- Incoming ---
[   'cv.ml.KNearest.create',
    'Ptr<KNearest>',
    ['/S'],
    [],
    None,
    '@brief Creates the empty model\n'
    '\n'
    'The static method creates empty %KNearest classifier. It should be then '
    'trained using StatModel::train method.']
parse_name: cv.ml.KNearest.create with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::create namespace:cv::ml classpath:KNearest classname:KNearest name:create
register (method) create in cv::ml::KNearest (trait) (cv_ml_KNearest_create)

--- Incoming ---
[   'cv.ml.KNearest.load',
    'Ptr<KNearest>',
    ['/S'],
    [['const String&', 'filepath', '', []]],
    None,
    '@brief Loads and creates a serialized knearest from a file\n'
    '*\n'
    '* Use KNearest::save to serialize and store an KNearest to disk.\n'
    '* Load the KNearest from this file again, by calling this function with '
    'the path to the file.\n'
    '*\n'
    '* @param filepath path to serialized KNearest']
parse_name: cv.ml.KNearest.load with ['cv', 'cv::ml'] -> fullname:cv::ml::KNearest::load namespace:cv::ml classpath:KNearest classname:KNearest name:load
register (method) load in cv::ml::KNearest (trait) (cv_ml_KNearest_load_String)

--- Incoming ---
[   'class cv.ml.SVM',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '@brief Support Vector Machines.\n\n@sa @ref ml_intro_svm']
parse_name: class cv.ml.SVM with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM namespace:cv::ml classpath: classname: name:SVM
register class cv::ml::SVM (['class cv.ml.SVM', ': cv::ml::StatModel', [], [], None, '@brief Support Vector Machines.\n\n@sa @ref ml_intro_svm']) impl:cv::ml::StatModel

--- Incoming ---
['class cv.ml.SVM.Kernel', ': cv::Algorithm', [], [], None, '']
parse_name: class cv.ml.SVM.Kernel with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::Kernel namespace:cv::ml classpath:SVM classname:SVM name:Kernel
register class cv::ml::SVM::Kernel (['class cv.ml.SVM.Kernel', ': cv::Algorithm', [], [], None, '']) impl:cv::Algorithm

--- Incoming ---
['cv.ml.SVM.Kernel.getType', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.ml.SVM.Kernel.getType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::Kernel::getType namespace:cv::ml classpath:SVM::Kernel classname:Kernel name:getType
register (method) getType in cv::ml::SVM::Kernel (trait) (cv_ml_SVM_Kernel_getType_const)

--- Incoming ---
[   'cv.ml.SVM.Kernel.calc',
    'void',
    ['/A'],
    [   ['int', 'vcount', '', []],
        ['int', 'n', '', []],
        ['const float*', 'vecs', '', []],
        ['const float*', 'another', '', []],
        ['float*', 'results', '', []]],
    None,
    '']
parse_name: cv.ml.SVM.Kernel.calc with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::Kernel::calc namespace:cv::ml classpath:SVM::Kernel classname:Kernel name:calc
register (method) calc in cv::ml::SVM::Kernel (trait) (cv_ml_SVM_Kernel_calc_int_int_const_float_X_const_float_X_float_X)

--- Incoming ---
['cv.ml.SVM.getType', 'int', ['/A', '/C'], [], None, '@see setType']
parse_name: cv.ml.SVM.getType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getType namespace:cv::ml classpath:SVM classname:SVM name:getType
register (method) getType in cv::ml::SVM (trait) (cv_ml_SVM_getType_const)

--- Incoming ---
[   'cv.ml.SVM.setType',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getType @see getType']
parse_name: cv.ml.SVM.setType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setType namespace:cv::ml classpath:SVM classname:SVM name:setType
register (method) setType in cv::ml::SVM (trait) (cv_ml_SVM_setType_int)

--- Incoming ---
['cv.ml.SVM.getGamma', 'double', ['/A', '/C'], [], None, '@see setGamma']
parse_name: cv.ml.SVM.getGamma with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getGamma namespace:cv::ml classpath:SVM classname:SVM name:getGamma
register (method) getGamma in cv::ml::SVM (trait) (cv_ml_SVM_getGamma_const)

--- Incoming ---
[   'cv.ml.SVM.setGamma',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getGamma @see getGamma']
parse_name: cv.ml.SVM.setGamma with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setGamma namespace:cv::ml classpath:SVM classname:SVM name:setGamma
register (method) setGamma in cv::ml::SVM (trait) (cv_ml_SVM_setGamma_double)

--- Incoming ---
['cv.ml.SVM.getCoef0', 'double', ['/A', '/C'], [], None, '@see setCoef0']
parse_name: cv.ml.SVM.getCoef0 with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getCoef0 namespace:cv::ml classpath:SVM classname:SVM name:getCoef0
register (method) getCoef0 in cv::ml::SVM (trait) (cv_ml_SVM_getCoef0_const)

--- Incoming ---
[   'cv.ml.SVM.setCoef0',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getCoef0 @see getCoef0']
parse_name: cv.ml.SVM.setCoef0 with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setCoef0 namespace:cv::ml classpath:SVM classname:SVM name:setCoef0
register (method) setCoef0 in cv::ml::SVM (trait) (cv_ml_SVM_setCoef0_double)

--- Incoming ---
['cv.ml.SVM.getDegree', 'double', ['/A', '/C'], [], None, '@see setDegree']
parse_name: cv.ml.SVM.getDegree with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getDegree namespace:cv::ml classpath:SVM classname:SVM name:getDegree
register (method) getDegree in cv::ml::SVM (trait) (cv_ml_SVM_getDegree_const)

--- Incoming ---
[   'cv.ml.SVM.setDegree',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getDegree @see getDegree']
parse_name: cv.ml.SVM.setDegree with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setDegree namespace:cv::ml classpath:SVM classname:SVM name:setDegree
register (method) setDegree in cv::ml::SVM (trait) (cv_ml_SVM_setDegree_double)

--- Incoming ---
['cv.ml.SVM.getC', 'double', ['/A', '/C'], [], None, '@see setC']
parse_name: cv.ml.SVM.getC with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getC namespace:cv::ml classpath:SVM classname:SVM name:getC
register (method) getC in cv::ml::SVM (trait) (cv_ml_SVM_getC_const)

--- Incoming ---
[   'cv.ml.SVM.setC',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getC @see getC']
parse_name: cv.ml.SVM.setC with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setC namespace:cv::ml classpath:SVM classname:SVM name:setC
register (method) setC in cv::ml::SVM (trait) (cv_ml_SVM_setC_double)

--- Incoming ---
['cv.ml.SVM.getNu', 'double', ['/A', '/C'], [], None, '@see setNu']
parse_name: cv.ml.SVM.getNu with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getNu namespace:cv::ml classpath:SVM classname:SVM name:getNu
register (method) getNu in cv::ml::SVM (trait) (cv_ml_SVM_getNu_const)

--- Incoming ---
[   'cv.ml.SVM.setNu',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getNu @see getNu']
parse_name: cv.ml.SVM.setNu with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setNu namespace:cv::ml classpath:SVM classname:SVM name:setNu
register (method) setNu in cv::ml::SVM (trait) (cv_ml_SVM_setNu_double)

--- Incoming ---
['cv.ml.SVM.getP', 'double', ['/A', '/C'], [], None, '@see setP']
parse_name: cv.ml.SVM.getP with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getP namespace:cv::ml classpath:SVM classname:SVM name:getP
register (method) getP in cv::ml::SVM (trait) (cv_ml_SVM_getP_const)

--- Incoming ---
[   'cv.ml.SVM.setP',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getP @see getP']
parse_name: cv.ml.SVM.setP with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setP namespace:cv::ml classpath:SVM classname:SVM name:setP
register (method) setP in cv::ml::SVM (trait) (cv_ml_SVM_setP_double)

--- Incoming ---
[   'cv.ml.SVM.getClassWeights',
    'cv::Mat',
    ['/A', '/C'],
    [],
    None,
    '@see setClassWeights']
parse_name: cv.ml.SVM.getClassWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getClassWeights namespace:cv::ml classpath:SVM classname:SVM name:getClassWeights
register (method) getClassWeights in cv::ml::SVM (trait) (cv_ml_SVM_getClassWeights_const)

--- Incoming ---
[   'cv.ml.SVM.setClassWeights',
    'void',
    ['/A'],
    [['const cv::Mat &', 'val', '', []]],
    None,
    '@copybrief getClassWeights @see getClassWeights']
parse_name: cv.ml.SVM.setClassWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setClassWeights namespace:cv::ml classpath:SVM classname:SVM name:setClassWeights
register (method) setClassWeights in cv::ml::SVM (trait) (cv_ml_SVM_setClassWeights_Mat)

--- Incoming ---
[   'cv.ml.SVM.getTermCriteria',
    'cv::TermCriteria',
    ['/A', '/C'],
    [],
    None,
    '@see setTermCriteria']
parse_name: cv.ml.SVM.getTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getTermCriteria namespace:cv::ml classpath:SVM classname:SVM name:getTermCriteria
register (method) getTermCriteria in cv::ml::SVM (trait) (cv_ml_SVM_getTermCriteria_const)

--- Incoming ---
[   'cv.ml.SVM.setTermCriteria',
    'void',
    ['/A'],
    [['const cv::TermCriteria &', 'val', '', []]],
    None,
    '@copybrief getTermCriteria @see getTermCriteria']
parse_name: cv.ml.SVM.setTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setTermCriteria namespace:cv::ml classpath:SVM classname:SVM name:setTermCriteria
register (method) setTermCriteria in cv::ml::SVM (trait) (cv_ml_SVM_setTermCriteria_TermCriteria)

--- Incoming ---
[   'cv.ml.SVM.getKernelType',
    'int',
    ['/A', '/C'],
    [],
    None,
    'Type of a %SVM kernel.\nSee SVM::KernelTypes. Default value is SVM::RBF.']
parse_name: cv.ml.SVM.getKernelType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getKernelType namespace:cv::ml classpath:SVM classname:SVM name:getKernelType
register (method) getKernelType in cv::ml::SVM (trait) (cv_ml_SVM_getKernelType_const)

--- Incoming ---
[   'cv.ml.SVM.setKernel',
    'void',
    ['/A'],
    [['int', 'kernelType', '', []]],
    None,
    'Initialize with one of predefined kernels.\nSee SVM::KernelTypes.']
parse_name: cv.ml.SVM.setKernel with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setKernel namespace:cv::ml classpath:SVM classname:SVM name:setKernel
register (method) setKernel in cv::ml::SVM (trait) (cv_ml_SVM_setKernel_int)

--- Incoming ---
[   'cv.ml.SVM.setCustomKernel',
    'void',
    ['/A'],
    [['const Ptr<Kernel> &', '_kernel', '', []]],
    None,
    'Initialize with custom kernel.\n'
    'See SVM::Kernel class for implementation details']
parse_name: cv.ml.SVM.setCustomKernel with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::setCustomKernel namespace:cv::ml classpath:SVM classname:SVM name:setCustomKernel
register (method) setCustomKernel in cv::ml::SVM (trait) (cv_ml_SVM_setCustomKernel_PtrOfKernel)

--- Incoming ---
[   'enum cv.ml.SVM.Types',
    '',
    [],
    [   ['const cv.ml.SVM.C_SVC', '100', [], [], None, ''],
        ['const cv.ml.SVM.NU_SVC', '101', [], [], None, ''],
        ['const cv.ml.SVM.ONE_CLASS', '102', [], [], None, ''],
        ['const cv.ml.SVM.EPS_SVR', '103', [], [], None, ''],
        ['const cv.ml.SVM.NU_SVR', '104', [], [], None, '']],
    None,
    '%SVM type']
parse_name: const cv.ml.SVM.C_SVC with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::C_SVC namespace:cv::ml classpath:SVM classname:SVM name:C_SVC
parse_name: const cv.ml.SVM.NU_SVC with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::NU_SVC namespace:cv::ml classpath:SVM classname:SVM name:NU_SVC
parse_name: const cv.ml.SVM.ONE_CLASS with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::ONE_CLASS namespace:cv::ml classpath:SVM classname:SVM name:ONE_CLASS
parse_name: const cv.ml.SVM.EPS_SVR with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::EPS_SVR namespace:cv::ml classpath:SVM classname:SVM name:EPS_SVR
parse_name: const cv.ml.SVM.NU_SVR with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::NU_SVR namespace:cv::ml classpath:SVM classname:SVM name:NU_SVR
parse_name: enum cv.ml.SVM.Types with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::Types namespace:cv::ml classpath:SVM classname:SVM name:Types
parse_name: const cv.ml.SVM.C_SVC with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::C_SVC namespace:cv::ml classpath:SVM classname:SVM name:C_SVC
parse_name: const cv.ml.SVM.NU_SVC with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::NU_SVC namespace:cv::ml classpath:SVM classname:SVM name:NU_SVC
parse_name: const cv.ml.SVM.ONE_CLASS with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::ONE_CLASS namespace:cv::ml classpath:SVM classname:SVM name:ONE_CLASS
parse_name: const cv.ml.SVM.EPS_SVR with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::EPS_SVR namespace:cv::ml classpath:SVM classname:SVM name:EPS_SVR
parse_name: const cv.ml.SVM.NU_SVR with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::NU_SVR namespace:cv::ml classpath:SVM classname:SVM name:NU_SVR

--- Incoming ---
[   'enum cv.ml.SVM.KernelTypes',
    '',
    [],
    [   ['const cv.ml.SVM.CUSTOM', '-1', [], [], None, ''],
        ['const cv.ml.SVM.LINEAR', '0', [], [], None, ''],
        ['const cv.ml.SVM.POLY', '1', [], [], None, ''],
        ['const cv.ml.SVM.RBF', '2', [], [], None, ''],
        ['const cv.ml.SVM.SIGMOID', '3', [], [], None, ''],
        ['const cv.ml.SVM.CHI2', '4', [], [], None, ''],
        ['const cv.ml.SVM.INTER', '5', [], [], None, '']],
    None,
    '@brief %SVM kernel type\n'
    '\n'
    'A comparison of different kernels on the following 2D test case with four '
    'classes. Four\n'
    'SVM::C_SVC SVMs have been trained (one against rest) with auto_train. '
    'Evaluation on three\n'
    'different kernels (SVM::CHI2, SVM::INTER, SVM::RBF). The color depicts '
    'the class with max score.\n'
    'Bright means max-score \\> 0, dark means max-score \\< 0.\n'
    '![image](pics/SVM_Comparison.png)']
parse_name: const cv.ml.SVM.CUSTOM with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::CUSTOM namespace:cv::ml classpath:SVM classname:SVM name:CUSTOM
parse_name: const cv.ml.SVM.LINEAR with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::LINEAR namespace:cv::ml classpath:SVM classname:SVM name:LINEAR
parse_name: const cv.ml.SVM.POLY with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::POLY namespace:cv::ml classpath:SVM classname:SVM name:POLY
parse_name: const cv.ml.SVM.RBF with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::RBF namespace:cv::ml classpath:SVM classname:SVM name:RBF
parse_name: const cv.ml.SVM.SIGMOID with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::SIGMOID namespace:cv::ml classpath:SVM classname:SVM name:SIGMOID
parse_name: const cv.ml.SVM.CHI2 with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::CHI2 namespace:cv::ml classpath:SVM classname:SVM name:CHI2
parse_name: const cv.ml.SVM.INTER with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::INTER namespace:cv::ml classpath:SVM classname:SVM name:INTER
parse_name: enum cv.ml.SVM.KernelTypes with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::KernelTypes namespace:cv::ml classpath:SVM classname:SVM name:KernelTypes
parse_name: const cv.ml.SVM.CUSTOM with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::CUSTOM namespace:cv::ml classpath:SVM classname:SVM name:CUSTOM
parse_name: const cv.ml.SVM.LINEAR with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::LINEAR namespace:cv::ml classpath:SVM classname:SVM name:LINEAR
parse_name: const cv.ml.SVM.POLY with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::POLY namespace:cv::ml classpath:SVM classname:SVM name:POLY
parse_name: const cv.ml.SVM.RBF with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::RBF namespace:cv::ml classpath:SVM classname:SVM name:RBF
parse_name: const cv.ml.SVM.SIGMOID with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::SIGMOID namespace:cv::ml classpath:SVM classname:SVM name:SIGMOID
parse_name: const cv.ml.SVM.CHI2 with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::CHI2 namespace:cv::ml classpath:SVM classname:SVM name:CHI2
parse_name: const cv.ml.SVM.INTER with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::INTER namespace:cv::ml classpath:SVM classname:SVM name:INTER

--- Incoming ---
[   'enum cv.ml.SVM.ParamTypes',
    '',
    [],
    [   ['const cv.ml.SVM.C', '0', [], [], None, ''],
        ['const cv.ml.SVM.GAMMA', '1', [], [], None, ''],
        ['const cv.ml.SVM.P', '2', [], [], None, ''],
        ['const cv.ml.SVM.NU', '3', [], [], None, ''],
        ['const cv.ml.SVM.COEF', '4', [], [], None, ''],
        ['const cv.ml.SVM.DEGREE', '5', [], [], None, '']],
    None,
    '%SVM params type']
parse_name: const cv.ml.SVM.C with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::C namespace:cv::ml classpath:SVM classname:SVM name:C
parse_name: const cv.ml.SVM.GAMMA with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::GAMMA namespace:cv::ml classpath:SVM classname:SVM name:GAMMA
parse_name: const cv.ml.SVM.P with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::P namespace:cv::ml classpath:SVM classname:SVM name:P
parse_name: const cv.ml.SVM.NU with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::NU namespace:cv::ml classpath:SVM classname:SVM name:NU
parse_name: const cv.ml.SVM.COEF with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::COEF namespace:cv::ml classpath:SVM classname:SVM name:COEF
parse_name: const cv.ml.SVM.DEGREE with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::DEGREE namespace:cv::ml classpath:SVM classname:SVM name:DEGREE
parse_name: enum cv.ml.SVM.ParamTypes with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::ParamTypes namespace:cv::ml classpath:SVM classname:SVM name:ParamTypes
parse_name: const cv.ml.SVM.C with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::C namespace:cv::ml classpath:SVM classname:SVM name:C
parse_name: const cv.ml.SVM.GAMMA with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::GAMMA namespace:cv::ml classpath:SVM classname:SVM name:GAMMA
parse_name: const cv.ml.SVM.P with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::P namespace:cv::ml classpath:SVM classname:SVM name:P
parse_name: const cv.ml.SVM.NU with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::NU namespace:cv::ml classpath:SVM classname:SVM name:NU
parse_name: const cv.ml.SVM.COEF with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::COEF namespace:cv::ml classpath:SVM classname:SVM name:COEF
parse_name: const cv.ml.SVM.DEGREE with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::DEGREE namespace:cv::ml classpath:SVM classname:SVM name:DEGREE

--- Incoming ---
[   'cv.ml.SVM.trainAuto',
    'bool',
    ['/A'],
    [   ['const Ptr<TrainData>&', 'data', '', []],
        ['int', 'kFold', '10', []],
        ['ParamGrid', 'Cgrid', 'getDefaultGrid(C)', []],
        ['ParamGrid', 'gammaGrid', 'getDefaultGrid(GAMMA)', []],
        ['ParamGrid', 'pGrid', 'getDefaultGrid(P)', []],
        ['ParamGrid', 'nuGrid', 'getDefaultGrid(NU)', []],
        ['ParamGrid', 'coeffGrid', 'getDefaultGrid(COEF)', []],
        ['ParamGrid', 'degreeGrid', 'getDefaultGrid(DEGREE)', []],
        ['bool', 'balanced', 'false', []]],
    None,
    '@brief Trains an %SVM with optimal parameters.\n'
    '\n'
    '@param data the training data that can be constructed using '
    'TrainData::create or\n'
    'TrainData::loadFromCSV.\n'
    '@param kFold Cross-validation parameter. The training set is divided into '
    'kFold subsets. One\n'
    'subset is used to test the model, the others form the train set. So, the '
    '%SVM algorithm is\n'
    'executed kFold times.\n'
    '@param Cgrid grid for C\n'
    '@param gammaGrid grid for gamma\n'
    '@param pGrid grid for p\n'
    '@param nuGrid grid for nu\n'
    '@param coeffGrid grid for coeff\n'
    '@param degreeGrid grid for degree\n'
    '@param balanced If true and the problem is 2-class classification then '
    'the method creates more\n'
    'balanced cross-validation subsets that is proportions between classes in '
    'subsets are close\n'
    'to such proportion in the whole train dataset.\n'
    '\n'
    'The method trains the %SVM model automatically by choosing the optimal '
    'parameters C, gamma, p,\n'
    'nu, coef0, degree. Parameters are considered optimal when the '
    'cross-validation\n'
    'estimate of the test set error is minimal.\n'
    '\n'
    'If there is no need to optimize a parameter, the corresponding grid step '
    'should be set to any\n'
    'value less than or equal to 1. For example, to avoid optimization in '
    'gamma, set `gammaGrid.step\n'
    '= 0`, `gammaGrid.minVal`, `gamma_grid.maxVal` as arbitrary numbers. In '
    'this case, the value\n'
    '`Gamma` is taken for gamma.\n'
    '\n'
    'And, finally, if the optimization in a parameter is required but the '
    'corresponding grid is\n'
    'unknown, you may call the function SVM::getDefaultGrid. To generate a '
    'grid, for example, for\n'
    'gamma, call `SVM::getDefaultGrid(SVM::GAMMA)`.\n'
    '\n'
    'This function works for the classification (SVM::C_SVC or SVM::NU_SVC) as '
    'well as for the\n'
    'regression (SVM::EPS_SVR or SVM::NU_SVR). If it is SVM::ONE_CLASS, no '
    'optimization is made and\n'
    'the usual %SVM with parameters specified in params is executed.']
parse_name: cv.ml.SVM.trainAuto with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::trainAuto namespace:cv::ml classpath:SVM classname:SVM name:trainAuto
register (method) trainAuto in cv::ml::SVM (trait) (cv_ml_SVM_trainAuto_PtrOfTrainData_int_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_bool)

--- Incoming ---
[   'cv.ml.SVM.trainAuto',
    'bool',
    ['/A'],
    [   ['InputArray', 'samples', '', []],
        ['int', 'layout', '', []],
        ['InputArray', 'responses', '', []],
        ['int', 'kFold', '10', []],
        ['Ptr<ParamGrid>', 'Cgrid', 'SVM::getDefaultGridPtr(SVM::C)', []],
        [   'Ptr<ParamGrid>',
            'gammaGrid',
            'SVM::getDefaultGridPtr(SVM::GAMMA)',
            []],
        ['Ptr<ParamGrid>', 'pGrid', 'SVM::getDefaultGridPtr(SVM::P)', []],
        ['Ptr<ParamGrid>', 'nuGrid', 'SVM::getDefaultGridPtr(SVM::NU)', []],
        [   'Ptr<ParamGrid>',
            'coeffGrid',
            'SVM::getDefaultGridPtr(SVM::COEF)',
            []],
        [   'Ptr<ParamGrid>',
            'degreeGrid',
            'SVM::getDefaultGridPtr(SVM::DEGREE)',
            []],
        ['bool', 'balanced', 'false', []]],
    None,
    '@brief Trains an %SVM with optimal parameters\n'
    '\n'
    '@param samples training samples\n'
    '@param layout See ml::SampleTypes.\n'
    '@param responses vector of responses associated with the training '
    'samples.\n'
    '@param kFold Cross-validation parameter. The training set is divided into '
    'kFold subsets. One\n'
    'subset is used to test the model, the others form the train set. So, the '
    '%SVM algorithm is\n'
    '@param Cgrid grid for C\n'
    '@param gammaGrid grid for gamma\n'
    '@param pGrid grid for p\n'
    '@param nuGrid grid for nu\n'
    '@param coeffGrid grid for coeff\n'
    '@param degreeGrid grid for degree\n'
    '@param balanced If true and the problem is 2-class classification then '
    'the method creates more\n'
    'balanced cross-validation subsets that is proportions between classes in '
    'subsets are close\n'
    'to such proportion in the whole train dataset.\n'
    '\n'
    'The method trains the %SVM model automatically by choosing the optimal '
    'parameters C, gamma, p,\n'
    'nu, coef0, degree. Parameters are considered optimal when the '
    'cross-validation\n'
    'estimate of the test set error is minimal.\n'
    '\n'
    'This function only makes use of SVM::getDefaultGrid for parameter '
    'optimization and thus only\n'
    'offers rudimentary parameter options.\n'
    '\n'
    'This function works for the classification (SVM::C_SVC or SVM::NU_SVC) as '
    'well as for the\n'
    'regression (SVM::EPS_SVR or SVM::NU_SVR). If it is SVM::ONE_CLASS, no '
    'optimization is made and\n'
    'the usual %SVM with parameters specified in params is executed.']
parse_name: cv.ml.SVM.trainAuto with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::trainAuto namespace:cv::ml classpath:SVM classname:SVM name:trainAuto
register (method) trainAuto in cv::ml::SVM (trait) (cv_ml_SVM_trainAuto__InputArray_int__InputArray_int_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_bool)

--- Incoming ---
[   'cv.ml.SVM.getSupportVectors',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Retrieves all the support vectors\n'
    '\n'
    'The method returns all the support vectors as a floating-point matrix, '
    'where support vectors are\n'
    'stored as matrix rows.']
parse_name: cv.ml.SVM.getSupportVectors with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getSupportVectors namespace:cv::ml classpath:SVM classname:SVM name:getSupportVectors
register (method) getSupportVectors in cv::ml::SVM (trait) (cv_ml_SVM_getSupportVectors_const)

--- Incoming ---
[   'cv.ml.SVM.getUncompressedSupportVectors',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Retrieves all the uncompressed support vectors of a linear %SVM\n'
    '\n'
    'The method returns all the uncompressed support vectors of a linear %SVM '
    'that the compressed\n'
    'support vector, used for prediction, was derived from. They are returned '
    'in a floating-point\n'
    'matrix, where the support vectors are stored as matrix rows.']
parse_name: cv.ml.SVM.getUncompressedSupportVectors with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getUncompressedSupportVectors namespace:cv::ml classpath:SVM classname:SVM name:getUncompressedSupportVectors
register (method) getUncompressedSupportVectors in cv::ml::SVM (trait) (cv_ml_SVM_getUncompressedSupportVectors_const)

--- Incoming ---
[   'cv.ml.SVM.getDecisionFunction',
    'double',
    ['/A', '/C'],
    [   ['int', 'i', '', []],
        ['OutputArray', 'alpha', '', []],
        ['OutputArray', 'svidx', '', []]],
    None,
    '@brief Retrieves the decision function\n'
    '\n'
    '@param i the index of the decision function. If the problem solved is '
    'regression, 1-class or\n'
    '2-class classification, then there will be just one decision function and '
    'the index should\n'
    'always be 0. Otherwise, in the case of N-class classification, there will '
    'be \\f$N(N-1)/2\\f$\n'
    'decision functions.\n'
    '@param alpha the optional output vector for weights, corresponding to '
    'different support vectors.\n'
    "In the case of linear %SVM all the alpha's will be 1's.\n"
    '@param svidx the optional output vector of indices of support vectors '
    'within the matrix of\n'
    'support vectors (which can be retrieved by SVM::getSupportVectors). In '
    'the case of linear\n'
    '%SVM each decision function consists of a single "compressed" support '
    'vector.\n'
    '\n'
    'The method returns rho parameter of the decision function, a scalar '
    'subtracted from the weighted\n'
    'sum of kernel responses.']
parse_name: cv.ml.SVM.getDecisionFunction with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getDecisionFunction namespace:cv::ml classpath:SVM classname:SVM name:getDecisionFunction
register (method) getDecisionFunction in cv::ml::SVM (trait) (cv_ml_SVM_getDecisionFunction_const_int__OutputArray__OutputArray)

--- Incoming ---
[   'cv.ml.SVM.getDefaultGrid',
    'ParamGrid',
    ['/S'],
    [['int', 'param_id', '', []]],
    None,
    '@brief Generates a grid for %SVM parameters.\n'
    '\n'
    '@param param_id %SVM parameters IDs that must be one of the '
    'SVM::ParamTypes. The grid is\n'
    'generated for the parameter with this ID.\n'
    '\n'
    'The function generates a grid for the specified parameter of the %SVM '
    'algorithm. The grid may be\n'
    'passed to the function SVM::trainAuto.']
parse_name: cv.ml.SVM.getDefaultGrid with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getDefaultGrid namespace:cv::ml classpath:SVM classname:SVM name:getDefaultGrid
register (method) getDefaultGrid in cv::ml::SVM (trait) (cv_ml_SVM_getDefaultGrid_int)

--- Incoming ---
[   'cv.ml.SVM.getDefaultGridPtr',
    'Ptr<ParamGrid>',
    ['/S'],
    [['int', 'param_id', '', []]],
    None,
    '@brief Generates a grid for %SVM parameters.\n'
    '\n'
    '@param param_id %SVM parameters IDs that must be one of the '
    'SVM::ParamTypes. The grid is\n'
    'generated for the parameter with this ID.\n'
    '\n'
    'The function generates a grid pointer for the specified parameter of the '
    '%SVM algorithm.\n'
    'The grid may be passed to the function SVM::trainAuto.']
parse_name: cv.ml.SVM.getDefaultGridPtr with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::getDefaultGridPtr namespace:cv::ml classpath:SVM classname:SVM name:getDefaultGridPtr
register (method) getDefaultGridPtr in cv::ml::SVM (trait) (cv_ml_SVM_getDefaultGridPtr_int)

--- Incoming ---
[   'cv.ml.SVM.create',
    'Ptr<SVM>',
    ['/S'],
    [],
    None,
    'Creates empty model.\n'
    'Use StatModel::train to train the model. Since %SVM has several '
    'parameters, you may want to\n'
    'find the best parameters for your problem, it can be done with '
    'SVM::trainAuto.']
parse_name: cv.ml.SVM.create with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::create namespace:cv::ml classpath:SVM classname:SVM name:create
register (method) create in cv::ml::SVM (trait) (cv_ml_SVM_create)

--- Incoming ---
[   'cv.ml.SVM.load',
    'Ptr<SVM>',
    ['/S'],
    [['const String&', 'filepath', '', []]],
    None,
    '@brief Loads and creates a serialized svm from a file\n'
    '*\n'
    '* Use SVM::save to serialize and store an SVM to disk.\n'
    '* Load the SVM from this file again, by calling this function with the '
    'path to the file.\n'
    '*\n'
    '* @param filepath path to serialized svm']
parse_name: cv.ml.SVM.load with ['cv', 'cv::ml'] -> fullname:cv::ml::SVM::load namespace:cv::ml classpath:SVM classname:SVM name:load
register (method) load in cv::ml::SVM (trait) (cv_ml_SVM_load_String)

--- Incoming ---
[   'class cv.ml.EM',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '@brief The class implements the Expectation Maximization algorithm.\n'
    '\n'
    '@sa @ref ml_intro_em']
parse_name: class cv.ml.EM with ['cv', 'cv::ml'] -> fullname:cv::ml::EM namespace:cv::ml classpath: classname: name:EM
register class cv::ml::EM (['class cv.ml.EM', ': cv::ml::StatModel', [], [], None, '@brief The class implements the Expectation Maximization algorithm.\n\n@sa @ref ml_intro_em']) impl:cv::ml::StatModel

--- Incoming ---
[   'enum cv.ml.EM.Types',
    '',
    [],
    [   ['const cv.ml.EM.COV_MAT_SPHERICAL', '0', [], [], None, ''],
        ['const cv.ml.EM.COV_MAT_DIAGONAL', '1', [], [], None, ''],
        ['const cv.ml.EM.COV_MAT_GENERIC', '2', [], [], None, ''],
        [   'const cv.ml.EM.COV_MAT_DEFAULT',
            'COV_MAT_DIAGONAL',
            [],
            [],
            None,
            '']],
    None,
    'Type of covariation matrices']
parse_name: const cv.ml.EM.COV_MAT_SPHERICAL with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_SPHERICAL namespace:cv::ml classpath:EM classname:EM name:COV_MAT_SPHERICAL
parse_name: const cv.ml.EM.COV_MAT_DIAGONAL with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_DIAGONAL namespace:cv::ml classpath:EM classname:EM name:COV_MAT_DIAGONAL
parse_name: const cv.ml.EM.COV_MAT_GENERIC with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_GENERIC namespace:cv::ml classpath:EM classname:EM name:COV_MAT_GENERIC
parse_name: const cv.ml.EM.COV_MAT_DEFAULT with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_DEFAULT namespace:cv::ml classpath:EM classname:EM name:COV_MAT_DEFAULT
parse_name: enum cv.ml.EM.Types with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::Types namespace:cv::ml classpath:EM classname:EM name:Types
parse_name: const cv.ml.EM.COV_MAT_SPHERICAL with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_SPHERICAL namespace:cv::ml classpath:EM classname:EM name:COV_MAT_SPHERICAL
parse_name: const cv.ml.EM.COV_MAT_DIAGONAL with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_DIAGONAL namespace:cv::ml classpath:EM classname:EM name:COV_MAT_DIAGONAL
parse_name: const cv.ml.EM.COV_MAT_GENERIC with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_GENERIC namespace:cv::ml classpath:EM classname:EM name:COV_MAT_GENERIC
parse_name: const cv.ml.EM.COV_MAT_DEFAULT with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::COV_MAT_DEFAULT namespace:cv::ml classpath:EM classname:EM name:COV_MAT_DEFAULT

--- Incoming ---
[   'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   ['const cv.ml.EM.DEFAULT_NCLUSTERS', '5', [], [], None, ''],
        ['const cv.ml.EM.DEFAULT_MAX_ITERS', '100', [], [], None, '']],
    None,
    'Default parameters']
parse_name: const cv.ml.EM.DEFAULT_NCLUSTERS with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::DEFAULT_NCLUSTERS namespace:cv::ml classpath:EM classname:EM name:DEFAULT_NCLUSTERS
parse_name: const cv.ml.EM.DEFAULT_MAX_ITERS with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::DEFAULT_MAX_ITERS namespace:cv::ml classpath:EM classname:EM name:DEFAULT_MAX_ITERS

--- Incoming ---
[   'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   ['const cv.ml.EM.START_E_STEP', '1', [], [], None, ''],
        ['const cv.ml.EM.START_M_STEP', '2', [], [], None, ''],
        ['const cv.ml.EM.START_AUTO_STEP', '0', [], [], None, '']],
    None,
    'The initial step']
parse_name: const cv.ml.EM.START_E_STEP with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::START_E_STEP namespace:cv::ml classpath:EM classname:EM name:START_E_STEP
parse_name: const cv.ml.EM.START_M_STEP with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::START_M_STEP namespace:cv::ml classpath:EM classname:EM name:START_M_STEP
parse_name: const cv.ml.EM.START_AUTO_STEP with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::START_AUTO_STEP namespace:cv::ml classpath:EM classname:EM name:START_AUTO_STEP

--- Incoming ---
[   'cv.ml.EM.getClustersNumber',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setClustersNumber']
parse_name: cv.ml.EM.getClustersNumber with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::getClustersNumber namespace:cv::ml classpath:EM classname:EM name:getClustersNumber
register (method) getClustersNumber in cv::ml::EM (trait) (cv_ml_EM_getClustersNumber_const)

--- Incoming ---
[   'cv.ml.EM.setClustersNumber',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getClustersNumber @see getClustersNumber']
parse_name: cv.ml.EM.setClustersNumber with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::setClustersNumber namespace:cv::ml classpath:EM classname:EM name:setClustersNumber
register (method) setClustersNumber in cv::ml::EM (trait) (cv_ml_EM_setClustersNumber_int)

--- Incoming ---
[   'cv.ml.EM.getCovarianceMatrixType',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setCovarianceMatrixType']
parse_name: cv.ml.EM.getCovarianceMatrixType with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::getCovarianceMatrixType namespace:cv::ml classpath:EM classname:EM name:getCovarianceMatrixType
register (method) getCovarianceMatrixType in cv::ml::EM (trait) (cv_ml_EM_getCovarianceMatrixType_const)

--- Incoming ---
[   'cv.ml.EM.setCovarianceMatrixType',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getCovarianceMatrixType @see getCovarianceMatrixType']
parse_name: cv.ml.EM.setCovarianceMatrixType with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::setCovarianceMatrixType namespace:cv::ml classpath:EM classname:EM name:setCovarianceMatrixType
register (method) setCovarianceMatrixType in cv::ml::EM (trait) (cv_ml_EM_setCovarianceMatrixType_int)

--- Incoming ---
[   'cv.ml.EM.getTermCriteria',
    'TermCriteria',
    ['/A', '/C'],
    [],
    None,
    '@see setTermCriteria']
parse_name: cv.ml.EM.getTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::getTermCriteria namespace:cv::ml classpath:EM classname:EM name:getTermCriteria
register (method) getTermCriteria in cv::ml::EM (trait) (cv_ml_EM_getTermCriteria_const)

--- Incoming ---
[   'cv.ml.EM.setTermCriteria',
    'void',
    ['/A'],
    [['const TermCriteria &', 'val', '', []]],
    None,
    '@copybrief getTermCriteria @see getTermCriteria']
parse_name: cv.ml.EM.setTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::setTermCriteria namespace:cv::ml classpath:EM classname:EM name:setTermCriteria
register (method) setTermCriteria in cv::ml::EM (trait) (cv_ml_EM_setTermCriteria_TermCriteria)

--- Incoming ---
[   'cv.ml.EM.getWeights',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns weights of the mixtures\n'
    '\n'
    'Returns vector with the number of elements equal to the number of '
    'mixtures.']
parse_name: cv.ml.EM.getWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::getWeights namespace:cv::ml classpath:EM classname:EM name:getWeights
register (method) getWeights in cv::ml::EM (trait) (cv_ml_EM_getWeights_const)

--- Incoming ---
[   'cv.ml.EM.getMeans',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns the cluster centers (means of the Gaussian mixture)\n'
    '\n'
    'Returns matrix with the number of rows equal to the number of mixtures '
    'and number of columns\n'
    'equal to the space dimensionality.']
parse_name: cv.ml.EM.getMeans with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::getMeans namespace:cv::ml classpath:EM classname:EM name:getMeans
register (method) getMeans in cv::ml::EM (trait) (cv_ml_EM_getMeans_const)

--- Incoming ---
[   'cv.ml.EM.getCovs',
    'void',
    ['/A', '/C'],
    [['std::vector<Mat>&', 'covs', '', []]],
    None,
    '@brief Returns covariation matrices\n'
    '\n'
    'Returns vector of covariation matrices. Number of matrices is the number '
    'of gaussian mixtures,\n'
    'each matrix is a square floating-point matrix NxN, where N is the space '
    'dimensionality.']
parse_name: cv.ml.EM.getCovs with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::getCovs namespace:cv::ml classpath:EM classname:EM name:getCovs
register (method) getCovs in cv::ml::EM (trait) (cv_ml_EM_getCovs_const_VectorOfMat)

--- Incoming ---
[   'cv.ml.EM.predict',
    'float',
    ['/C'],
    [   ['InputArray', 'samples', '', []],
        ['OutputArray', 'results', 'noArray()', []],
        ['int', 'flags', '0', []]],
    None,
    '@brief Returns posterior probabilities for the provided samples\n'
    '\n'
    '@param samples The input samples, floating-point matrix\n'
    '@param results The optional output \\f$ nSamples \\times nClusters\\f$ '
    'matrix of results. It contains\n'
    'posterior probabilities for each sample from the input\n'
    '@param flags This parameter will be ignored']
parse_name: cv.ml.EM.predict with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::predict namespace:cv::ml classpath:EM classname:EM name:predict
register (method) predict in cv::ml::EM (trait) (cv_ml_EM_predict_const__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.ml.EM.predict2',
    'Vec2d',
    ['/A', '/C'],
    [['InputArray', 'sample', '', []], ['OutputArray', 'probs', '', []]],
    None,
    '@brief Returns a likelihood logarithm value and an index of the most '
    'probable mixture component\n'
    'for the given sample.\n'
    '\n'
    '@param sample A sample for classification. It should be a one-channel '
    'matrix of\n'
    '\\f$1 \\times dims\\f$ or \\f$dims \\times 1\\f$ size.\n'
    '@param probs Optional output matrix that contains posterior probabilities '
    'of each component\n'
    'given the sample. It has \\f$1 \\times nclusters\\f$ size and CV_64FC1 '
    'type.\n'
    '\n'
    'The method returns a two-element double vector. Zero element is a '
    'likelihood logarithm value for\n'
    'the sample. First element is an index of the most probable mixture '
    'component for the given\n'
    'sample.']
parse_name: cv.ml.EM.predict2 with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::predict2 namespace:cv::ml classpath:EM classname:EM name:predict2
register (method) predict2 in cv::ml::EM (trait) (cv_ml_EM_predict2_const__InputArray__OutputArray)

--- Incoming ---
[   'cv.ml.EM.trainEM',
    'bool',
    ['/A'],
    [   ['InputArray', 'samples', '', []],
        ['OutputArray', 'logLikelihoods', 'noArray()', []],
        ['OutputArray', 'labels', 'noArray()', []],
        ['OutputArray', 'probs', 'noArray()', []]],
    None,
    '@brief Estimate the Gaussian mixture parameters from a samples set.\n'
    '\n'
    'This variation starts with Expectation step. Initial values of the model '
    'parameters will be\n'
    'estimated by the k-means algorithm.\n'
    '\n'
    'Unlike many of the ML models, %EM is an unsupervised learning algorithm '
    'and it does not take\n'
    'responses (class labels or function values) as input. Instead, it '
    'computes the *Maximum\n'
    'Likelihood Estimate* of the Gaussian mixture parameters from an input '
    'sample set, stores all the\n'
    'parameters inside the structure: \\f$p_{i,k}\\f$ in probs, \\f$a_k\\f$ in '
    'means , \\f$S_k\\f$ in\n'
    'covs[k], \\f$\\pi_k\\f$ in weights , and optionally computes the output '
    '"class label" for each\n'
    'sample: \\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ '
    '(indices of the most\n'
    'probable mixture component for each sample).\n'
    '\n'
    'The trained model can be used further for prediction, just like any other '
    'classifier. The\n'
    'trained model is similar to the NormalBayesClassifier.\n'
    '\n'
    '@param samples Samples from which the Gaussian mixture model will be '
    'estimated. It should be a\n'
    'one-channel matrix, each row of which is a sample. If the matrix does not '
    'have CV_64F type\n'
    'it will be converted to the inner matrix of such type for the further '
    'computing.\n'
    '@param logLikelihoods The optional output matrix that contains a '
    'likelihood logarithm value for\n'
    'each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type.\n'
    '@param labels The optional output "class label" for each sample:\n'
    '\\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices '
    'of the most probable\n'
    'mixture component for each sample). It has \\f$nsamples \\times 1\\f$ '
    'size and CV_32SC1 type.\n'
    '@param probs The optional output matrix that contains posterior '
    'probabilities of each Gaussian\n'
    'mixture component given the each sample. It has \\f$nsamples \\times '
    'nclusters\\f$ size and\n'
    'CV_64FC1 type.']
parse_name: cv.ml.EM.trainEM with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::trainEM namespace:cv::ml classpath:EM classname:EM name:trainEM
register (method) trainEM in cv::ml::EM (trait) (cv_ml_EM_trainEM__InputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.ml.EM.trainE',
    'bool',
    ['/A'],
    [   ['InputArray', 'samples', '', []],
        ['InputArray', 'means0', '', []],
        ['InputArray', 'covs0', 'noArray()', []],
        ['InputArray', 'weights0', 'noArray()', []],
        ['OutputArray', 'logLikelihoods', 'noArray()', []],
        ['OutputArray', 'labels', 'noArray()', []],
        ['OutputArray', 'probs', 'noArray()', []]],
    None,
    '@brief Estimate the Gaussian mixture parameters from a samples set.\n'
    '\n'
    'This variation starts with Expectation step. You need to provide initial '
    'means \\f$a_k\\f$ of\n'
    'mixture components. Optionally you can pass initial weights '
    '\\f$\\pi_k\\f$ and covariance matrices\n'
    '\\f$S_k\\f$ of mixture components.\n'
    '\n'
    '@param samples Samples from which the Gaussian mixture model will be '
    'estimated. It should be a\n'
    'one-channel matrix, each row of which is a sample. If the matrix does not '
    'have CV_64F type\n'
    'it will be converted to the inner matrix of such type for the further '
    'computing.\n'
    '@param means0 Initial means \\f$a_k\\f$ of mixture components. It is a '
    'one-channel matrix of\n'
    '\\f$nclusters \\times dims\\f$ size. If the matrix does not have CV_64F '
    'type it will be\n'
    'converted to the inner matrix of such type for the further computing.\n'
    '@param covs0 The vector of initial covariance matrices \\f$S_k\\f$ of '
    'mixture components. Each of\n'
    'covariance matrices is a one-channel matrix of \\f$dims \\times dims\\f$ '
    'size. If the matrices\n'
    'do not have CV_64F type they will be converted to the inner matrices of '
    'such type for the\n'
    'further computing.\n'
    '@param weights0 Initial weights \\f$\\pi_k\\f$ of mixture components. It '
    'should be a one-channel\n'
    'floating-point matrix with \\f$1 \\times nclusters\\f$ or \\f$nclusters '
    '\\times 1\\f$ size.\n'
    '@param logLikelihoods The optional output matrix that contains a '
    'likelihood logarithm value for\n'
    'each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type.\n'
    '@param labels The optional output "class label" for each sample:\n'
    '\\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices '
    'of the most probable\n'
    'mixture component for each sample). It has \\f$nsamples \\times 1\\f$ '
    'size and CV_32SC1 type.\n'
    '@param probs The optional output matrix that contains posterior '
    'probabilities of each Gaussian\n'
    'mixture component given the each sample. It has \\f$nsamples \\times '
    'nclusters\\f$ size and\n'
    'CV_64FC1 type.']
parse_name: cv.ml.EM.trainE with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::trainE namespace:cv::ml classpath:EM classname:EM name:trainE
register (method) trainE in cv::ml::EM (trait) (cv_ml_EM_trainE__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.ml.EM.trainM',
    'bool',
    ['/A'],
    [   ['InputArray', 'samples', '', []],
        ['InputArray', 'probs0', '', []],
        ['OutputArray', 'logLikelihoods', 'noArray()', []],
        ['OutputArray', 'labels', 'noArray()', []],
        ['OutputArray', 'probs', 'noArray()', []]],
    None,
    '@brief Estimate the Gaussian mixture parameters from a samples set.\n'
    '\n'
    'This variation starts with Maximization step. You need to provide initial '
    'probabilities\n'
    '\\f$p_{i,k}\\f$ to use this option.\n'
    '\n'
    '@param samples Samples from which the Gaussian mixture model will be '
    'estimated. It should be a\n'
    'one-channel matrix, each row of which is a sample. If the matrix does not '
    'have CV_64F type\n'
    'it will be converted to the inner matrix of such type for the further '
    'computing.\n'
    '@param probs0 the probabilities\n'
    '@param logLikelihoods The optional output matrix that contains a '
    'likelihood logarithm value for\n'
    'each sample. It has \\f$nsamples \\times 1\\f$ size and CV_64FC1 type.\n'
    '@param labels The optional output "class label" for each sample:\n'
    '\\f$\\texttt{labels}_i=\\texttt{arg max}_k(p_{i,k}), i=1..N\\f$ (indices '
    'of the most probable\n'
    'mixture component for each sample). It has \\f$nsamples \\times 1\\f$ '
    'size and CV_32SC1 type.\n'
    '@param probs The optional output matrix that contains posterior '
    'probabilities of each Gaussian\n'
    'mixture component given the each sample. It has \\f$nsamples \\times '
    'nclusters\\f$ size and\n'
    'CV_64FC1 type.']
parse_name: cv.ml.EM.trainM with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::trainM namespace:cv::ml classpath:EM classname:EM name:trainM
register (method) trainM in cv::ml::EM (trait) (cv_ml_EM_trainM__InputArray__InputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.ml.EM.create',
    'Ptr<EM>',
    ['/S'],
    [],
    None,
    'Creates empty %EM model.\n'
    'The model should be trained then using StatModel::train(traindata, flags) '
    'method. Alternatively, you\n'
    'can use one of the EM::train\\* methods or load it from file using '
    'Algorithm::load\\<EM\\>(filename).']
parse_name: cv.ml.EM.create with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::create namespace:cv::ml classpath:EM classname:EM name:create
register (method) create in cv::ml::EM (trait) (cv_ml_EM_create)

--- Incoming ---
[   'cv.ml.EM.load',
    'Ptr<EM>',
    ['/S'],
    [   ['const String&', 'filepath', '', []],
        ['const String&', 'nodeName', 'String()', []]],
    None,
    '@brief Loads and creates a serialized EM from a file\n'
    '*\n'
    '* Use EM::save to serialize and store an EM to disk.\n'
    '* Load the EM from this file again, by calling this function with the '
    'path to the file.\n'
    '* Optionally specify the node for the file containing the classifier\n'
    '*\n'
    '* @param filepath path to serialized EM\n'
    '* @param nodeName name of node containing the classifier']
parse_name: cv.ml.EM.load with ['cv', 'cv::ml'] -> fullname:cv::ml::EM::load namespace:cv::ml classpath:EM classname:EM name:load
register (method) load in cv::ml::EM (trait) (cv_ml_EM_load_String_String)

--- Incoming ---
[   'class cv.ml.DTrees',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '@brief The class represents a single decision tree or a collection of '
    'decision trees.\n'
    '\n'
    'The current public interface of the class allows user to train only a '
    'single decision tree, however\n'
    'the class is capable of storing multiple decision trees and using them '
    'for prediction (by summing\n'
    'responses or using a voting schemes), and the derived from DTrees classes '
    '(such as RTrees and Boost)\n'
    'use this capability to implement decision tree ensembles.\n'
    '\n'
    '@sa @ref ml_intro_trees']
parse_name: class cv.ml.DTrees with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees namespace:cv::ml classpath: classname: name:DTrees
register class cv::ml::DTrees (['class cv.ml.DTrees', ': cv::ml::StatModel', [], [], None, '@brief The class represents a single decision tree or a collection of decision trees.\n\nThe current public interface of the class allows user to train only a single decision tree, however\nthe class is capable of storing multiple decision trees and using them for prediction (by summing\nresponses or using a voting schemes), and the derived from DTrees classes (such as RTrees and Boost)\nuse this capability to implement decision tree ensembles.\n\n@sa @ref ml_intro_trees']) impl:cv::ml::StatModel

--- Incoming ---
[   'enum cv.ml.DTrees.Flags',
    '',
    [],
    [   ['const cv.ml.DTrees.PREDICT_AUTO', '0', [], [], None, ''],
        ['const cv.ml.DTrees.PREDICT_SUM', '(1<<8)', [], [], None, ''],
        ['const cv.ml.DTrees.PREDICT_MAX_VOTE', '(2<<8)', [], [], None, ''],
        ['const cv.ml.DTrees.PREDICT_MASK', '(3<<8)', [], [], None, '']],
    None,
    'Predict options']
parse_name: const cv.ml.DTrees.PREDICT_AUTO with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_AUTO namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_AUTO
parse_name: const cv.ml.DTrees.PREDICT_SUM with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_SUM namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_SUM
parse_name: const cv.ml.DTrees.PREDICT_MAX_VOTE with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_MAX_VOTE namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_MAX_VOTE
parse_name: const cv.ml.DTrees.PREDICT_MASK with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_MASK namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_MASK
parse_name: enum cv.ml.DTrees.Flags with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::Flags namespace:cv::ml classpath:DTrees classname:DTrees name:Flags
parse_name: const cv.ml.DTrees.PREDICT_AUTO with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_AUTO namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_AUTO
parse_name: const cv.ml.DTrees.PREDICT_SUM with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_SUM namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_SUM
parse_name: const cv.ml.DTrees.PREDICT_MAX_VOTE with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_MAX_VOTE namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_MAX_VOTE
parse_name: const cv.ml.DTrees.PREDICT_MASK with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::PREDICT_MASK namespace:cv::ml classpath:DTrees classname:DTrees name:PREDICT_MASK

--- Incoming ---
[   'cv.ml.DTrees.getMaxCategories',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setMaxCategories']
parse_name: cv.ml.DTrees.getMaxCategories with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getMaxCategories namespace:cv::ml classpath:DTrees classname:DTrees name:getMaxCategories
register (method) getMaxCategories in cv::ml::DTrees (trait) (cv_ml_DTrees_getMaxCategories_const)

--- Incoming ---
[   'cv.ml.DTrees.setMaxCategories',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getMaxCategories @see getMaxCategories']
parse_name: cv.ml.DTrees.setMaxCategories with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setMaxCategories namespace:cv::ml classpath:DTrees classname:DTrees name:setMaxCategories
register (method) setMaxCategories in cv::ml::DTrees (trait) (cv_ml_DTrees_setMaxCategories_int)

--- Incoming ---
['cv.ml.DTrees.getMaxDepth', 'int', ['/A', '/C'], [], None, '@see setMaxDepth']
parse_name: cv.ml.DTrees.getMaxDepth with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getMaxDepth namespace:cv::ml classpath:DTrees classname:DTrees name:getMaxDepth
register (method) getMaxDepth in cv::ml::DTrees (trait) (cv_ml_DTrees_getMaxDepth_const)

--- Incoming ---
[   'cv.ml.DTrees.setMaxDepth',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getMaxDepth @see getMaxDepth']
parse_name: cv.ml.DTrees.setMaxDepth with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setMaxDepth namespace:cv::ml classpath:DTrees classname:DTrees name:setMaxDepth
register (method) setMaxDepth in cv::ml::DTrees (trait) (cv_ml_DTrees_setMaxDepth_int)

--- Incoming ---
[   'cv.ml.DTrees.getMinSampleCount',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setMinSampleCount']
parse_name: cv.ml.DTrees.getMinSampleCount with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getMinSampleCount namespace:cv::ml classpath:DTrees classname:DTrees name:getMinSampleCount
register (method) getMinSampleCount in cv::ml::DTrees (trait) (cv_ml_DTrees_getMinSampleCount_const)

--- Incoming ---
[   'cv.ml.DTrees.setMinSampleCount',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getMinSampleCount @see getMinSampleCount']
parse_name: cv.ml.DTrees.setMinSampleCount with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setMinSampleCount namespace:cv::ml classpath:DTrees classname:DTrees name:setMinSampleCount
register (method) setMinSampleCount in cv::ml::DTrees (trait) (cv_ml_DTrees_setMinSampleCount_int)

--- Incoming ---
['cv.ml.DTrees.getCVFolds', 'int', ['/A', '/C'], [], None, '@see setCVFolds']
parse_name: cv.ml.DTrees.getCVFolds with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getCVFolds namespace:cv::ml classpath:DTrees classname:DTrees name:getCVFolds
register (method) getCVFolds in cv::ml::DTrees (trait) (cv_ml_DTrees_getCVFolds_const)

--- Incoming ---
[   'cv.ml.DTrees.setCVFolds',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getCVFolds @see getCVFolds']
parse_name: cv.ml.DTrees.setCVFolds with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setCVFolds namespace:cv::ml classpath:DTrees classname:DTrees name:setCVFolds
register (method) setCVFolds in cv::ml::DTrees (trait) (cv_ml_DTrees_setCVFolds_int)

--- Incoming ---
[   'cv.ml.DTrees.getUseSurrogates',
    'bool',
    ['/A', '/C'],
    [],
    None,
    '@see setUseSurrogates']
parse_name: cv.ml.DTrees.getUseSurrogates with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getUseSurrogates namespace:cv::ml classpath:DTrees classname:DTrees name:getUseSurrogates
register (method) getUseSurrogates in cv::ml::DTrees (trait) (cv_ml_DTrees_getUseSurrogates_const)

--- Incoming ---
[   'cv.ml.DTrees.setUseSurrogates',
    'void',
    ['/A'],
    [['bool', 'val', '', []]],
    None,
    '@copybrief getUseSurrogates @see getUseSurrogates']
parse_name: cv.ml.DTrees.setUseSurrogates with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setUseSurrogates namespace:cv::ml classpath:DTrees classname:DTrees name:setUseSurrogates
register (method) setUseSurrogates in cv::ml::DTrees (trait) (cv_ml_DTrees_setUseSurrogates_bool)

--- Incoming ---
[   'cv.ml.DTrees.getUse1SERule',
    'bool',
    ['/A', '/C'],
    [],
    None,
    '@see setUse1SERule']
parse_name: cv.ml.DTrees.getUse1SERule with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getUse1SERule namespace:cv::ml classpath:DTrees classname:DTrees name:getUse1SERule
register (method) getUse1SERule in cv::ml::DTrees (trait) (cv_ml_DTrees_getUse1SERule_const)

--- Incoming ---
[   'cv.ml.DTrees.setUse1SERule',
    'void',
    ['/A'],
    [['bool', 'val', '', []]],
    None,
    '@copybrief getUse1SERule @see getUse1SERule']
parse_name: cv.ml.DTrees.setUse1SERule with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setUse1SERule namespace:cv::ml classpath:DTrees classname:DTrees name:setUse1SERule
register (method) setUse1SERule in cv::ml::DTrees (trait) (cv_ml_DTrees_setUse1SERule_bool)

--- Incoming ---
[   'cv.ml.DTrees.getTruncatePrunedTree',
    'bool',
    ['/A', '/C'],
    [],
    None,
    '@see setTruncatePrunedTree']
parse_name: cv.ml.DTrees.getTruncatePrunedTree with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getTruncatePrunedTree namespace:cv::ml classpath:DTrees classname:DTrees name:getTruncatePrunedTree
register (method) getTruncatePrunedTree in cv::ml::DTrees (trait) (cv_ml_DTrees_getTruncatePrunedTree_const)

--- Incoming ---
[   'cv.ml.DTrees.setTruncatePrunedTree',
    'void',
    ['/A'],
    [['bool', 'val', '', []]],
    None,
    '@copybrief getTruncatePrunedTree @see getTruncatePrunedTree']
parse_name: cv.ml.DTrees.setTruncatePrunedTree with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setTruncatePrunedTree namespace:cv::ml classpath:DTrees classname:DTrees name:setTruncatePrunedTree
register (method) setTruncatePrunedTree in cv::ml::DTrees (trait) (cv_ml_DTrees_setTruncatePrunedTree_bool)

--- Incoming ---
[   'cv.ml.DTrees.getRegressionAccuracy',
    'float',
    ['/A', '/C'],
    [],
    None,
    '@see setRegressionAccuracy']
parse_name: cv.ml.DTrees.getRegressionAccuracy with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getRegressionAccuracy namespace:cv::ml classpath:DTrees classname:DTrees name:getRegressionAccuracy
register (method) getRegressionAccuracy in cv::ml::DTrees (trait) (cv_ml_DTrees_getRegressionAccuracy_const)

--- Incoming ---
[   'cv.ml.DTrees.setRegressionAccuracy',
    'void',
    ['/A'],
    [['float', 'val', '', []]],
    None,
    '@copybrief getRegressionAccuracy @see getRegressionAccuracy']
parse_name: cv.ml.DTrees.setRegressionAccuracy with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setRegressionAccuracy namespace:cv::ml classpath:DTrees classname:DTrees name:setRegressionAccuracy
register (method) setRegressionAccuracy in cv::ml::DTrees (trait) (cv_ml_DTrees_setRegressionAccuracy_float)

--- Incoming ---
['cv.ml.DTrees.getPriors', 'cv::Mat', ['/A', '/C'], [], None, '@see setPriors']
parse_name: cv.ml.DTrees.getPriors with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getPriors namespace:cv::ml classpath:DTrees classname:DTrees name:getPriors
register (method) getPriors in cv::ml::DTrees (trait) (cv_ml_DTrees_getPriors_const)

--- Incoming ---
[   'cv.ml.DTrees.setPriors',
    'void',
    ['/A'],
    [['const cv::Mat &', 'val', '', []]],
    None,
    '@copybrief getPriors @see getPriors']
parse_name: cv.ml.DTrees.setPriors with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::setPriors namespace:cv::ml classpath:DTrees classname:DTrees name:setPriors
register (method) setPriors in cv::ml::DTrees (trait) (cv_ml_DTrees_setPriors_Mat)

--- Incoming ---
[   'class cv.ml.DTrees.Node',
    '',
    [],
    [],
    None,
    '@brief The class represents a decision tree node.']
parse_name: class cv.ml.DTrees.Node with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::Node namespace:cv::ml classpath:DTrees classname:DTrees name:Node
register class cv::ml::DTrees::Node (['class cv.ml.DTrees.Node', '', [], [], None, '@brief The class represents a decision tree node.'])

--- Incoming ---
['cv.ml.DTrees.Node.Node', 'N', [], [], None, '']
parse_name: cv.ml.DTrees.Node.Node with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::Node::Node namespace:cv::ml classpath:DTrees::Node classname:Node name:Node
register (constructor) default in cv::ml::DTrees::Node (cv_ml_DTrees_Node_Node)

--- Incoming ---
[   'class cv.ml.DTrees.Split',
    '',
    [],
    [],
    None,
    '@brief The class represents split in a decision tree.']
parse_name: class cv.ml.DTrees.Split with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::Split namespace:cv::ml classpath:DTrees classname:DTrees name:Split
register class cv::ml::DTrees::Split (['class cv.ml.DTrees.Split', '', [], [], None, '@brief The class represents split in a decision tree.'])

--- Incoming ---
['cv.ml.DTrees.Split.Split', 'S', [], [], None, '']
parse_name: cv.ml.DTrees.Split.Split with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::Split::Split namespace:cv::ml classpath:DTrees::Split classname:Split name:Split
register (constructor) default in cv::ml::DTrees::Split (cv_ml_DTrees_Split_Split)

--- Incoming ---
[   'cv.ml.DTrees.getRoots',
    'const std::vector<int>&',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns indices of root nodes']
parse_name: cv.ml.DTrees.getRoots with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getRoots namespace:cv::ml classpath:DTrees classname:DTrees name:getRoots
register (method) getRoots in cv::ml::DTrees (trait) (cv_ml_DTrees_getRoots_const)

--- Incoming ---
[   'cv.ml.DTrees.getNodes',
    'const std::vector<Node>&',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns all the nodes\n'
    '\n'
    'all the node indices are indices in the returned vector']
parse_name: cv.ml.DTrees.getNodes with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getNodes namespace:cv::ml classpath:DTrees classname:DTrees name:getNodes
register (method) getNodes in cv::ml::DTrees (trait) (cv_ml_DTrees_getNodes_const)

--- Incoming ---
[   'cv.ml.DTrees.getSplits',
    'const std::vector<Split>&',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns all the splits\n'
    '\n'
    'all the split indices are indices in the returned vector']
parse_name: cv.ml.DTrees.getSplits with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getSplits namespace:cv::ml classpath:DTrees classname:DTrees name:getSplits
register (method) getSplits in cv::ml::DTrees (trait) (cv_ml_DTrees_getSplits_const)

--- Incoming ---
[   'cv.ml.DTrees.getSubsets',
    'const std::vector<int>&',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns all the bitsets for categorical splits\n'
    '\n'
    'Split::subsetOfs is an offset in the returned vector']
parse_name: cv.ml.DTrees.getSubsets with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::getSubsets namespace:cv::ml classpath:DTrees classname:DTrees name:getSubsets
register (method) getSubsets in cv::ml::DTrees (trait) (cv_ml_DTrees_getSubsets_const)

--- Incoming ---
[   'cv.ml.DTrees.create',
    'Ptr<DTrees>',
    ['/S'],
    [],
    None,
    '@brief Creates the empty model\n'
    '\n'
    'The static method creates empty decision tree with the specified '
    'parameters. It should be then\n'
    'trained using train method (see StatModel::train). Alternatively, you can '
    'load the model from\n'
    'file using Algorithm::load\\<DTrees\\>(filename).']
parse_name: cv.ml.DTrees.create with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::create namespace:cv::ml classpath:DTrees classname:DTrees name:create
register (method) create in cv::ml::DTrees (trait) (cv_ml_DTrees_create)

--- Incoming ---
[   'cv.ml.DTrees.load',
    'Ptr<DTrees>',
    ['/S'],
    [   ['const String&', 'filepath', '', []],
        ['const String&', 'nodeName', 'String()', []]],
    None,
    '@brief Loads and creates a serialized DTrees from a file\n'
    '*\n'
    '* Use DTree::save to serialize and store an DTree to disk.\n'
    '* Load the DTree from this file again, by calling this function with the '
    'path to the file.\n'
    '* Optionally specify the node for the file containing the classifier\n'
    '*\n'
    '* @param filepath path to serialized DTree\n'
    '* @param nodeName name of node containing the classifier']
parse_name: cv.ml.DTrees.load with ['cv', 'cv::ml'] -> fullname:cv::ml::DTrees::load namespace:cv::ml classpath:DTrees classname:DTrees name:load
register (method) load in cv::ml::DTrees (trait) (cv_ml_DTrees_load_String_String)

--- Incoming ---
[   'class cv.ml.RTrees',
    ': cv::ml::DTrees',
    [],
    [],
    None,
    '@brief The class implements the random forest predictor.\n'
    '\n'
    '@sa @ref ml_intro_rtrees']
parse_name: class cv.ml.RTrees with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees namespace:cv::ml classpath: classname: name:RTrees
register class cv::ml::RTrees (['class cv.ml.RTrees', ': cv::ml::DTrees', [], [], None, '@brief The class implements the random forest predictor.\n\n@sa @ref ml_intro_rtrees']) impl:cv::ml::DTrees

--- Incoming ---
[   'cv.ml.RTrees.getCalculateVarImportance',
    'bool',
    ['/A', '/C'],
    [],
    None,
    '@see setCalculateVarImportance']
parse_name: cv.ml.RTrees.getCalculateVarImportance with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::getCalculateVarImportance namespace:cv::ml classpath:RTrees classname:RTrees name:getCalculateVarImportance
register (method) getCalculateVarImportance in cv::ml::RTrees (trait) (cv_ml_RTrees_getCalculateVarImportance_const)

--- Incoming ---
[   'cv.ml.RTrees.setCalculateVarImportance',
    'void',
    ['/A'],
    [['bool', 'val', '', []]],
    None,
    '@copybrief getCalculateVarImportance @see getCalculateVarImportance']
parse_name: cv.ml.RTrees.setCalculateVarImportance with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::setCalculateVarImportance namespace:cv::ml classpath:RTrees classname:RTrees name:setCalculateVarImportance
register (method) setCalculateVarImportance in cv::ml::RTrees (trait) (cv_ml_RTrees_setCalculateVarImportance_bool)

--- Incoming ---
[   'cv.ml.RTrees.getActiveVarCount',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setActiveVarCount']
parse_name: cv.ml.RTrees.getActiveVarCount with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::getActiveVarCount namespace:cv::ml classpath:RTrees classname:RTrees name:getActiveVarCount
register (method) getActiveVarCount in cv::ml::RTrees (trait) (cv_ml_RTrees_getActiveVarCount_const)

--- Incoming ---
[   'cv.ml.RTrees.setActiveVarCount',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getActiveVarCount @see getActiveVarCount']
parse_name: cv.ml.RTrees.setActiveVarCount with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::setActiveVarCount namespace:cv::ml classpath:RTrees classname:RTrees name:setActiveVarCount
register (method) setActiveVarCount in cv::ml::RTrees (trait) (cv_ml_RTrees_setActiveVarCount_int)

--- Incoming ---
[   'cv.ml.RTrees.getTermCriteria',
    'TermCriteria',
    ['/A', '/C'],
    [],
    None,
    '@see setTermCriteria']
parse_name: cv.ml.RTrees.getTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::getTermCriteria namespace:cv::ml classpath:RTrees classname:RTrees name:getTermCriteria
register (method) getTermCriteria in cv::ml::RTrees (trait) (cv_ml_RTrees_getTermCriteria_const)

--- Incoming ---
[   'cv.ml.RTrees.setTermCriteria',
    'void',
    ['/A'],
    [['const TermCriteria &', 'val', '', []]],
    None,
    '@copybrief getTermCriteria @see getTermCriteria']
parse_name: cv.ml.RTrees.setTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::setTermCriteria namespace:cv::ml classpath:RTrees classname:RTrees name:setTermCriteria
register (method) setTermCriteria in cv::ml::RTrees (trait) (cv_ml_RTrees_setTermCriteria_TermCriteria)

--- Incoming ---
[   'cv.ml.RTrees.getVarImportance',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    'Returns the variable importance array.\n'
    'The method returns the variable importance vector, computed at the '
    'training stage when\n'
    'CalculateVarImportance is set to true. If this flag was set to false, the '
    'empty matrix is\n'
    'returned.']
parse_name: cv.ml.RTrees.getVarImportance with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::getVarImportance namespace:cv::ml classpath:RTrees classname:RTrees name:getVarImportance
register (method) getVarImportance in cv::ml::RTrees (trait) (cv_ml_RTrees_getVarImportance_const)

--- Incoming ---
[   'cv.ml.RTrees.getVotes',
    'void',
    ['/A', '/C'],
    [   ['InputArray', 'samples', '', []],
        ['OutputArray', 'results', '', []],
        ['int', 'flags', '', []]],
    None,
    'Returns the result of each individual tree in the forest.\n'
    'In case the model is a regression problem, the method will return each of '
    "the trees'\n"
    'results for each of the sample cases. If the model is a classifier, it '
    'will return\n'
    'a Mat with samples + 1 rows, where the first row gives the class number '
    'and the\n'
    'following rows return the votes each class had for each sample.\n'
    '@param samples Array containing the samples for which votes will be '
    'calculated.\n'
    '@param results Array where the result of the calculation will be '
    'written.\n'
    '@param flags Flags for defining the type of RTrees.']
parse_name: cv.ml.RTrees.getVotes with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::getVotes namespace:cv::ml classpath:RTrees classname:RTrees name:getVotes
register (method) getVotes in cv::ml::RTrees (trait) (cv_ml_RTrees_getVotes_const__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.ml.RTrees.create',
    'Ptr<RTrees>',
    ['/S'],
    [],
    None,
    'Creates the empty model.\n'
    'Use StatModel::train to train the model, StatModel::train to create and '
    'train the model,\n'
    'Algorithm::load to load the pre-trained model.']
parse_name: cv.ml.RTrees.create with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::create namespace:cv::ml classpath:RTrees classname:RTrees name:create
register (method) create in cv::ml::RTrees (trait) (cv_ml_RTrees_create)

--- Incoming ---
[   'cv.ml.RTrees.load',
    'Ptr<RTrees>',
    ['/S'],
    [   ['const String&', 'filepath', '', []],
        ['const String&', 'nodeName', 'String()', []]],
    None,
    '@brief Loads and creates a serialized RTree from a file\n'
    '*\n'
    '* Use RTree::save to serialize and store an RTree to disk.\n'
    '* Load the RTree from this file again, by calling this function with the '
    'path to the file.\n'
    '* Optionally specify the node for the file containing the classifier\n'
    '*\n'
    '* @param filepath path to serialized RTree\n'
    '* @param nodeName name of node containing the classifier']
parse_name: cv.ml.RTrees.load with ['cv', 'cv::ml'] -> fullname:cv::ml::RTrees::load namespace:cv::ml classpath:RTrees classname:RTrees name:load
register (method) load in cv::ml::RTrees (trait) (cv_ml_RTrees_load_String_String)

--- Incoming ---
[   'class cv.ml.Boost',
    ': cv::ml::DTrees',
    [],
    [],
    None,
    '@brief Boosted tree classifier derived from DTrees\n'
    '\n'
    '@sa @ref ml_intro_boost']
parse_name: class cv.ml.Boost with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost namespace:cv::ml classpath: classname: name:Boost
register class cv::ml::Boost (['class cv.ml.Boost', ': cv::ml::DTrees', [], [], None, '@brief Boosted tree classifier derived from DTrees\n\n@sa @ref ml_intro_boost']) impl:cv::ml::DTrees

--- Incoming ---
['cv.ml.Boost.getBoostType', 'int', ['/A', '/C'], [], None, '@see setBoostType']
parse_name: cv.ml.Boost.getBoostType with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::getBoostType namespace:cv::ml classpath:Boost classname:Boost name:getBoostType
register (method) getBoostType in cv::ml::Boost (trait) (cv_ml_Boost_getBoostType_const)

--- Incoming ---
[   'cv.ml.Boost.setBoostType',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getBoostType @see getBoostType']
parse_name: cv.ml.Boost.setBoostType with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::setBoostType namespace:cv::ml classpath:Boost classname:Boost name:setBoostType
register (method) setBoostType in cv::ml::Boost (trait) (cv_ml_Boost_setBoostType_int)

--- Incoming ---
['cv.ml.Boost.getWeakCount', 'int', ['/A', '/C'], [], None, '@see setWeakCount']
parse_name: cv.ml.Boost.getWeakCount with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::getWeakCount namespace:cv::ml classpath:Boost classname:Boost name:getWeakCount
register (method) getWeakCount in cv::ml::Boost (trait) (cv_ml_Boost_getWeakCount_const)

--- Incoming ---
[   'cv.ml.Boost.setWeakCount',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getWeakCount @see getWeakCount']
parse_name: cv.ml.Boost.setWeakCount with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::setWeakCount namespace:cv::ml classpath:Boost classname:Boost name:setWeakCount
register (method) setWeakCount in cv::ml::Boost (trait) (cv_ml_Boost_setWeakCount_int)

--- Incoming ---
[   'cv.ml.Boost.getWeightTrimRate',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setWeightTrimRate']
parse_name: cv.ml.Boost.getWeightTrimRate with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::getWeightTrimRate namespace:cv::ml classpath:Boost classname:Boost name:getWeightTrimRate
register (method) getWeightTrimRate in cv::ml::Boost (trait) (cv_ml_Boost_getWeightTrimRate_const)

--- Incoming ---
[   'cv.ml.Boost.setWeightTrimRate',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getWeightTrimRate @see getWeightTrimRate']
parse_name: cv.ml.Boost.setWeightTrimRate with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::setWeightTrimRate namespace:cv::ml classpath:Boost classname:Boost name:setWeightTrimRate
register (method) setWeightTrimRate in cv::ml::Boost (trait) (cv_ml_Boost_setWeightTrimRate_double)

--- Incoming ---
[   'enum cv.ml.Boost.Types',
    '',
    [],
    [   [   'const cv.ml.Boost.DISCRETE',
            '0',
            [],
            [],
            None,
            'Discrete AdaBoost.\n'],
        [   'const cv.ml.Boost.REAL',
            '1',
            [],
            [],
            None,
            'Real AdaBoost. It is a technique that utilizes confidence-rated '
            'predictions\n'],
        [   'const cv.ml.Boost.LOGIT',
            '2',
            [],
            [],
            None,
            'LogitBoost. It can produce good regression fits.\n'],
        [   'const cv.ml.Boost.GENTLE',
            '3',
            [],
            [],
            None,
            'Gentle AdaBoost. It puts less weight on outlier data points and '
            'for that\n']],
    None,
    'Boosting type.\n'
    'Gentle AdaBoost and Real AdaBoost are often the preferable choices.']
parse_name: const cv.ml.Boost.DISCRETE with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::DISCRETE namespace:cv::ml classpath:Boost classname:Boost name:DISCRETE
parse_name: const cv.ml.Boost.REAL with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::REAL namespace:cv::ml classpath:Boost classname:Boost name:REAL
parse_name: const cv.ml.Boost.LOGIT with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::LOGIT namespace:cv::ml classpath:Boost classname:Boost name:LOGIT
parse_name: const cv.ml.Boost.GENTLE with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::GENTLE namespace:cv::ml classpath:Boost classname:Boost name:GENTLE
parse_name: enum cv.ml.Boost.Types with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::Types namespace:cv::ml classpath:Boost classname:Boost name:Types
parse_name: const cv.ml.Boost.DISCRETE with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::DISCRETE namespace:cv::ml classpath:Boost classname:Boost name:DISCRETE
parse_name: const cv.ml.Boost.REAL with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::REAL namespace:cv::ml classpath:Boost classname:Boost name:REAL
parse_name: const cv.ml.Boost.LOGIT with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::LOGIT namespace:cv::ml classpath:Boost classname:Boost name:LOGIT
parse_name: const cv.ml.Boost.GENTLE with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::GENTLE namespace:cv::ml classpath:Boost classname:Boost name:GENTLE

--- Incoming ---
[   'cv.ml.Boost.create',
    'Ptr<Boost>',
    ['/S'],
    [],
    None,
    'Creates the empty model.\n'
    'Use StatModel::train to train the model, '
    'Algorithm::load\\<Boost\\>(filename) to load the pre-trained model.']
parse_name: cv.ml.Boost.create with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::create namespace:cv::ml classpath:Boost classname:Boost name:create
register (method) create in cv::ml::Boost (trait) (cv_ml_Boost_create)

--- Incoming ---
[   'cv.ml.Boost.load',
    'Ptr<Boost>',
    ['/S'],
    [   ['const String&', 'filepath', '', []],
        ['const String&', 'nodeName', 'String()', []]],
    None,
    '@brief Loads and creates a serialized Boost from a file\n'
    '*\n'
    '* Use Boost::save to serialize and store an RTree to disk.\n'
    '* Load the Boost from this file again, by calling this function with the '
    'path to the file.\n'
    '* Optionally specify the node for the file containing the classifier\n'
    '*\n'
    '* @param filepath path to serialized Boost\n'
    '* @param nodeName name of node containing the classifier']
parse_name: cv.ml.Boost.load with ['cv', 'cv::ml'] -> fullname:cv::ml::Boost::load namespace:cv::ml classpath:Boost classname:Boost name:load
register (method) load in cv::ml::Boost (trait) (cv_ml_Boost_load_String_String)

--- Incoming ---
[   'class cv.ml.ANN_MLP',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '@brief Artificial Neural Networks - Multi-Layer Perceptrons.\n'
    '\n'
    'Unlike many other models in ML that are constructed and trained at once, '
    'in the MLP model these\n'
    'steps are separated. First, a network with the specified topology is '
    'created using the non-default\n'
    'constructor or the method ANN_MLP::create. All the weights are set to '
    'zeros. Then, the network is\n'
    'trained using a set of input and output vectors. The training procedure '
    'can be repeated more than\n'
    'once, that is, the weights can be adjusted based on the new training '
    'data.\n'
    '\n'
    'Additional flags for StatModel::train are available: '
    'ANN_MLP::TrainFlags.\n'
    '\n'
    '@sa @ref ml_intro_ann']
parse_name: class cv.ml.ANN_MLP with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP namespace:cv::ml classpath: classname: name:ANN_MLP
register class cv::ml::ANN_MLP (['class cv.ml.ANN_MLP', ': cv::ml::StatModel', [], [], None, '@brief Artificial Neural Networks - Multi-Layer Perceptrons.\n\nUnlike many other models in ML that are constructed and trained at once, in the MLP model these\nsteps are separated. First, a network with the specified topology is created using the non-default\nconstructor or the method ANN_MLP::create. All the weights are set to zeros. Then, the network is\ntrained using a set of input and output vectors. The training procedure can be repeated more than\nonce, that is, the weights can be adjusted based on the new training data.\n\nAdditional flags for StatModel::train are available: ANN_MLP::TrainFlags.\n\n@sa @ref ml_intro_ann']) impl:cv::ml::StatModel

--- Incoming ---
[   'enum cv.ml.ANN_MLP.TrainingMethods',
    '',
    [],
    [   [   'const cv.ml.ANN_MLP.BACKPROP',
            '0',
            [],
            [],
            None,
            'The back-propagation algorithm.\n'],
        [   'const cv.ml.ANN_MLP.RPROP',
            '1',
            [],
            [],
            None,
            'The RPROP algorithm. See @cite RPROP93 for details.\n'],
        [   'const cv.ml.ANN_MLP.ANNEAL',
            '2',
            [],
            [],
            None,
            'The simulated annealing algorithm. See @cite Kirkpatrick83 for '
            'details.\n']],
    None,
    'Available training methods']
parse_name: const cv.ml.ANN_MLP.BACKPROP with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::BACKPROP namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:BACKPROP
parse_name: const cv.ml.ANN_MLP.RPROP with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::RPROP namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:RPROP
parse_name: const cv.ml.ANN_MLP.ANNEAL with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::ANNEAL namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:ANNEAL
parse_name: enum cv.ml.ANN_MLP.TrainingMethods with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::TrainingMethods namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:TrainingMethods
parse_name: const cv.ml.ANN_MLP.BACKPROP with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::BACKPROP namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:BACKPROP
parse_name: const cv.ml.ANN_MLP.RPROP with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::RPROP namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:RPROP
parse_name: const cv.ml.ANN_MLP.ANNEAL with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::ANNEAL namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:ANNEAL

--- Incoming ---
[   'cv.ml.ANN_MLP.setTrainMethod',
    'void',
    ['/A'],
    [   ['int', 'method', '', []],
        ['double', 'param1', '0', []],
        ['double', 'param2', '0', []]],
    None,
    'Sets training method and common parameters.\n'
    '@param method Default value is ANN_MLP::RPROP. See '
    'ANN_MLP::TrainingMethods.\n'
    '@param param1 passed to setRpropDW0 for ANN_MLP::RPROP and to '
    'setBackpropWeightScale for ANN_MLP::BACKPROP and to initialT for '
    'ANN_MLP::ANNEAL.\n'
    '@param param2 passed to setRpropDWMin for ANN_MLP::RPROP and to '
    'setBackpropMomentumScale for ANN_MLP::BACKPROP and to finalT for '
    'ANN_MLP::ANNEAL.']
parse_name: cv.ml.ANN_MLP.setTrainMethod with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setTrainMethod namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setTrainMethod
register (method) setTrainMethod in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setTrainMethod_int_double_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getTrainMethod',
    'int',
    ['/A', '/C'],
    [],
    None,
    'Returns current training method']
parse_name: cv.ml.ANN_MLP.getTrainMethod with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getTrainMethod namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getTrainMethod
register (method) getTrainMethod in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getTrainMethod_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setActivationFunction',
    'void',
    ['/A'],
    [   ['int', 'type', '', []],
        ['double', 'param1', '0', []],
        ['double', 'param2', '0', []]],
    None,
    'Initialize the activation function for each neuron.\n'
    'Currently the default and the only fully supported activation function is '
    'ANN_MLP::SIGMOID_SYM.\n'
    '@param type The type of activation function. See '
    'ANN_MLP::ActivationFunctions.\n'
    '@param param1 The first parameter of the activation function, '
    '\\f$\\alpha\\f$. Default value is 0.\n'
    '@param param2 The second parameter of the activation function, '
    '\\f$\\beta\\f$. Default value is 0.']
parse_name: cv.ml.ANN_MLP.setActivationFunction with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setActivationFunction namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setActivationFunction
register (method) setActivationFunction in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setActivationFunction_int_double_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.setLayerSizes',
    'void',
    ['/A'],
    [['InputArray', '_layer_sizes', '', []]],
    None,
    'Integer vector specifying the number of neurons in each layer including '
    'the input and output layers.\n'
    'The very first element specifies the number of elements in the input '
    'layer.\n'
    'The last element - number of elements in the output layer. Default value '
    'is empty Mat.\n'
    '@sa getLayerSizes']
parse_name: cv.ml.ANN_MLP.setLayerSizes with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setLayerSizes namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setLayerSizes
register (method) setLayerSizes in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setLayerSizes__InputArray)

--- Incoming ---
[   'cv.ml.ANN_MLP.getLayerSizes',
    'cv::Mat',
    ['/A', '/C'],
    [],
    None,
    'Integer vector specifying the number of neurons in each layer including '
    'the input and output layers.\n'
    'The very first element specifies the number of elements in the input '
    'layer.\n'
    'The last element - number of elements in the output layer.\n'
    '@sa setLayerSizes']
parse_name: cv.ml.ANN_MLP.getLayerSizes with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getLayerSizes namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getLayerSizes
register (method) getLayerSizes in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getLayerSizes_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.getTermCriteria',
    'TermCriteria',
    ['/A', '/C'],
    [],
    None,
    '@see setTermCriteria']
parse_name: cv.ml.ANN_MLP.getTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getTermCriteria namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getTermCriteria
register (method) getTermCriteria in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getTermCriteria_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setTermCriteria',
    'void',
    ['/A'],
    [['TermCriteria', 'val', '', []]],
    None,
    '@copybrief getTermCriteria @see getTermCriteria']
parse_name: cv.ml.ANN_MLP.setTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setTermCriteria namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setTermCriteria
register (method) setTermCriteria in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setTermCriteria_TermCriteria)

--- Incoming ---
[   'cv.ml.ANN_MLP.getBackpropWeightScale',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setBackpropWeightScale']
parse_name: cv.ml.ANN_MLP.getBackpropWeightScale with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getBackpropWeightScale namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getBackpropWeightScale
register (method) getBackpropWeightScale in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getBackpropWeightScale_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setBackpropWeightScale',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getBackpropWeightScale @see getBackpropWeightScale']
parse_name: cv.ml.ANN_MLP.setBackpropWeightScale with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setBackpropWeightScale namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setBackpropWeightScale
register (method) setBackpropWeightScale in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setBackpropWeightScale_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getBackpropMomentumScale',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setBackpropMomentumScale']
parse_name: cv.ml.ANN_MLP.getBackpropMomentumScale with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getBackpropMomentumScale namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getBackpropMomentumScale
register (method) getBackpropMomentumScale in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getBackpropMomentumScale_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setBackpropMomentumScale',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getBackpropMomentumScale @see getBackpropMomentumScale']
parse_name: cv.ml.ANN_MLP.setBackpropMomentumScale with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setBackpropMomentumScale namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setBackpropMomentumScale
register (method) setBackpropMomentumScale in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setBackpropMomentumScale_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getRpropDW0',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setRpropDW0']
parse_name: cv.ml.ANN_MLP.getRpropDW0 with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getRpropDW0 namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getRpropDW0
register (method) getRpropDW0 in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getRpropDW0_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDW0',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getRpropDW0 @see getRpropDW0']
parse_name: cv.ml.ANN_MLP.setRpropDW0 with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setRpropDW0 namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setRpropDW0
register (method) setRpropDW0 in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setRpropDW0_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getRpropDWPlus',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setRpropDWPlus']
parse_name: cv.ml.ANN_MLP.getRpropDWPlus with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getRpropDWPlus namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getRpropDWPlus
register (method) getRpropDWPlus in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getRpropDWPlus_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWPlus',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getRpropDWPlus @see getRpropDWPlus']
parse_name: cv.ml.ANN_MLP.setRpropDWPlus with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setRpropDWPlus namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setRpropDWPlus
register (method) setRpropDWPlus in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setRpropDWPlus_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getRpropDWMinus',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setRpropDWMinus']
parse_name: cv.ml.ANN_MLP.getRpropDWMinus with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getRpropDWMinus namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getRpropDWMinus
register (method) getRpropDWMinus in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getRpropDWMinus_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWMinus',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getRpropDWMinus @see getRpropDWMinus']
parse_name: cv.ml.ANN_MLP.setRpropDWMinus with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setRpropDWMinus namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setRpropDWMinus
register (method) setRpropDWMinus in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setRpropDWMinus_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getRpropDWMin',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setRpropDWMin']
parse_name: cv.ml.ANN_MLP.getRpropDWMin with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getRpropDWMin namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getRpropDWMin
register (method) getRpropDWMin in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getRpropDWMin_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWMin',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getRpropDWMin @see getRpropDWMin']
parse_name: cv.ml.ANN_MLP.setRpropDWMin with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setRpropDWMin namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setRpropDWMin
register (method) setRpropDWMin in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setRpropDWMin_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getRpropDWMax',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setRpropDWMax']
parse_name: cv.ml.ANN_MLP.getRpropDWMax with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getRpropDWMax namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getRpropDWMax
register (method) getRpropDWMax in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getRpropDWMax_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWMax',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getRpropDWMax @see getRpropDWMax']
parse_name: cv.ml.ANN_MLP.setRpropDWMax with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setRpropDWMax namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setRpropDWMax
register (method) setRpropDWMax in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setRpropDWMax_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getAnnealInitialT',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setAnnealInitialT']
parse_name: cv.ml.ANN_MLP.getAnnealInitialT with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getAnnealInitialT namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getAnnealInitialT
register (method) getAnnealInitialT in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getAnnealInitialT_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealInitialT',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getAnnealInitialT @see getAnnealInitialT']
parse_name: cv.ml.ANN_MLP.setAnnealInitialT with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setAnnealInitialT namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setAnnealInitialT
register (method) setAnnealInitialT in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setAnnealInitialT_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getAnnealFinalT',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setAnnealFinalT']
parse_name: cv.ml.ANN_MLP.getAnnealFinalT with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getAnnealFinalT namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getAnnealFinalT
register (method) getAnnealFinalT in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getAnnealFinalT_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealFinalT',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getAnnealFinalT @see getAnnealFinalT']
parse_name: cv.ml.ANN_MLP.setAnnealFinalT with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setAnnealFinalT namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setAnnealFinalT
register (method) setAnnealFinalT in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setAnnealFinalT_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getAnnealCoolingRatio',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setAnnealCoolingRatio']
parse_name: cv.ml.ANN_MLP.getAnnealCoolingRatio with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getAnnealCoolingRatio namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getAnnealCoolingRatio
register (method) getAnnealCoolingRatio in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getAnnealCoolingRatio_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealCoolingRatio',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getAnnealCoolingRatio @see getAnnealCoolingRatio']
parse_name: cv.ml.ANN_MLP.setAnnealCoolingRatio with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setAnnealCoolingRatio namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setAnnealCoolingRatio
register (method) setAnnealCoolingRatio in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setAnnealCoolingRatio_double)

--- Incoming ---
[   'cv.ml.ANN_MLP.getAnnealItePerStep',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setAnnealItePerStep']
parse_name: cv.ml.ANN_MLP.getAnnealItePerStep with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getAnnealItePerStep namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getAnnealItePerStep
register (method) getAnnealItePerStep in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getAnnealItePerStep_const)

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealItePerStep',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getAnnealItePerStep @see getAnnealItePerStep']
parse_name: cv.ml.ANN_MLP.setAnnealItePerStep with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setAnnealItePerStep namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setAnnealItePerStep
register (method) setAnnealItePerStep in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setAnnealItePerStep_int)

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealEnergyRNG',
    'void',
    ['/A'],
    [['const RNG&', 'rng', '', []]],
    None,
    '@brief Set/initialize anneal RNG']
parse_name: cv.ml.ANN_MLP.setAnnealEnergyRNG with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::setAnnealEnergyRNG namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:setAnnealEnergyRNG
Registering an unknown type: RNG
register (method) setAnnealEnergyRNG in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_setAnnealEnergyRNG_RNG)

--- Incoming ---
[   'enum cv.ml.ANN_MLP.ActivationFunctions',
    '',
    [],
    [   ['const cv.ml.ANN_MLP.IDENTITY', '0', [], [], None, ''],
        ['const cv.ml.ANN_MLP.SIGMOID_SYM', '1', [], [], None, ''],
        ['const cv.ml.ANN_MLP.GAUSSIAN', '2', [], [], None, ''],
        ['const cv.ml.ANN_MLP.RELU', '3', [], [], None, ''],
        ['const cv.ml.ANN_MLP.LEAKYRELU', '4', [], [], None, '']],
    None,
    'possible activation functions']
parse_name: const cv.ml.ANN_MLP.IDENTITY with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::IDENTITY namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:IDENTITY
parse_name: const cv.ml.ANN_MLP.SIGMOID_SYM with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::SIGMOID_SYM namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:SIGMOID_SYM
parse_name: const cv.ml.ANN_MLP.GAUSSIAN with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::GAUSSIAN namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:GAUSSIAN
parse_name: const cv.ml.ANN_MLP.RELU with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::RELU namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:RELU
parse_name: const cv.ml.ANN_MLP.LEAKYRELU with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::LEAKYRELU namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:LEAKYRELU
parse_name: enum cv.ml.ANN_MLP.ActivationFunctions with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::ActivationFunctions namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:ActivationFunctions
parse_name: const cv.ml.ANN_MLP.IDENTITY with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::IDENTITY namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:IDENTITY
parse_name: const cv.ml.ANN_MLP.SIGMOID_SYM with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::SIGMOID_SYM namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:SIGMOID_SYM
parse_name: const cv.ml.ANN_MLP.GAUSSIAN with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::GAUSSIAN namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:GAUSSIAN
parse_name: const cv.ml.ANN_MLP.RELU with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::RELU namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:RELU
parse_name: const cv.ml.ANN_MLP.LEAKYRELU with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::LEAKYRELU namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:LEAKYRELU

--- Incoming ---
[   'enum cv.ml.ANN_MLP.TrainFlags',
    '',
    [],
    [   ['const cv.ml.ANN_MLP.UPDATE_WEIGHTS', '1', [], [], None, ''],
        ['const cv.ml.ANN_MLP.NO_INPUT_SCALE', '2', [], [], None, ''],
        ['const cv.ml.ANN_MLP.NO_OUTPUT_SCALE', '4', [], [], None, '']],
    None,
    'Train options']
parse_name: const cv.ml.ANN_MLP.UPDATE_WEIGHTS with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::UPDATE_WEIGHTS namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:UPDATE_WEIGHTS
parse_name: const cv.ml.ANN_MLP.NO_INPUT_SCALE with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::NO_INPUT_SCALE namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:NO_INPUT_SCALE
parse_name: const cv.ml.ANN_MLP.NO_OUTPUT_SCALE with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::NO_OUTPUT_SCALE namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:NO_OUTPUT_SCALE
parse_name: enum cv.ml.ANN_MLP.TrainFlags with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::TrainFlags namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:TrainFlags
parse_name: const cv.ml.ANN_MLP.UPDATE_WEIGHTS with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::UPDATE_WEIGHTS namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:UPDATE_WEIGHTS
parse_name: const cv.ml.ANN_MLP.NO_INPUT_SCALE with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::NO_INPUT_SCALE namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:NO_INPUT_SCALE
parse_name: const cv.ml.ANN_MLP.NO_OUTPUT_SCALE with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::NO_OUTPUT_SCALE namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:NO_OUTPUT_SCALE

--- Incoming ---
[   'cv.ml.ANN_MLP.getWeights',
    'Mat',
    ['/A', '/C'],
    [['int', 'layerIdx', '', []]],
    None,
    '']
parse_name: cv.ml.ANN_MLP.getWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::getWeights namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:getWeights
register (method) getWeights in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_getWeights_const_int)

--- Incoming ---
[   'cv.ml.ANN_MLP.create',
    'Ptr<ANN_MLP>',
    ['/S'],
    [],
    None,
    '@brief Creates empty model\n'
    '\n'
    'Use StatModel::train to train the model, '
    'Algorithm::load\\<ANN_MLP\\>(filename) to load the pre-trained model.\n'
    'Note that the train method has optional flags: ANN_MLP::TrainFlags.']
parse_name: cv.ml.ANN_MLP.create with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::create namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:create
register (method) create in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_create)

--- Incoming ---
[   'cv.ml.ANN_MLP.load',
    'Ptr<ANN_MLP>',
    ['/S'],
    [['const String&', 'filepath', '', []]],
    None,
    '@brief Loads and creates a serialized ANN from a file\n'
    '*\n'
    '* Use ANN::save to serialize and store an ANN to disk.\n'
    '* Load the ANN from this file again, by calling this function with the '
    'path to the file.\n'
    '*\n'
    '* @param filepath path to serialized ANN']
parse_name: cv.ml.ANN_MLP.load with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP::load namespace:cv::ml classpath:ANN_MLP classname:ANN_MLP name:load
register (method) load in cv::ml::ANN_MLP (trait) (cv_ml_ANN_MLP_load_String)

--- Incoming ---
['typedef cv.ml.ANN_MLP_ANNEAL', 'ANN_MLP', '', [], None, '']
parse_name: typedef cv.ml.ANN_MLP_ANNEAL with ['cv', 'cv::ml'] -> fullname:cv::ml::ANN_MLP_ANNEAL namespace:cv::ml classpath: classname: name:ANN_MLP_ANNEAL
Registering an unknown type: ANN_MLP_ANNEAL

--- Incoming ---
[   'class cv.ml.LogisticRegression',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '@brief Implements Logistic Regression classifier.\n\n@sa @ref ml_intro_lr']
parse_name: class cv.ml.LogisticRegression with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression namespace:cv::ml classpath: classname: name:LogisticRegression
register class cv::ml::LogisticRegression (['class cv.ml.LogisticRegression', ': cv::ml::StatModel', [], [], None, '@brief Implements Logistic Regression classifier.\n\n@sa @ref ml_intro_lr']) impl:cv::ml::StatModel

--- Incoming ---
[   'cv.ml.LogisticRegression.getLearningRate',
    'double',
    ['/A', '/C'],
    [],
    None,
    '@see setLearningRate']
parse_name: cv.ml.LogisticRegression.getLearningRate with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::getLearningRate namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:getLearningRate
register (method) getLearningRate in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_getLearningRate_const)

--- Incoming ---
[   'cv.ml.LogisticRegression.setLearningRate',
    'void',
    ['/A'],
    [['double', 'val', '', []]],
    None,
    '@copybrief getLearningRate @see getLearningRate']
parse_name: cv.ml.LogisticRegression.setLearningRate with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::setLearningRate namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:setLearningRate
register (method) setLearningRate in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_setLearningRate_double)

--- Incoming ---
[   'cv.ml.LogisticRegression.getIterations',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setIterations']
parse_name: cv.ml.LogisticRegression.getIterations with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::getIterations namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:getIterations
register (method) getIterations in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_getIterations_const)

--- Incoming ---
[   'cv.ml.LogisticRegression.setIterations',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getIterations @see getIterations']
parse_name: cv.ml.LogisticRegression.setIterations with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::setIterations namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:setIterations
register (method) setIterations in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_setIterations_int)

--- Incoming ---
[   'cv.ml.LogisticRegression.getRegularization',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setRegularization']
parse_name: cv.ml.LogisticRegression.getRegularization with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::getRegularization namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:getRegularization
register (method) getRegularization in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_getRegularization_const)

--- Incoming ---
[   'cv.ml.LogisticRegression.setRegularization',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getRegularization @see getRegularization']
parse_name: cv.ml.LogisticRegression.setRegularization with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::setRegularization namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:setRegularization
register (method) setRegularization in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_setRegularization_int)

--- Incoming ---
[   'cv.ml.LogisticRegression.getTrainMethod',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setTrainMethod']
parse_name: cv.ml.LogisticRegression.getTrainMethod with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::getTrainMethod namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:getTrainMethod
register (method) getTrainMethod in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_getTrainMethod_const)

--- Incoming ---
[   'cv.ml.LogisticRegression.setTrainMethod',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getTrainMethod @see getTrainMethod']
parse_name: cv.ml.LogisticRegression.setTrainMethod with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::setTrainMethod namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:setTrainMethod
register (method) setTrainMethod in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_setTrainMethod_int)

--- Incoming ---
[   'cv.ml.LogisticRegression.getMiniBatchSize',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setMiniBatchSize']
parse_name: cv.ml.LogisticRegression.getMiniBatchSize with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::getMiniBatchSize namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:getMiniBatchSize
register (method) getMiniBatchSize in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_getMiniBatchSize_const)

--- Incoming ---
[   'cv.ml.LogisticRegression.setMiniBatchSize',
    'void',
    ['/A'],
    [['int', 'val', '', []]],
    None,
    '@copybrief getMiniBatchSize @see getMiniBatchSize']
parse_name: cv.ml.LogisticRegression.setMiniBatchSize with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::setMiniBatchSize namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:setMiniBatchSize
register (method) setMiniBatchSize in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_setMiniBatchSize_int)

--- Incoming ---
[   'cv.ml.LogisticRegression.getTermCriteria',
    'TermCriteria',
    ['/A', '/C'],
    [],
    None,
    '@see setTermCriteria']
parse_name: cv.ml.LogisticRegression.getTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::getTermCriteria namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:getTermCriteria
register (method) getTermCriteria in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_getTermCriteria_const)

--- Incoming ---
[   'cv.ml.LogisticRegression.setTermCriteria',
    'void',
    ['/A'],
    [['TermCriteria', 'val', '', []]],
    None,
    '@copybrief getTermCriteria @see getTermCriteria']
parse_name: cv.ml.LogisticRegression.setTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::setTermCriteria namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:setTermCriteria
register (method) setTermCriteria in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_setTermCriteria_TermCriteria)

--- Incoming ---
[   'enum cv.ml.LogisticRegression.RegKinds',
    '',
    [],
    [   [   'const cv.ml.LogisticRegression.REG_DISABLE',
            '-1',
            [],
            [],
            None,
            'Regularization disabled\n'],
        [   'const cv.ml.LogisticRegression.REG_L1',
            '0',
            [],
            [],
            None,
            '%L1 norm\n'],
        [   'const cv.ml.LogisticRegression.REG_L2',
            '1',
            [],
            [],
            None,
            '%L2 norm\n']],
    None,
    'Regularization kinds']
parse_name: const cv.ml.LogisticRegression.REG_DISABLE with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::REG_DISABLE namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:REG_DISABLE
parse_name: const cv.ml.LogisticRegression.REG_L1 with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::REG_L1 namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:REG_L1
parse_name: const cv.ml.LogisticRegression.REG_L2 with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::REG_L2 namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:REG_L2
parse_name: enum cv.ml.LogisticRegression.RegKinds with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::RegKinds namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:RegKinds
parse_name: const cv.ml.LogisticRegression.REG_DISABLE with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::REG_DISABLE namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:REG_DISABLE
parse_name: const cv.ml.LogisticRegression.REG_L1 with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::REG_L1 namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:REG_L1
parse_name: const cv.ml.LogisticRegression.REG_L2 with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::REG_L2 namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:REG_L2

--- Incoming ---
[   'enum cv.ml.LogisticRegression.Methods',
    '',
    [],
    [   ['const cv.ml.LogisticRegression.BATCH', '0', [], [], None, ''],
        [   'const cv.ml.LogisticRegression.MINI_BATCH',
            '1',
            [],
            [],
            None,
            'Set MiniBatchSize to a positive integer when using this '
            'method.\n']],
    None,
    'Training methods']
parse_name: const cv.ml.LogisticRegression.BATCH with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::BATCH namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:BATCH
parse_name: const cv.ml.LogisticRegression.MINI_BATCH with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::MINI_BATCH namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:MINI_BATCH
parse_name: enum cv.ml.LogisticRegression.Methods with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::Methods namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:Methods
parse_name: const cv.ml.LogisticRegression.BATCH with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::BATCH namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:BATCH
parse_name: const cv.ml.LogisticRegression.MINI_BATCH with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::MINI_BATCH namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:MINI_BATCH

--- Incoming ---
[   'cv.ml.LogisticRegression.predict',
    'float',
    ['/C'],
    [   ['InputArray', 'samples', '', []],
        ['OutputArray', 'results', 'noArray()', []],
        ['int', 'flags', '0', []]],
    None,
    '@brief Predicts responses for input samples and returns a float type.\n'
    '\n'
    '@param samples The input data for the prediction algorithm. Matrix [m x '
    'n], where each row\n'
    'contains variables (features) of one object being classified. Should have '
    'data type CV_32F.\n'
    '@param results Predicted labels as a column matrix of type CV_32S.\n'
    '@param flags Not used.']
parse_name: cv.ml.LogisticRegression.predict with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::predict namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:predict
register (method) predict in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_predict_const__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.ml.LogisticRegression.get_learnt_thetas',
    'Mat',
    ['/A', '/C'],
    [],
    None,
    '@brief This function returns the trained parameters arranged across '
    'rows.\n'
    '\n'
    'For a two class classifcation problem, it returns a row matrix. It '
    'returns learnt parameters of\n'
    'the Logistic Regression as a matrix of type CV_32F.']
parse_name: cv.ml.LogisticRegression.get_learnt_thetas with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::get_learnt_thetas namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:get_learnt_thetas
register (method) get_learnt_thetas in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_get_learnt_thetas_const)

--- Incoming ---
[   'cv.ml.LogisticRegression.create',
    'Ptr<LogisticRegression>',
    ['/S'],
    [],
    None,
    '@brief Creates empty model.\n'
    '\n'
    'Creates Logistic Regression model with parameters given.']
parse_name: cv.ml.LogisticRegression.create with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::create namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:create
register (method) create in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_create)

--- Incoming ---
[   'cv.ml.LogisticRegression.load',
    'Ptr<LogisticRegression>',
    ['/S'],
    [   ['const String&', 'filepath', '', []],
        ['const String&', 'nodeName', 'String()', []]],
    None,
    '@brief Loads and creates a serialized LogisticRegression from a file\n'
    '*\n'
    '* Use LogisticRegression::save to serialize and store an '
    'LogisticRegression to disk.\n'
    '* Load the LogisticRegression from this file again, by calling this '
    'function with the path to the file.\n'
    '* Optionally specify the node for the file containing the classifier\n'
    '*\n'
    '* @param filepath path to serialized LogisticRegression\n'
    '* @param nodeName name of node containing the classifier']
parse_name: cv.ml.LogisticRegression.load with ['cv', 'cv::ml'] -> fullname:cv::ml::LogisticRegression::load namespace:cv::ml classpath:LogisticRegression classname:LogisticRegression name:load
register (method) load in cv::ml::LogisticRegression (trait) (cv_ml_LogisticRegression_load_String_String)

--- Incoming ---
[   'class cv.ml.SVMSGD',
    ': cv::ml::StatModel',
    [],
    [],
    None,
    '**************************************************************************************\\\n'
    '*                        Stochastic Gradient Descent SVM '
    'Classifier                      *\n'
    '\\***************************************************************************************']
parse_name: class cv.ml.SVMSGD with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD namespace:cv::ml classpath: classname: name:SVMSGD
register class cv::ml::SVMSGD (['class cv.ml.SVMSGD', ': cv::ml::StatModel', [], [], None, '**************************************************************************************\\\n*                        Stochastic Gradient Descent SVM Classifier                      *\n\\***************************************************************************************']) impl:cv::ml::StatModel

--- Incoming ---
[   'enum cv.ml.SVMSGD.SvmsgdType',
    '',
    [],
    [   [   'const cv.ml.SVMSGD.SGD',
            '0',
            [],
            [],
            None,
            'Stochastic Gradient Descent\n'],
        [   'const cv.ml.SVMSGD.ASGD',
            '1',
            [],
            [],
            None,
            'Average Stochastic Gradient Descent\n']],
    None,
    'SVMSGD type.\nASGD is often the preferable choice.']
parse_name: const cv.ml.SVMSGD.SGD with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::SGD namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:SGD
parse_name: const cv.ml.SVMSGD.ASGD with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::ASGD namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:ASGD
parse_name: enum cv.ml.SVMSGD.SvmsgdType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::SvmsgdType namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:SvmsgdType
parse_name: const cv.ml.SVMSGD.SGD with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::SGD namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:SGD
parse_name: const cv.ml.SVMSGD.ASGD with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::ASGD namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:ASGD

--- Incoming ---
[   'enum cv.ml.SVMSGD.MarginType',
    '',
    [],
    [   [   'const cv.ml.SVMSGD.SOFT_MARGIN',
            '0',
            [],
            [],
            None,
            'General case, suits to the case of non-linearly separable sets, '
            'allows outliers.\n'],
        [   'const cv.ml.SVMSGD.HARD_MARGIN',
            '1',
            [],
            [],
            None,
            'More accurate for the case of linearly separable sets.\n']],
    None,
    'Margin type.']
parse_name: const cv.ml.SVMSGD.SOFT_MARGIN with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::SOFT_MARGIN namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:SOFT_MARGIN
parse_name: const cv.ml.SVMSGD.HARD_MARGIN with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::HARD_MARGIN namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:HARD_MARGIN
parse_name: enum cv.ml.SVMSGD.MarginType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::MarginType namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:MarginType
parse_name: const cv.ml.SVMSGD.SOFT_MARGIN with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::SOFT_MARGIN namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:SOFT_MARGIN
parse_name: const cv.ml.SVMSGD.HARD_MARGIN with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::HARD_MARGIN namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:HARD_MARGIN

--- Incoming ---
[   'cv.ml.SVMSGD.getWeights',
    'Mat',
    ['/A'],
    [],
    None,
    '* @return the weights of the trained model (decision function f(x) = '
    'weights * x + shift).']
parse_name: cv.ml.SVMSGD.getWeights with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getWeights namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getWeights
register (method) getWeights in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getWeights)

--- Incoming ---
[   'cv.ml.SVMSGD.getShift',
    'float',
    ['/A'],
    [],
    None,
    '* @return the shift of the trained model (decision function f(x) = '
    'weights * x + shift).']
parse_name: cv.ml.SVMSGD.getShift with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getShift namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getShift
register (method) getShift in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getShift)

--- Incoming ---
[   'cv.ml.SVMSGD.create',
    'Ptr<SVMSGD>',
    ['/S'],
    [],
    None,
    '@brief Creates empty model.\n'
    '* Use StatModel::train to train the model. Since %SVMSGD has several '
    'parameters, you may want to\n'
    '* find the best parameters for your problem or use setOptimalParameters() '
    'to set some default parameters.']
parse_name: cv.ml.SVMSGD.create with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::create namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:create
register (method) create in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_create)

--- Incoming ---
[   'cv.ml.SVMSGD.load',
    'Ptr<SVMSGD>',
    ['/S'],
    [   ['const String&', 'filepath', '', []],
        ['const String&', 'nodeName', 'String()', []]],
    None,
    '@brief Loads and creates a serialized SVMSGD from a file\n'
    '*\n'
    '* Use SVMSGD::save to serialize and store an SVMSGD to disk.\n'
    '* Load the SVMSGD from this file again, by calling this function with the '
    'path to the file.\n'
    '* Optionally specify the node for the file containing the classifier\n'
    '*\n'
    '* @param filepath path to serialized SVMSGD\n'
    '* @param nodeName name of node containing the classifier']
parse_name: cv.ml.SVMSGD.load with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::load namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:load
register (method) load in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_load_String_String)

--- Incoming ---
[   'cv.ml.SVMSGD.setOptimalParameters',
    'void',
    ['/A'],
    [   ['int', 'svmsgdType', 'SVMSGD::ASGD', []],
        ['int', 'marginType', 'SVMSGD::SOFT_MARGIN', []]],
    None,
    '@brief Function sets optimal parameters values for chosen SVM SGD model.\n'
    '* @param svmsgdType is the type of SVMSGD classifier.\n'
    '* @param marginType is the type of margin constraint.']
parse_name: cv.ml.SVMSGD.setOptimalParameters with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::setOptimalParameters namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:setOptimalParameters
register (method) setOptimalParameters in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_setOptimalParameters_int_int)

--- Incoming ---
[   'cv.ml.SVMSGD.getSvmsgdType',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setSvmsgdType']
parse_name: cv.ml.SVMSGD.getSvmsgdType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getSvmsgdType namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getSvmsgdType
register (method) getSvmsgdType in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getSvmsgdType_const)

--- Incoming ---
[   'cv.ml.SVMSGD.setSvmsgdType',
    'void',
    ['/A'],
    [['int', 'svmsgdType', '', []]],
    None,
    '@copybrief getSvmsgdType @see getSvmsgdType']
parse_name: cv.ml.SVMSGD.setSvmsgdType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::setSvmsgdType namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:setSvmsgdType
register (method) setSvmsgdType in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_setSvmsgdType_int)

--- Incoming ---
[   'cv.ml.SVMSGD.getMarginType',
    'int',
    ['/A', '/C'],
    [],
    None,
    '@see setMarginType']
parse_name: cv.ml.SVMSGD.getMarginType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getMarginType namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getMarginType
register (method) getMarginType in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getMarginType_const)

--- Incoming ---
[   'cv.ml.SVMSGD.setMarginType',
    'void',
    ['/A'],
    [['int', 'marginType', '', []]],
    None,
    '@copybrief getMarginType @see getMarginType']
parse_name: cv.ml.SVMSGD.setMarginType with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::setMarginType namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:setMarginType
register (method) setMarginType in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_setMarginType_int)

--- Incoming ---
[   'cv.ml.SVMSGD.getMarginRegularization',
    'float',
    ['/A', '/C'],
    [],
    None,
    '@see setMarginRegularization']
parse_name: cv.ml.SVMSGD.getMarginRegularization with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getMarginRegularization namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getMarginRegularization
register (method) getMarginRegularization in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getMarginRegularization_const)

--- Incoming ---
[   'cv.ml.SVMSGD.setMarginRegularization',
    'void',
    ['/A'],
    [['float', 'marginRegularization', '', []]],
    None,
    '@copybrief getMarginRegularization @see getMarginRegularization']
parse_name: cv.ml.SVMSGD.setMarginRegularization with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::setMarginRegularization namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:setMarginRegularization
register (method) setMarginRegularization in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_setMarginRegularization_float)

--- Incoming ---
[   'cv.ml.SVMSGD.getInitialStepSize',
    'float',
    ['/A', '/C'],
    [],
    None,
    '@see setInitialStepSize']
parse_name: cv.ml.SVMSGD.getInitialStepSize with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getInitialStepSize namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getInitialStepSize
register (method) getInitialStepSize in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getInitialStepSize_const)

--- Incoming ---
[   'cv.ml.SVMSGD.setInitialStepSize',
    'void',
    ['/A'],
    [['float', 'InitialStepSize', '', []]],
    None,
    '@copybrief getInitialStepSize @see getInitialStepSize']
parse_name: cv.ml.SVMSGD.setInitialStepSize with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::setInitialStepSize namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:setInitialStepSize
register (method) setInitialStepSize in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_setInitialStepSize_float)

--- Incoming ---
[   'cv.ml.SVMSGD.getStepDecreasingPower',
    'float',
    ['/A', '/C'],
    [],
    None,
    '@see setStepDecreasingPower']
parse_name: cv.ml.SVMSGD.getStepDecreasingPower with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getStepDecreasingPower namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getStepDecreasingPower
register (method) getStepDecreasingPower in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getStepDecreasingPower_const)

--- Incoming ---
[   'cv.ml.SVMSGD.setStepDecreasingPower',
    'void',
    ['/A'],
    [['float', 'stepDecreasingPower', '', []]],
    None,
    '@copybrief getStepDecreasingPower @see getStepDecreasingPower']
parse_name: cv.ml.SVMSGD.setStepDecreasingPower with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::setStepDecreasingPower namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:setStepDecreasingPower
register (method) setStepDecreasingPower in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_setStepDecreasingPower_float)

--- Incoming ---
[   'cv.ml.SVMSGD.getTermCriteria',
    'TermCriteria',
    ['/A', '/C'],
    [],
    None,
    '@see setTermCriteria']
parse_name: cv.ml.SVMSGD.getTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::getTermCriteria namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:getTermCriteria
register (method) getTermCriteria in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_getTermCriteria_const)

--- Incoming ---
[   'cv.ml.SVMSGD.setTermCriteria',
    'void',
    ['/A'],
    [['const cv::TermCriteria &', 'val', '', []]],
    None,
    '@copybrief getTermCriteria @see getTermCriteria']
parse_name: cv.ml.SVMSGD.setTermCriteria with ['cv', 'cv::ml'] -> fullname:cv::ml::SVMSGD::setTermCriteria namespace:cv::ml classpath:SVMSGD classname:SVMSGD name:setTermCriteria
register (method) setTermCriteria in cv::ml::SVMSGD (trait) (cv_ml_SVMSGD_setTermCriteria_TermCriteria)

--- Incoming ---
[   'cv.ml.randMVNormal',
    'void',
    [],
    [   ['InputArray', 'mean', '', []],
        ['InputArray', 'cov', '', []],
        ['int', 'nsamples', '', []],
        ['OutputArray', 'samples', '', []]],
    None,
    '@brief Generates _sample_ from multivariate normal distribution\n'
    '\n'
    '@param mean an average row vector\n'
    '@param cov symmetric covariation matrix\n'
    '@param nsamples returned samples count\n'
    '@param samples returned samples array']
parse_name: cv.ml.randMVNormal with ['cv', 'cv::ml'] -> fullname:cv::ml::randMVNormal namespace:cv::ml classpath: classname: name:randMVNormal
register (function) randMVNormal (cv_ml_randMVNormal__InputArray__InputArray_int__OutputArray)

--- Incoming ---
[   'cv.ml.createConcentricSpheresTestSet',
    'void',
    [],
    [   ['int', 'nsamples', '', []],
        ['int', 'nfeatures', '', []],
        ['int', 'nclasses', '', []],
        ['OutputArray', 'samples', '', []],
        ['OutputArray', 'responses', '', []]],
    None,
    '@brief Creates test set']
parse_name: cv.ml.createConcentricSpheresTestSet with ['cv', 'cv::ml'] -> fullname:cv::ml::createConcentricSpheresTestSet namespace:cv::ml classpath: classname: name:createConcentricSpheresTestSet
register (function) createConcentricSpheresTestSet (cv_ml_createConcentricSpheresTestSet_int_int_int__OutputArray__OutputArray)

--- Incoming ---
[   'struct cv.ml.SimulatedAnnealingSolverSystem',
    '',
    [],
    [],
    None,
    '@brief This class declares example interface for system state used in '
    'simulated annealing optimization algorithm.\n'
    '\n'
    "@note This class is not defined in C++ code and can't be use directly - "
    'you need your own implementation with the same methods.']
parse_name: struct cv.ml.SimulatedAnnealingSolverSystem with ['cv', 'cv::ml'] -> fullname:cv::ml::SimulatedAnnealingSolverSystem namespace:cv::ml classpath: classname: name:SimulatedAnnealingSolverSystem
register class cv::ml::SimulatedAnnealingSolverSystem (['struct cv.ml.SimulatedAnnealingSolverSystem', '', [], [], None, "@brief This class declares example interface for system state used in simulated annealing optimization algorithm.\n\n@note This class is not defined in C++ code and can't be use directly - you need your own implementation with the same methods."]) [ignored]

--- Incoming ---
[   'cv.ml.SimulatedAnnealingSolverSystem.energy',
    'double',
    ['/C'],
    [],
    None,
    'Give energy value for a state of system.']
parse_name: cv.ml.SimulatedAnnealingSolverSystem.energy with ['cv', 'cv::ml'] -> fullname:cv::ml::SimulatedAnnealingSolverSystem::energy namespace:cv::ml classpath:SimulatedAnnealingSolverSystem classname:SimulatedAnnealingSolverSystem name:energy
register (method) energy in cv::ml::SimulatedAnnealingSolverSystem (ignored) (cv_ml_SimulatedAnnealingSolverSystem_energy_const)

--- Incoming ---
[   'cv.ml.SimulatedAnnealingSolverSystem.changeState',
    'void',
    [],
    [],
    None,
    'Function which change the state of system (random perturbation).']
parse_name: cv.ml.SimulatedAnnealingSolverSystem.changeState with ['cv', 'cv::ml'] -> fullname:cv::ml::SimulatedAnnealingSolverSystem::changeState namespace:cv::ml classpath:SimulatedAnnealingSolverSystem classname:SimulatedAnnealingSolverSystem name:changeState
register (method) changeState in cv::ml::SimulatedAnnealingSolverSystem (ignored) (cv_ml_SimulatedAnnealingSolverSystem_changeState)

--- Incoming ---
[   'cv.ml.SimulatedAnnealingSolverSystem.reverseState',
    'void',
    [],
    [],
    None,
    'Function to reverse to the previous state. Can be called once only after '
    'changeState().']
parse_name: cv.ml.SimulatedAnnealingSolverSystem.reverseState with ['cv', 'cv::ml'] -> fullname:cv::ml::SimulatedAnnealingSolverSystem::reverseState namespace:cv::ml classpath:SimulatedAnnealingSolverSystem classname:SimulatedAnnealingSolverSystem name:reverseState
register (method) reverseState in cv::ml::SimulatedAnnealingSolverSystem (ignored) (cv_ml_SimulatedAnnealingSolverSystem_reverseState)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/ml/ml.hpp ================


Namespaces: ['cv', 'cv.ml']
Comment: {'ml': '\n@defgroup ml Machine Learning\n\nThe Machine Learning Library (MLL) is a set of classes and functions for statistical\nclassification, regression, and clustering of data.\n\nMost of the classification and regression algorithms are implemented as C++ classes. As the\nalgorithms have different sets of features (like an ability to handle missing measurements or\ncategorical input variables), there is a little common ground between the classes. This common\nground is defined by the class cv::ml::StatModel that all the other ML classes are derived from.\n\nSee detailed overview here: @ref ml_intro.\n\n'}


===== Generating... =====
Generating func cv_ml_createConcentricSpheresTestSet_int_int_int__OutputArray__OutputArray
Generating func cv_ml_randMVNormal__InputArray__InputArray_int__OutputArray
Ghost class cv::Algorithm (ghost, trait), ignoring
Ghost class cv::DMatch (simple, ghost), ignoring
Ghost class cv::DescriptorMatcher (ghost, trait), ignoring
Ghost class cv::Feature2D (ghost, trait), ignoring
Ghost class cv::FileNode (ghost), ignoring
Ghost class cv::FileStorage (ghost), ignoring
Ghost class cv::KeyPoint (simple, ghost), ignoring
Ghost class cv::Mat (ghost), ignoring
Ghost class cv::MatExpr (ghost), ignoring
Ghost class cv::Range (ghost), ignoring
Ghost class cv::RotatedRect (ghost), ignoring
Ghost class cv::TermCriteria (ghost), ignoring
Ghost class cv::UMat (ghost), ignoring
Ghost class cv::_InputArray (ghost, trait), ignoring
Ghost class cv::_InputOutputArray (ghost, trait), ignoring
Ghost class cv::_OutputArray (ghost, trait), ignoring
Ghost class cv::dnn::Layer (ghost, trait), ignoring
Ghost class cv::dnn::LayerParams (ghost), ignoring
Generating impl for trait cv::ml::ANN_MLP (trait)
Generating func cv_ml_ANN_MLP_setTrainMethod_int_double_double
Generating func cv_ml_ANN_MLP_getTrainMethod_const
Generating func cv_ml_ANN_MLP_setActivationFunction_int_double_double
Generating func cv_ml_ANN_MLP_setLayerSizes__InputArray
Generating func cv_ml_ANN_MLP_getLayerSizes_const
Generating func cv_ml_ANN_MLP_getTermCriteria_const
Generating func cv_ml_ANN_MLP_setTermCriteria_TermCriteria
Generating func cv_ml_ANN_MLP_getBackpropWeightScale_const
Generating func cv_ml_ANN_MLP_setBackpropWeightScale_double
Generating func cv_ml_ANN_MLP_getBackpropMomentumScale_const
Generating func cv_ml_ANN_MLP_setBackpropMomentumScale_double
Generating func cv_ml_ANN_MLP_getRpropDW0_const
Generating func cv_ml_ANN_MLP_setRpropDW0_double
Generating func cv_ml_ANN_MLP_getRpropDWPlus_const
Generating func cv_ml_ANN_MLP_setRpropDWPlus_double
Generating func cv_ml_ANN_MLP_getRpropDWMinus_const
Generating func cv_ml_ANN_MLP_setRpropDWMinus_double
Generating func cv_ml_ANN_MLP_getRpropDWMin_const
Generating func cv_ml_ANN_MLP_setRpropDWMin_double
Generating func cv_ml_ANN_MLP_getRpropDWMax_const
Generating func cv_ml_ANN_MLP_setRpropDWMax_double
Generating func cv_ml_ANN_MLP_getAnnealInitialT_const
Generating func cv_ml_ANN_MLP_setAnnealInitialT_double
Generating func cv_ml_ANN_MLP_getAnnealFinalT_const
Generating func cv_ml_ANN_MLP_setAnnealFinalT_double
Generating func cv_ml_ANN_MLP_getAnnealCoolingRatio_const
Generating func cv_ml_ANN_MLP_setAnnealCoolingRatio_double
Generating func cv_ml_ANN_MLP_getAnnealItePerStep_const
Generating func cv_ml_ANN_MLP_setAnnealItePerStep_int
Generating func cv_ml_ANN_MLP_setAnnealEnergyRNG_RNG
  ignored: can not map type Unknown[RNG] yet
Generating func cv_ml_ANN_MLP_getWeights_const_int
Generating func cv_ml_ANN_MLP_create
Generating func cv_ml_ANN_MLP_load_String
Generating impl for trait cv::ml::Boost (trait)
Generating func cv_ml_Boost_getBoostType_const
Generating func cv_ml_Boost_setBoostType_int
Generating func cv_ml_Boost_getWeakCount_const
Generating func cv_ml_Boost_setWeakCount_int
Generating func cv_ml_Boost_getWeightTrimRate_const
Generating func cv_ml_Boost_setWeightTrimRate_double
Generating func cv_ml_Boost_create
Generating func cv_ml_Boost_load_String_String
Generating impl for trait cv::ml::DTrees (trait)
Generating func cv_ml_DTrees_getMaxCategories_const
Generating func cv_ml_DTrees_setMaxCategories_int
Generating func cv_ml_DTrees_getMaxDepth_const
Generating func cv_ml_DTrees_setMaxDepth_int
Generating func cv_ml_DTrees_getMinSampleCount_const
Generating func cv_ml_DTrees_setMinSampleCount_int
Generating func cv_ml_DTrees_getCVFolds_const
Generating func cv_ml_DTrees_setCVFolds_int
Generating func cv_ml_DTrees_getUseSurrogates_const
Generating func cv_ml_DTrees_setUseSurrogates_bool
Generating func cv_ml_DTrees_getUse1SERule_const
Generating func cv_ml_DTrees_setUse1SERule_bool
Generating func cv_ml_DTrees_getTruncatePrunedTree_const
Generating func cv_ml_DTrees_setTruncatePrunedTree_bool
Generating func cv_ml_DTrees_getRegressionAccuracy_const
Generating func cv_ml_DTrees_setRegressionAccuracy_float
Generating func cv_ml_DTrees_getPriors_const
Generating func cv_ml_DTrees_setPriors_Mat
Generating func cv_ml_DTrees_getRoots_const
Generating func cv_ml_DTrees_getNodes_const
Generating func cv_ml_DTrees_getSplits_const
Generating func cv_ml_DTrees_getSubsets_const
Generating func cv_ml_DTrees_create
Generating func cv_ml_DTrees_load_String_String
Generating box for cv::ml::DTrees::Node
Generating func cv_ml_DTrees_Node_Node
Generating box for cv::ml::DTrees::Split
Generating func cv_ml_DTrees_Split_Split
Generating impl for trait cv::ml::EM (trait)
Generating func cv_ml_EM_getClustersNumber_const
Generating func cv_ml_EM_setClustersNumber_int
Generating func cv_ml_EM_getCovarianceMatrixType_const
Generating func cv_ml_EM_setCovarianceMatrixType_int
Generating func cv_ml_EM_getTermCriteria_const
Generating func cv_ml_EM_setTermCriteria_TermCriteria
Generating func cv_ml_EM_getWeights_const
Generating func cv_ml_EM_getMeans_const
Generating func cv_ml_EM_getCovs_const_VectorOfMat
Generating func cv_ml_EM_predict_const__InputArray__OutputArray_int
Generating func cv_ml_EM_predict2_const__InputArray__OutputArray
Generating func cv_ml_EM_trainEM__InputArray__OutputArray__OutputArray__OutputArray
Generating func cv_ml_EM_trainE__InputArray__InputArray__InputArray__InputArray__OutputArray__OutputArray__OutputArray
Generating func cv_ml_EM_trainM__InputArray__InputArray__OutputArray__OutputArray__OutputArray
Generating func cv_ml_EM_create
Generating func cv_ml_EM_load_String_String
Generating impl for trait cv::ml::KNearest (trait)
Generating func cv_ml_KNearest_getDefaultK_const
Generating func cv_ml_KNearest_setDefaultK_int
Generating func cv_ml_KNearest_getIsClassifier_const
Generating func cv_ml_KNearest_setIsClassifier_bool
Generating func cv_ml_KNearest_getEmax_const
Generating func cv_ml_KNearest_setEmax_int
Generating func cv_ml_KNearest_getAlgorithmType_const
Generating func cv_ml_KNearest_setAlgorithmType_int
Generating func cv_ml_KNearest_findNearest_const__InputArray_int__OutputArray__OutputArray__OutputArray
Generating func cv_ml_KNearest_create
Generating func cv_ml_KNearest_load_String
Generating impl for trait cv::ml::LogisticRegression (trait)
Generating func cv_ml_LogisticRegression_getLearningRate_const
Generating func cv_ml_LogisticRegression_setLearningRate_double
Generating func cv_ml_LogisticRegression_getIterations_const
Generating func cv_ml_LogisticRegression_setIterations_int
Generating func cv_ml_LogisticRegression_getRegularization_const
Generating func cv_ml_LogisticRegression_setRegularization_int
Generating func cv_ml_LogisticRegression_getTrainMethod_const
Generating func cv_ml_LogisticRegression_setTrainMethod_int
Generating func cv_ml_LogisticRegression_getMiniBatchSize_const
Generating func cv_ml_LogisticRegression_setMiniBatchSize_int
Generating func cv_ml_LogisticRegression_getTermCriteria_const
Generating func cv_ml_LogisticRegression_setTermCriteria_TermCriteria
Generating func cv_ml_LogisticRegression_predict_const__InputArray__OutputArray_int
Generating func cv_ml_LogisticRegression_get_learnt_thetas_const
Generating func cv_ml_LogisticRegression_create
Generating func cv_ml_LogisticRegression_load_String_String
Generating impl for trait cv::ml::NormalBayesClassifier (trait)
Generating func cv_ml_NormalBayesClassifier_predictProb_const__InputArray__OutputArray__OutputArray_int
Generating func cv_ml_NormalBayesClassifier_create
Generating func cv_ml_NormalBayesClassifier_load_String_String
Generating box for cv::ml::ParamGrid
Generating func cv_ml_ParamGrid_minVal_const
Generating func cv_ml_ParamGrid_maxVal_const
Generating func cv_ml_ParamGrid_logStep_const
Generating func cv_ml_ParamGrid_ParamGrid
Generating func cv_ml_ParamGrid_ParamGrid_double_double_double
Generating func cv_ml_ParamGrid_create_double_double_double
Generating impl for trait cv::ml::RTrees (trait)
Generating func cv_ml_RTrees_getCalculateVarImportance_const
Generating func cv_ml_RTrees_setCalculateVarImportance_bool
Generating func cv_ml_RTrees_getActiveVarCount_const
Generating func cv_ml_RTrees_setActiveVarCount_int
Generating func cv_ml_RTrees_getTermCriteria_const
Generating func cv_ml_RTrees_setTermCriteria_TermCriteria
Generating func cv_ml_RTrees_getVarImportance_const
Generating func cv_ml_RTrees_getVotes_const__InputArray__OutputArray_int
Generating func cv_ml_RTrees_create
Generating func cv_ml_RTrees_load_String_String
Generating impl for trait cv::ml::SVM (trait)
Generating func cv_ml_SVM_getType_const
Generating func cv_ml_SVM_setType_int
Generating func cv_ml_SVM_getGamma_const
Generating func cv_ml_SVM_setGamma_double
Generating func cv_ml_SVM_getCoef0_const
Generating func cv_ml_SVM_setCoef0_double
Generating func cv_ml_SVM_getDegree_const
Generating func cv_ml_SVM_setDegree_double
Generating func cv_ml_SVM_getC_const
Generating func cv_ml_SVM_setC_double
Generating func cv_ml_SVM_getNu_const
Generating func cv_ml_SVM_setNu_double
Generating func cv_ml_SVM_getP_const
Generating func cv_ml_SVM_setP_double
Generating func cv_ml_SVM_getClassWeights_const
Generating func cv_ml_SVM_setClassWeights_Mat
Generating func cv_ml_SVM_getTermCriteria_const
Generating func cv_ml_SVM_setTermCriteria_TermCriteria
Generating func cv_ml_SVM_getKernelType_const
Generating func cv_ml_SVM_setKernel_int
Generating func cv_ml_SVM_setCustomKernel_PtrOfKernel
Generating func cv_ml_SVM_trainAuto_PtrOfTrainData_int_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_bool
Generating func cv_ml_SVM_trainAuto__InputArray_int__InputArray_int_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_PtrOfParamGrid_bool
Generating func cv_ml_SVM_getSupportVectors_const
Generating func cv_ml_SVM_getUncompressedSupportVectors_const
Generating func cv_ml_SVM_getDecisionFunction_const_int__OutputArray__OutputArray
Generating func cv_ml_SVM_getDefaultGrid_int
Generating func cv_ml_SVM_getDefaultGridPtr_int
Generating func cv_ml_SVM_create
Generating func cv_ml_SVM_load_String
Generating impl for trait cv::ml::SVM::Kernel (trait)
Generating func cv_ml_SVM_Kernel_getType_const
Generating func cv_ml_SVM_Kernel_calc_int_int_const_float_X_const_float_X_float_X
Generating impl for trait cv::ml::SVMSGD (trait)
Generating func cv_ml_SVMSGD_getWeights
Generating func cv_ml_SVMSGD_getShift
Generating func cv_ml_SVMSGD_setOptimalParameters_int_int
Generating func cv_ml_SVMSGD_getSvmsgdType_const
Generating func cv_ml_SVMSGD_setSvmsgdType_int
Generating func cv_ml_SVMSGD_getMarginType_const
Generating func cv_ml_SVMSGD_setMarginType_int
Generating func cv_ml_SVMSGD_getMarginRegularization_const
Generating func cv_ml_SVMSGD_setMarginRegularization_float
Generating func cv_ml_SVMSGD_getInitialStepSize_const
Generating func cv_ml_SVMSGD_setInitialStepSize_float
Generating func cv_ml_SVMSGD_getStepDecreasingPower_const
Generating func cv_ml_SVMSGD_setStepDecreasingPower_float
Generating func cv_ml_SVMSGD_getTermCriteria_const
Generating func cv_ml_SVMSGD_setTermCriteria_TermCriteria
Generating func cv_ml_SVMSGD_create
Generating func cv_ml_SVMSGD_load_String_String
Manual ignore class cv::ml::SimulatedAnnealingSolverSystem (ignored)
Generating impl for trait cv::ml::StatModel (trait)
Generating func cv_ml_StatModel_getVarCount_const
Generating func cv_ml_StatModel_empty_const
Generating func cv_ml_StatModel_isTrained_const
Generating func cv_ml_StatModel_isClassifier_const
Generating func cv_ml_StatModel_train_PtrOfTrainData_int
Generating func cv_ml_StatModel_train__InputArray_int__InputArray
Generating func cv_ml_StatModel_calcError_const_PtrOfTrainData_bool__OutputArray
Generating func cv_ml_StatModel_predict_const__InputArray__OutputArray_int
Generating func cv_ml_StatModel_Ptr_<__Tp_>_train_PtrOfTrainData_int
  ignored: return type class Unknown[template<typename _Tp> static Ptr<_Tp>] is ignored
Generating impl for trait cv::ml::TrainData (trait)
Generating func cv_ml_TrainData_missingValue
Generating func cv_ml_TrainData_getLayout_const
Generating func cv_ml_TrainData_getNTrainSamples_const
Generating func cv_ml_TrainData_getNTestSamples_const
Generating func cv_ml_TrainData_getNSamples_const
Generating func cv_ml_TrainData_getNVars_const
Generating func cv_ml_TrainData_getNAllVars_const
Generating func cv_ml_TrainData_getSample_const__InputArray_int_float_X
Generating func cv_ml_TrainData_getSamples_const
Generating func cv_ml_TrainData_getMissing_const
Generating func cv_ml_TrainData_getTrainSamples_const_int_bool_bool
Generating func cv_ml_TrainData_getTrainResponses_const
Generating func cv_ml_TrainData_getTrainNormCatResponses_const
Generating func cv_ml_TrainData_getTestResponses_const
Generating func cv_ml_TrainData_getTestNormCatResponses_const
Generating func cv_ml_TrainData_getResponses_const
Generating func cv_ml_TrainData_getNormCatResponses_const
Generating func cv_ml_TrainData_getSampleWeights_const
Generating func cv_ml_TrainData_getTrainSampleWeights_const
Generating func cv_ml_TrainData_getTestSampleWeights_const
Generating func cv_ml_TrainData_getVarIdx_const
Generating func cv_ml_TrainData_getVarType_const
Generating func cv_ml_TrainData_getVarSymbolFlags_const
Generating func cv_ml_TrainData_getResponseType_const
Generating func cv_ml_TrainData_getTrainSampleIdx_const
Generating func cv_ml_TrainData_getTestSampleIdx_const
Generating func cv_ml_TrainData_getValues_const_int__InputArray_float_X
Generating func cv_ml_TrainData_getNormCatValues_const_int__InputArray_int_X
Generating func cv_ml_TrainData_getDefaultSubstValues_const
Generating func cv_ml_TrainData_getCatCount_const_int
Generating func cv_ml_TrainData_getClassLabels_const
Generating func cv_ml_TrainData_getCatOfs_const
Generating func cv_ml_TrainData_getCatMap_const
Generating func cv_ml_TrainData_setTrainTestSplit_int_bool
Generating func cv_ml_TrainData_setTrainTestSplitRatio_double_bool
Generating func cv_ml_TrainData_shuffleTrainTest
Generating func cv_ml_TrainData_getTestSamples_const
Generating func cv_ml_TrainData_getNames_const_VectorOfString
Generating func cv_ml_TrainData_getSubVector_Mat_Mat
Generating func cv_ml_TrainData_getSubMatrix_Mat_Mat_int
Generating func cv_ml_TrainData_loadFromCSV_String_int_int_int_String_char_char
Generating func cv_ml_TrainData_create__InputArray_int__InputArray__InputArray__InputArray__InputArray__InputArray
Ghost class cv::utils::logging::LogTag (ghost), ignoring
