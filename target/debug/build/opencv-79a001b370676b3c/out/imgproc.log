
--- Manual ---
('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']])
parse_name: class cv.Vec8i with ['cv'] -> fullname:cv::Vec8i namespace:cv classpath: classname: name:Vec8i
register class cv::Vec8i (('class cv.Vec8i', '', ['/Simple'], [['int', 'data[8]', '', '/RW']]))

--- Manual ---
('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6d with ['cv'] -> fullname:cv::Vec6d namespace:cv classpath: classname: name:Vec6d
register class cv::Vec6d (('class cv.Vec6d', '', ['/Simple'], [['double', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6f with ['cv'] -> fullname:cv::Vec6f namespace:cv classpath: classname: name:Vec6f
register class cv::Vec6f (('class cv.Vec6f', '', ['/Simple'], [['float', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']])
parse_name: class cv.Vec6i with ['cv'] -> fullname:cv::Vec6i namespace:cv classpath: classname: name:Vec6i
register class cv::Vec6i (('class cv.Vec6i', '', ['/Simple'], [['int', 'data[6]', '', '/RW']]))

--- Manual ---
('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4d with ['cv'] -> fullname:cv::Vec4d namespace:cv classpath: classname: name:Vec4d
register class cv::Vec4d (('class cv.Vec4d', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4f with ['cv'] -> fullname:cv::Vec4f namespace:cv classpath: classname: name:Vec4f
register class cv::Vec4f (('class cv.Vec4f', '', ['/Simple'], [['float', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4i with ['cv'] -> fullname:cv::Vec4i namespace:cv classpath: classname: name:Vec4i
register class cv::Vec4i (('class cv.Vec4i', '', ['/Simple'], [['int', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4w with ['cv'] -> fullname:cv::Vec4w namespace:cv classpath: classname: name:Vec4w
register class cv::Vec4w (('class cv.Vec4w', '', ['/Simple'], [['unsigned short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4s with ['cv'] -> fullname:cv::Vec4s namespace:cv classpath: classname: name:Vec4s
register class cv::Vec4s (('class cv.Vec4s', '', ['/Simple'], [['short', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']])
parse_name: class cv.Vec4b with ['cv'] -> fullname:cv::Vec4b namespace:cv classpath: classname: name:Vec4b
register class cv::Vec4b (('class cv.Vec4b', '', ['/Simple'], [['unsigned char', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3d with ['cv'] -> fullname:cv::Vec3d namespace:cv classpath: classname: name:Vec3d
register class cv::Vec3d (('class cv.Vec3d', '', ['/Simple'], [['double', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3f with ['cv'] -> fullname:cv::Vec3f namespace:cv classpath: classname: name:Vec3f
register class cv::Vec3f (('class cv.Vec3f', '', ['/Simple'], [['float', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3i with ['cv'] -> fullname:cv::Vec3i namespace:cv classpath: classname: name:Vec3i
register class cv::Vec3i (('class cv.Vec3i', '', ['/Simple'], [['int', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3w with ['cv'] -> fullname:cv::Vec3w namespace:cv classpath: classname: name:Vec3w
register class cv::Vec3w (('class cv.Vec3w', '', ['/Simple'], [['unsigned short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3s with ['cv'] -> fullname:cv::Vec3s namespace:cv classpath: classname: name:Vec3s
register class cv::Vec3s (('class cv.Vec3s', '', ['/Simple'], [['short', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']])
parse_name: class cv.Vec3b with ['cv'] -> fullname:cv::Vec3b namespace:cv classpath: classname: name:Vec3b
register class cv::Vec3b (('class cv.Vec3b', '', ['/Simple'], [['unsigned char', 'data[3]', '', '/RW']]))

--- Manual ---
('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2d with ['cv'] -> fullname:cv::Vec2d namespace:cv classpath: classname: name:Vec2d
register class cv::Vec2d (('class cv.Vec2d', '', ['/Simple'], [['double', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2d',
    '',
    ['/Simple'],
    [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']])
parse_name: class cv.Size2d with ['cv'] -> fullname:cv::Size2d namespace:cv classpath: classname: name:Size2d
register class cv::Size2d (('class cv.Size2d', '', ['/Simple'], [['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2d',
    '',
    ['/Simple'],
    [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']])
parse_name: class cv.Point2d with ['cv'] -> fullname:cv::Point2d namespace:cv classpath: classname: name:Point2d
register class cv::Point2d (('class cv.Point2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2d',
    '',
    ['/Simple'],
    [   ['double', 'x', '', '/RW'],
        ['double', 'y', '', '/RW'],
        ['double', 'width', '', '/RW'],
        ['double', 'height', '', '/RW']])
parse_name: class cv.Rect2d with ['cv'] -> fullname:cv::Rect2d namespace:cv classpath: classname: name:Rect2d
register class cv::Rect2d (('class cv.Rect2d', '', ['/Simple'], [['double', 'x', '', '/RW'], ['double', 'y', '', '/RW'], ['double', 'width', '', '/RW'], ['double', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2f with ['cv'] -> fullname:cv::Vec2f namespace:cv classpath: classname: name:Vec2f
register class cv::Vec2f (('class cv.Vec2f', '', ['/Simple'], [['float', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2f',
    '',
    ['/Simple'],
    [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']])
parse_name: class cv.Size2f with ['cv'] -> fullname:cv::Size2f namespace:cv classpath: classname: name:Size2f
register class cv::Size2f (('class cv.Size2f', '', ['/Simple'], [['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2f',
    '',
    ['/Simple'],
    [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']])
parse_name: class cv.Point2f with ['cv'] -> fullname:cv::Point2f namespace:cv classpath: classname: name:Point2f
register class cv::Point2f (('class cv.Point2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2f',
    '',
    ['/Simple'],
    [   ['float', 'x', '', '/RW'],
        ['float', 'y', '', '/RW'],
        ['float', 'width', '', '/RW'],
        ['float', 'height', '', '/RW']])
parse_name: class cv.Rect2f with ['cv'] -> fullname:cv::Rect2f namespace:cv classpath: classname: name:Rect2f
register class cv::Rect2f (('class cv.Rect2f', '', ['/Simple'], [['float', 'x', '', '/RW'], ['float', 'y', '', '/RW'], ['float', 'width', '', '/RW'], ['float', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size2l',
    '',
    ['/Simple'],
    [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']])
parse_name: class cv.Size2l with ['cv'] -> fullname:cv::Size2l namespace:cv classpath: classname: name:Size2l
register class cv::Size2l (('class cv.Size2l', '', ['/Simple'], [['int64', 'width', '', '/RW'], ['int64', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2l',
    '',
    ['/Simple'],
    [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']])
parse_name: class cv.Point2l with ['cv'] -> fullname:cv::Point2l namespace:cv classpath: classname: name:Point2l
register class cv::Point2l (('class cv.Point2l', '', ['/Simple'], [['int64', 'x', '', '/RW'], ['int64', 'y', '', '/RW']]))

--- Manual ---
('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2i with ['cv'] -> fullname:cv::Vec2i namespace:cv classpath: classname: name:Vec2i
register class cv::Vec2i (('class cv.Vec2i', '', ['/Simple'], [['int', 'data[2]', '', '/RW']]))

--- Manual ---
(   'class cv.Size2i',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size2i with ['cv'] -> fullname:cv::Size2i namespace:cv classpath: classname: name:Size2i
register class cv::Size2i (('class cv.Size2i', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point2i',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point2i with ['cv'] -> fullname:cv::Point2i namespace:cv classpath: classname: name:Point2i
register class cv::Point2i (('class cv.Point2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect2i',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect2i with ['cv'] -> fullname:cv::Rect2i namespace:cv classpath: classname: name:Rect2i
register class cv::Rect2i (('class cv.Rect2i', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Size',
    '',
    ['/Simple'],
    [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']])
parse_name: class cv.Size with ['cv'] -> fullname:cv::Size namespace:cv classpath: classname: name:Size
register class cv::Size (('class cv.Size', '', ['/Simple'], [['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
(   'class cv.Point',
    '',
    ['/Simple'],
    [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']])
parse_name: class cv.Point with ['cv'] -> fullname:cv::Point namespace:cv classpath: classname: name:Point
register class cv::Point (('class cv.Point', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW']]))

--- Manual ---
(   'class cv.Rect',
    '',
    ['/Simple'],
    [   ['int', 'x', '', '/RW'],
        ['int', 'y', '', '/RW'],
        ['int', 'width', '', '/RW'],
        ['int', 'height', '', '/RW']])
parse_name: class cv.Rect with ['cv'] -> fullname:cv::Rect namespace:cv classpath: classname: name:Rect
register class cv::Rect (('class cv.Rect', '', ['/Simple'], [['int', 'x', '', '/RW'], ['int', 'y', '', '/RW'], ['int', 'width', '', '/RW'], ['int', 'height', '', '/RW']]))

--- Manual ---
('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2w with ['cv'] -> fullname:cv::Vec2w namespace:cv classpath: classname: name:Vec2w
register class cv::Vec2w (('class cv.Vec2w', '', ['/Simple'], [['unsigned short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2s with ['cv'] -> fullname:cv::Vec2s namespace:cv classpath: classname: name:Vec2s
register class cv::Vec2s (('class cv.Vec2s', '', ['/Simple'], [['short', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']])
parse_name: class cv.Vec2b with ['cv'] -> fullname:cv::Vec2b namespace:cv classpath: classname: name:Vec2b
register class cv::Vec2b (('class cv.Vec2b', '', ['/Simple'], [['unsigned char', 'data[2]', '', '/RW']]))

--- Manual ---
('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']])
parse_name: class cv.Scalar with ['cv'] -> fullname:cv::Scalar namespace:cv classpath: classname: name:Scalar
register class cv::Scalar (('class cv.Scalar', '', ['/Simple'], [['double', 'data[4]', '', '/RW']]))

--- Manual ---
('class cv._InputArray', '', ['/Ghost'], [])
parse_name: class cv._InputArray with ['cv'] -> fullname:cv::_InputArray namespace:cv classpath: classname: name:_InputArray
register class cv::_InputArray (('class cv._InputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputArray', 'const _InputArray&', [], [])
parse_name: typedef cv.InputArray with ['cv'] -> fullname:cv::InputArray namespace:cv classpath: classname: name:InputArray
Registering an unknown type: InputArray

--- Manual ---
('class cv._OutputArray', '', ['/Ghost'], [])
parse_name: class cv._OutputArray with ['cv'] -> fullname:cv::_OutputArray namespace:cv classpath: classname: name:_OutputArray
register class cv::_OutputArray (('class cv._OutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.OutputArray', '_OutputArray&', [], [])
parse_name: typedef cv.OutputArray with ['cv'] -> fullname:cv::OutputArray namespace:cv classpath: classname: name:OutputArray
Registering an unknown type: OutputArray

--- Manual ---
('class cv._InputOutputArray', '', ['/Ghost'], [])
parse_name: class cv._InputOutputArray with ['cv'] -> fullname:cv::_InputOutputArray namespace:cv classpath: classname: name:_InputOutputArray
register class cv::_InputOutputArray (('class cv._InputOutputArray', '', ['/Ghost'], []))

--- Manual ---
('typedef cv.InputOutputArray', '_InputOutputArray&', [], [])
parse_name: typedef cv.InputOutputArray with ['cv'] -> fullname:cv::InputOutputArray namespace:cv classpath: classname: name:InputOutputArray
Registering an unknown type: InputOutputArray

--- Manual ---
('typedef cv.InputArrayOfArrays', 'InputArray', [], [])
parse_name: typedef cv.InputArrayOfArrays with ['cv'] -> fullname:cv::InputArrayOfArrays namespace:cv classpath: classname: name:InputArrayOfArrays
Registering an unknown type: InputArrayOfArrays

--- Manual ---
('typedef cv.OutputArrayOfArrays', 'OutputArray', [], [])
parse_name: typedef cv.OutputArrayOfArrays with ['cv'] -> fullname:cv::OutputArrayOfArrays namespace:cv classpath: classname: name:OutputArrayOfArrays
Registering an unknown type: OutputArrayOfArrays

--- Manual ---
('typedef cv.InputOutputArrayOfArrays', 'InputOutputArray', [], [])
parse_name: typedef cv.InputOutputArrayOfArrays with ['cv'] -> fullname:cv::InputOutputArrayOfArrays namespace:cv classpath: classname: name:InputOutputArrayOfArrays
Registering an unknown type: InputOutputArrayOfArrays

--- Manual ---
('class cv.Range', '', ['/Ghost'], [])
parse_name: class cv.Range with ['cv'] -> fullname:cv::Range namespace:cv classpath: classname: name:Range
register class cv::Range (('class cv.Range', '', ['/Ghost'], []))

--- Manual ---
('class cv.MatExpr', '', ['/Ghost'], [])
parse_name: class cv.MatExpr with ['cv'] -> fullname:cv::MatExpr namespace:cv classpath: classname: name:MatExpr
register class cv::MatExpr (('class cv.MatExpr', '', ['/Ghost'], []))

--- Manual ---
('class cv.Mat', '', ['/Ghost'], [])
parse_name: class cv.Mat with ['cv'] -> fullname:cv::Mat namespace:cv classpath: classname: name:Mat
register class cv::Mat (('class cv.Mat', '', ['/Ghost'], []))

--- Manual ---
('class cv.UMat', '', ['/Ghost'], [])
parse_name: class cv.UMat with ['cv'] -> fullname:cv::UMat namespace:cv classpath: classname: name:UMat
register class cv::UMat (('class cv.UMat', '', ['/Ghost'], []))

--- Manual ---
('class cv.Algorithm', '', ['/Ghost'], [])
parse_name: class cv.Algorithm with ['cv'] -> fullname:cv::Algorithm namespace:cv classpath: classname: name:Algorithm
register class cv::Algorithm (('class cv.Algorithm', '', ['/Ghost'], []))

--- Manual ---
('class cv.DMatch', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.DMatch with ['cv'] -> fullname:cv::DMatch namespace:cv classpath: classname: name:DMatch
register class cv::DMatch (('class cv.DMatch', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.KeyPoint', '', ['/Ghost', '/Simple'], [])
parse_name: class cv.KeyPoint with ['cv'] -> fullname:cv::KeyPoint namespace:cv classpath: classname: name:KeyPoint
register class cv::KeyPoint (('class cv.KeyPoint', '', ['/Ghost', '/Simple'], []))

--- Manual ---
('class cv.RotatedRect', '', ['/Ghost'], [])
parse_name: class cv.RotatedRect with ['cv'] -> fullname:cv::RotatedRect namespace:cv classpath: classname: name:RotatedRect
register class cv::RotatedRect (('class cv.RotatedRect', '', ['/Ghost'], []))

--- Manual ---
('class cv.TermCriteria', '', ['/Ghost'], [])
parse_name: class cv.TermCriteria with ['cv'] -> fullname:cv::TermCriteria namespace:cv classpath: classname: name:TermCriteria
register class cv::TermCriteria (('class cv.TermCriteria', '', ['/Ghost'], []))

--- Manual ---
('class cv.utils.logging.LogTag', '', ['/Ghost'], [])
parse_name: class cv.utils.logging.LogTag with ['cv'] -> fullname:cv::utils::logging::LogTag namespace:cv classpath:utils::logging classname:logging name:LogTag
register class cv::utils::logging::LogTag (('class cv.utils.logging.LogTag', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileNode', '', ['/Ghost'], [])
parse_name: class cv.FileNode with ['cv'] -> fullname:cv::FileNode namespace:cv classpath: classname: name:FileNode
register class cv::FileNode (('class cv.FileNode', '', ['/Ghost'], []))

--- Manual ---
('class cv.FileStorage', '', ['/Ghost'], [])
parse_name: class cv.FileStorage with ['cv'] -> fullname:cv::FileStorage namespace:cv classpath: classname: name:FileStorage
register class cv::FileStorage (('class cv.FileStorage', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.LayerParams', '', ['/Ghost'], [])
parse_name: class cv.dnn.LayerParams with ['cv'] -> fullname:cv::dnn::LayerParams namespace:cv classpath:dnn classname:dnn name:LayerParams
register class cv::dnn::LayerParams (('class cv.dnn.LayerParams', '', ['/Ghost'], []))

--- Manual ---
('class cv.dnn.Layer', '', ['/Ghost'], [])
parse_name: class cv.dnn.Layer with ['cv'] -> fullname:cv::dnn::Layer namespace:cv classpath:dnn classname:dnn name:Layer
register class cv::dnn::Layer (('class cv.dnn.Layer', '', ['/Ghost'], []))

--- Manual ---
('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])
parse_name: class cv.Feature2D with ['cv'] -> fullname:cv::Feature2D namespace:cv classpath: classname: name:Feature2D
register class cv::Feature2D (('class cv.Feature2D', ': cv::Algorithm', ['/Ghost'], [])) impl:cv::Algorithm

--- Manual ---
('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])
parse_name: class cv.DescriptorMatcher with ['cv'] -> fullname:cv::DescriptorMatcher namespace:cv classpath: classname: name:DescriptorMatcher
register class cv::DescriptorMatcher (('class cv.DescriptorMatcher', ': cv::Algorithm', ['/Ghost', '/A'], [])) impl:cv::Algorithm

--- Manual ---
('typedef cv.FeatureDetector', 'Feature2D', [], [])
parse_name: typedef cv.FeatureDetector with ['cv'] -> fullname:cv::FeatureDetector namespace:cv classpath: classname: name:FeatureDetector
Registering an unknown type: FeatureDetector

--- Manual ---
('typedef cv.DescriptorExtractor', 'Feature2D', [], [])
parse_name: typedef cv.DescriptorExtractor with ['cv'] -> fullname:cv::DescriptorExtractor namespace:cv classpath: classname: name:DescriptorExtractor
Registering an unknown type: DescriptorExtractor

--- Manual ---
('enum cv.InterpolationFlags', '', ['/Ghost'], [])
parse_name: enum cv.InterpolationFlags with ['cv'] -> fullname:cv::InterpolationFlags namespace:cv classpath: classname: name:InterpolationFlags


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/imgproc.hpp ================


Namespaces: ['cv']
Comment: {'imgproc': '\n@defgroup imgproc Image Processing\n\nThis module includes image-processing functions.\n\n@{\n@defgroup imgproc_filter Image Filtering\n\nFunctions and classes described in this section are used to perform various linear or non-linear\nfiltering operations on 2D images (represented as Mat\'s). It means that for each pixel location\n\\f$(x,y)\\f$ in the source image (normally, rectangular), its neighborhood is considered and used to\ncompute the response. In case of a linear filter, it is a weighted sum of pixel values. In case of\nmorphological operations, it is the minimum or maximum values, and so on. The computed response is\nstored in the destination image at the same location \\f$(x,y)\\f$. It means that the output image\nwill be of the same size as the input image. Normally, the functions support multi-channel arrays,\nin which case every channel is processed independently. Therefore, the output image will also have\nthe same number of channels as the input one.\n\nAnother common feature of the functions and classes described in this section is that, unlike\nsimple arithmetic functions, they need to extrapolate values of some non-existing pixels. For\nexample, if you want to smooth an image using a Gaussian \\f$3 \\times 3\\f$ filter, then, when\nprocessing the left-most pixels in each row, you need pixels to the left of them, that is, outside\nof the image. You can let these pixels be the same as the left-most image pixels ("replicated\nborder" extrapolation method), or assume that all the non-existing pixels are zeros ("constant\nborder" extrapolation method), and so on. OpenCV enables you to specify the extrapolation method.\nFor details, see #BorderTypes\n\n@anchor filter_depths\n### Depth combinations\nInput depth (src.depth()) | Output depth (ddepth)\n--------------------------|----------------------\nCV_8U                     | -1/CV_16S/CV_32F/CV_64F\nCV_16U/CV_16S             | -1/CV_32F/CV_64F\nCV_32F                    | -1/CV_32F/CV_64F\nCV_64F                    | -1/CV_64F\n\n@note when ddepth=-1, the output image will have the same depth as the source.\n\n@defgroup imgproc_transform Geometric Image Transformations\n\nThe functions in this section perform various geometrical transformations of 2D images. They do not\nchange the image content but deform the pixel grid and map this deformed grid to the destination\nimage. In fact, to avoid sampling artifacts, the mapping is done in the reverse order, from\ndestination to the source. That is, for each pixel \\f$(x, y)\\f$ of the destination image, the\nfunctions compute coordinates of the corresponding "donor" pixel in the source image and copy the\npixel value:\n\n\\f[\\texttt{dst} (x,y)= \\texttt{src} (f_x(x,y), f_y(x,y))\\f]\n\nIn case when you specify the forward mapping \\f$\\left<g_x, g_y\\right>: \\texttt{src} \\rightarrow\n\\texttt{dst}\\f$, the OpenCV functions first compute the corresponding inverse mapping\n\\f$\\left<f_x, f_y\\right>: \\texttt{dst} \\rightarrow \\texttt{src}\\f$ and then use the above formula.\n\nThe actual implementations of the geometrical transformations, from the most generic remap and to\nthe simplest and the fastest resize, need to solve two main problems with the above formula:\n\n- Extrapolation of non-existing pixels. Similarly to the filtering functions described in the\nprevious section, for some \\f$(x,y)\\f$, either one of \\f$f_x(x,y)\\f$, or \\f$f_y(x,y)\\f$, or both\nof them may fall outside of the image. In this case, an extrapolation method needs to be used.\nOpenCV provides the same selection of extrapolation methods as in the filtering functions. In\naddition, it provides the method #BORDER_TRANSPARENT. This means that the corresponding pixels in\nthe destination image will not be modified at all.\n\n- Interpolation of pixel values. Usually \\f$f_x(x,y)\\f$ and \\f$f_y(x,y)\\f$ are floating-point\nnumbers. This means that \\f$\\left<f_x, f_y\\right>\\f$ can be either an affine or perspective\ntransformation, or radial lens distortion correction, and so on. So, a pixel value at fractional\ncoordinates needs to be retrieved. In the simplest case, the coordinates can be just rounded to the\nnearest integer coordinates and the corresponding pixel can be used. This is called a\nnearest-neighbor interpolation. However, a better result can be achieved by using more\nsophisticated [interpolation methods](http://en.wikipedia.org/wiki/Multivariate_interpolation) ,\nwhere a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\nf_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\ninterpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\nresize for details.\n\n@note The geometrical transformations do not work with `CV_8S` or `CV_32S` images.\n\n@defgroup imgproc_misc Miscellaneous Image Transformations\n@defgroup imgproc_draw Drawing Functions\n\nDrawing functions work with matrices/images of arbitrary depth. The boundaries of the shapes can be\nrendered with antialiasing (implemented only for 8-bit images for now). All the functions include\nthe parameter color that uses an RGB value (that may be constructed with the Scalar constructor )\nfor color images and brightness for grayscale images. For color images, the channel ordering is\nnormally *Blue, Green, Red*. This is what imshow, imread, and imwrite expect. So, if you form a\ncolor using the Scalar constructor, it should look like:\n\n\\f[\\texttt{Scalar} (blue \\_ component, green \\_ component, red \\_ component[, alpha \\_ component])\\f]\n\nIf you are using your own image rendering and I/O functions, you can use any channel ordering. The\ndrawing functions process each channel independently and do not depend on the channel order or even\non the used color space. The whole image can be converted from BGR to RGB or to a different color\nspace using cvtColor .\n\nIf a drawn figure is partially or completely outside the image, the drawing functions clip it. Also,\nmany drawing functions can handle pixel coordinates specified with sub-pixel accuracy. This means\nthat the coordinates can be passed as fixed-point numbers encoded as integers. The number of\nfractional bits is specified by the shift parameter and the real point coordinates are calculated as\n\\f$\\texttt{Point}(x,y)\\rightarrow\\texttt{Point2f}(x*2^{-shift},y*2^{-shift})\\f$ . This feature is\nespecially effective when rendering antialiased shapes.\n\n@note The functions do not support alpha-transparency when the target image is 4-channel. In this\ncase, the color[3] is simply copied to the repainted pixels. Thus, if you want to paint\nsemi-transparent shapes, you can paint them in a separate buffer and then blend it with the main\nimage.\n\n@defgroup imgproc_color_conversions Color Space Conversions\n@defgroup imgproc_colormap ColorMaps in OpenCV\n\nThe human perception isn\'t built for observing fine changes in grayscale images. Human eyes are more\nsensitive to observing changes between colors, so you often need to recolor your grayscale images to\nget a clue about them. OpenCV now comes with various colormaps to enhance the visualization in your\ncomputer vision application.\n\nIn OpenCV you only need applyColorMap to apply a colormap on a given image. The following sample\ncode reads the path to an image from command line, applies a Jet colormap on it and shows the\nresult:\n\n@include snippets/imgproc_applyColorMap.cpp\n\n@see #ColormapTypes\n\n@defgroup imgproc_subdiv2d Planar Subdivision\n\nThe Subdiv2D class described in this section is used to perform various planar subdivision on\na set of 2D points (represented as vector of Point2f). OpenCV subdivides a plane into triangles\nusing the Delaunay\'s algorithm, which corresponds to the dual graph of the Voronoi diagram.\nIn the figure below, the Delaunay\'s triangulation is marked with black lines and the Voronoi\ndiagram with red lines.\n\n![Delaunay triangulation (black) and Voronoi (red)](pics/delaunay_voronoi.png)\n\nThe subdivisions can be used for the 3D piece-wise transformation of a plane, morphing, fast\nlocation of points on the plane, building special graphs (such as NNG,RNG), and so forth.\n\n@defgroup imgproc_hist Histograms\n@defgroup imgproc_shape Structural Analysis and Shape Descriptors\n@defgroup imgproc_motion Motion Analysis and Object Tracking\n@defgroup imgproc_feature Feature Detection\n@defgroup imgproc_object Object Detection\n@defgroup imgproc_c C API\n@defgroup imgproc_hal Hardware Acceleration Layer\n@{\n@defgroup imgproc_hal_functions Functions\n@defgroup imgproc_hal_interface Interface\n@}\n@}\n\n'}

--- Incoming ---
[   'enum cv.SpecialFilter',
    '',
    [],
    [['const cv.FILTER_SCHARR', '-1', [], [], None, '']],
    None,
    '@addtogroup imgproc\n@{\n\n@addtogroup imgproc_filter\n@{']
parse_name: const cv.FILTER_SCHARR with ['cv'] -> fullname:cv::FILTER_SCHARR namespace:cv classpath: classname: name:FILTER_SCHARR
parse_name: enum cv.SpecialFilter with ['cv'] -> fullname:cv::SpecialFilter namespace:cv classpath: classname: name:SpecialFilter
parse_name: const cv.FILTER_SCHARR with ['cv'] -> fullname:cv::FILTER_SCHARR namespace:cv classpath: classname: name:FILTER_SCHARR

--- Incoming ---
[   'enum cv.MorphTypes',
    '',
    [],
    [   ['const cv.MORPH_ERODE', '0', [], [], None, 'see #erode\n'],
        ['const cv.MORPH_DILATE', '1', [], [], None, 'see #dilate\n'],
        ['const cv.MORPH_OPEN', '2', [], [], None, 'an opening operation\n'],
        ['const cv.MORPH_CLOSE', '3', [], [], None, 'a closing operation\n'],
        [   'const cv.MORPH_GRADIENT',
            '4',
            [],
            [],
            None,
            'a morphological gradient\n'],
        ['const cv.MORPH_TOPHAT', '5', [], [], None, '"top hat"\n'],
        ['const cv.MORPH_BLACKHAT', '6', [], [], None, '"black hat"\n'],
        ['const cv.MORPH_HITMISS', '7', [], [], None, '"hit or miss"\n']],
    None,
    'type of morphological operation']
parse_name: const cv.MORPH_ERODE with ['cv'] -> fullname:cv::MORPH_ERODE namespace:cv classpath: classname: name:MORPH_ERODE
parse_name: const cv.MORPH_DILATE with ['cv'] -> fullname:cv::MORPH_DILATE namespace:cv classpath: classname: name:MORPH_DILATE
parse_name: const cv.MORPH_OPEN with ['cv'] -> fullname:cv::MORPH_OPEN namespace:cv classpath: classname: name:MORPH_OPEN
parse_name: const cv.MORPH_CLOSE with ['cv'] -> fullname:cv::MORPH_CLOSE namespace:cv classpath: classname: name:MORPH_CLOSE
parse_name: const cv.MORPH_GRADIENT with ['cv'] -> fullname:cv::MORPH_GRADIENT namespace:cv classpath: classname: name:MORPH_GRADIENT
parse_name: const cv.MORPH_TOPHAT with ['cv'] -> fullname:cv::MORPH_TOPHAT namespace:cv classpath: classname: name:MORPH_TOPHAT
parse_name: const cv.MORPH_BLACKHAT with ['cv'] -> fullname:cv::MORPH_BLACKHAT namespace:cv classpath: classname: name:MORPH_BLACKHAT
parse_name: const cv.MORPH_HITMISS with ['cv'] -> fullname:cv::MORPH_HITMISS namespace:cv classpath: classname: name:MORPH_HITMISS
parse_name: enum cv.MorphTypes with ['cv'] -> fullname:cv::MorphTypes namespace:cv classpath: classname: name:MorphTypes
parse_name: const cv.MORPH_ERODE with ['cv'] -> fullname:cv::MORPH_ERODE namespace:cv classpath: classname: name:MORPH_ERODE
parse_name: const cv.MORPH_DILATE with ['cv'] -> fullname:cv::MORPH_DILATE namespace:cv classpath: classname: name:MORPH_DILATE
parse_name: const cv.MORPH_OPEN with ['cv'] -> fullname:cv::MORPH_OPEN namespace:cv classpath: classname: name:MORPH_OPEN
parse_name: const cv.MORPH_CLOSE with ['cv'] -> fullname:cv::MORPH_CLOSE namespace:cv classpath: classname: name:MORPH_CLOSE
parse_name: const cv.MORPH_GRADIENT with ['cv'] -> fullname:cv::MORPH_GRADIENT namespace:cv classpath: classname: name:MORPH_GRADIENT
parse_name: const cv.MORPH_TOPHAT with ['cv'] -> fullname:cv::MORPH_TOPHAT namespace:cv classpath: classname: name:MORPH_TOPHAT
parse_name: const cv.MORPH_BLACKHAT with ['cv'] -> fullname:cv::MORPH_BLACKHAT namespace:cv classpath: classname: name:MORPH_BLACKHAT
parse_name: const cv.MORPH_HITMISS with ['cv'] -> fullname:cv::MORPH_HITMISS namespace:cv classpath: classname: name:MORPH_HITMISS

--- Incoming ---
[   'enum cv.MorphShapes',
    '',
    [],
    [   [   'const cv.MORPH_RECT',
            '0',
            [],
            [],
            None,
            'a rectangular structuring element:  \\f[E_{ij}=1\\f]\n'],
        [   'const cv.MORPH_CROSS',
            '1',
            [],
            [],
            None,
            'a cross-shaped structuring element:\n'],
        [   'const cv.MORPH_ELLIPSE',
            '2',
            [],
            [],
            None,
            'an elliptic structuring element, that is, a filled ellipse '
            'inscribed\n']],
    None,
    'shape of the structuring element']
parse_name: const cv.MORPH_RECT with ['cv'] -> fullname:cv::MORPH_RECT namespace:cv classpath: classname: name:MORPH_RECT
parse_name: const cv.MORPH_CROSS with ['cv'] -> fullname:cv::MORPH_CROSS namespace:cv classpath: classname: name:MORPH_CROSS
parse_name: const cv.MORPH_ELLIPSE with ['cv'] -> fullname:cv::MORPH_ELLIPSE namespace:cv classpath: classname: name:MORPH_ELLIPSE
parse_name: enum cv.MorphShapes with ['cv'] -> fullname:cv::MorphShapes namespace:cv classpath: classname: name:MorphShapes
parse_name: const cv.MORPH_RECT with ['cv'] -> fullname:cv::MORPH_RECT namespace:cv classpath: classname: name:MORPH_RECT
parse_name: const cv.MORPH_CROSS with ['cv'] -> fullname:cv::MORPH_CROSS namespace:cv classpath: classname: name:MORPH_CROSS
parse_name: const cv.MORPH_ELLIPSE with ['cv'] -> fullname:cv::MORPH_ELLIPSE namespace:cv classpath: classname: name:MORPH_ELLIPSE

--- Incoming ---
[   'enum cv.InterpolationFlags',
    '',
    [],
    [   ['const cv.INTER_NEAREST', '0', [], [], None, ''],
        ['const cv.INTER_LINEAR', '1', [], [], None, ''],
        ['const cv.INTER_CUBIC', '2', [], [], None, ''],
        ['const cv.INTER_AREA', '3', [], [], None, ''],
        ['const cv.INTER_LANCZOS4', '4', [], [], None, ''],
        ['const cv.INTER_LINEAR_EXACT', '5', [], [], None, ''],
        ['const cv.INTER_MAX', '7', [], [], None, ''],
        ['const cv.WARP_FILL_OUTLIERS', '8', [], [], None, ''],
        ['const cv.WARP_INVERSE_MAP', '16', [], [], None, '']],
    None,
    '@} imgproc_filter\n'
    '@addtogroup imgproc_transform\n'
    '@{\n'
    'interpolation algorithm']
parse_name: const cv.INTER_NEAREST with ['cv'] -> fullname:cv::INTER_NEAREST namespace:cv classpath: classname: name:INTER_NEAREST
parse_name: const cv.INTER_LINEAR with ['cv'] -> fullname:cv::INTER_LINEAR namespace:cv classpath: classname: name:INTER_LINEAR
parse_name: const cv.INTER_CUBIC with ['cv'] -> fullname:cv::INTER_CUBIC namespace:cv classpath: classname: name:INTER_CUBIC
parse_name: const cv.INTER_AREA with ['cv'] -> fullname:cv::INTER_AREA namespace:cv classpath: classname: name:INTER_AREA
parse_name: const cv.INTER_LANCZOS4 with ['cv'] -> fullname:cv::INTER_LANCZOS4 namespace:cv classpath: classname: name:INTER_LANCZOS4
parse_name: const cv.INTER_LINEAR_EXACT with ['cv'] -> fullname:cv::INTER_LINEAR_EXACT namespace:cv classpath: classname: name:INTER_LINEAR_EXACT
parse_name: const cv.INTER_MAX with ['cv'] -> fullname:cv::INTER_MAX namespace:cv classpath: classname: name:INTER_MAX
parse_name: const cv.WARP_FILL_OUTLIERS with ['cv'] -> fullname:cv::WARP_FILL_OUTLIERS namespace:cv classpath: classname: name:WARP_FILL_OUTLIERS
parse_name: const cv.WARP_INVERSE_MAP with ['cv'] -> fullname:cv::WARP_INVERSE_MAP namespace:cv classpath: classname: name:WARP_INVERSE_MAP
parse_name: enum cv.InterpolationFlags with ['cv'] -> fullname:cv::InterpolationFlags namespace:cv classpath: classname: name:InterpolationFlags
parse_name: const cv.INTER_NEAREST with ['cv'] -> fullname:cv::INTER_NEAREST namespace:cv classpath: classname: name:INTER_NEAREST
parse_name: const cv.INTER_LINEAR with ['cv'] -> fullname:cv::INTER_LINEAR namespace:cv classpath: classname: name:INTER_LINEAR
parse_name: const cv.INTER_CUBIC with ['cv'] -> fullname:cv::INTER_CUBIC namespace:cv classpath: classname: name:INTER_CUBIC
parse_name: const cv.INTER_AREA with ['cv'] -> fullname:cv::INTER_AREA namespace:cv classpath: classname: name:INTER_AREA
parse_name: const cv.INTER_LANCZOS4 with ['cv'] -> fullname:cv::INTER_LANCZOS4 namespace:cv classpath: classname: name:INTER_LANCZOS4
parse_name: const cv.INTER_LINEAR_EXACT with ['cv'] -> fullname:cv::INTER_LINEAR_EXACT namespace:cv classpath: classname: name:INTER_LINEAR_EXACT
parse_name: const cv.INTER_MAX with ['cv'] -> fullname:cv::INTER_MAX namespace:cv classpath: classname: name:INTER_MAX
parse_name: const cv.WARP_FILL_OUTLIERS with ['cv'] -> fullname:cv::WARP_FILL_OUTLIERS namespace:cv classpath: classname: name:WARP_FILL_OUTLIERS
parse_name: const cv.WARP_INVERSE_MAP with ['cv'] -> fullname:cv::WARP_INVERSE_MAP namespace:cv classpath: classname: name:WARP_INVERSE_MAP

--- Incoming ---
[   'enum cv.WarpPolarMode',
    '',
    [],
    [   ['const cv.WARP_POLAR_LINEAR', '0', [], [], None, ''],
        ['const cv.WARP_POLAR_LOG', '256', [], [], None, '']],
    None,
    '\\brief Specify the polar mapping mode\n@sa warpPolar']
parse_name: const cv.WARP_POLAR_LINEAR with ['cv'] -> fullname:cv::WARP_POLAR_LINEAR namespace:cv classpath: classname: name:WARP_POLAR_LINEAR
parse_name: const cv.WARP_POLAR_LOG with ['cv'] -> fullname:cv::WARP_POLAR_LOG namespace:cv classpath: classname: name:WARP_POLAR_LOG
parse_name: enum cv.WarpPolarMode with ['cv'] -> fullname:cv::WarpPolarMode namespace:cv classpath: classname: name:WarpPolarMode
parse_name: const cv.WARP_POLAR_LINEAR with ['cv'] -> fullname:cv::WARP_POLAR_LINEAR namespace:cv classpath: classname: name:WARP_POLAR_LINEAR
parse_name: const cv.WARP_POLAR_LOG with ['cv'] -> fullname:cv::WARP_POLAR_LOG namespace:cv classpath: classname: name:WARP_POLAR_LOG

--- Incoming ---
[   'enum cv.InterpolationMasks',
    '',
    [],
    [   ['const cv.INTER_BITS', '5', [], [], None, ''],
        ['const cv.INTER_BITS2', 'INTER_BITS * 2', [], [], None, ''],
        ['const cv.INTER_TAB_SIZE', '1 << INTER_BITS', [], [], None, ''],
        [   'const cv.INTER_TAB_SIZE2',
            'INTER_TAB_SIZE * INTER_TAB_SIZE',
            [],
            [],
            None,
            '']],
    None,
    '']
parse_name: const cv.INTER_BITS with ['cv'] -> fullname:cv::INTER_BITS namespace:cv classpath: classname: name:INTER_BITS
parse_name: const cv.INTER_BITS2 with ['cv'] -> fullname:cv::INTER_BITS2 namespace:cv classpath: classname: name:INTER_BITS2
parse_name: const cv.INTER_TAB_SIZE with ['cv'] -> fullname:cv::INTER_TAB_SIZE namespace:cv classpath: classname: name:INTER_TAB_SIZE
parse_name: const cv.INTER_TAB_SIZE2 with ['cv'] -> fullname:cv::INTER_TAB_SIZE2 namespace:cv classpath: classname: name:INTER_TAB_SIZE2
parse_name: enum cv.InterpolationMasks with ['cv'] -> fullname:cv::InterpolationMasks namespace:cv classpath: classname: name:InterpolationMasks
parse_name: const cv.INTER_BITS with ['cv'] -> fullname:cv::INTER_BITS namespace:cv classpath: classname: name:INTER_BITS
parse_name: const cv.INTER_BITS2 with ['cv'] -> fullname:cv::INTER_BITS2 namespace:cv classpath: classname: name:INTER_BITS2
parse_name: const cv.INTER_TAB_SIZE with ['cv'] -> fullname:cv::INTER_TAB_SIZE namespace:cv classpath: classname: name:INTER_TAB_SIZE
parse_name: const cv.INTER_TAB_SIZE2 with ['cv'] -> fullname:cv::INTER_TAB_SIZE2 namespace:cv classpath: classname: name:INTER_TAB_SIZE2

--- Incoming ---
[   'enum cv.DistanceTypes',
    '',
    [],
    [   ['const cv.DIST_USER', '-1', [], [], None, 'User defined distance\n'],
        [   'const cv.DIST_L1',
            '1',
            [],
            [],
            None,
            'distance = |x1-x2| + |y1-y2|\n'],
        [   'const cv.DIST_L2',
            '2',
            [],
            [],
            None,
            'the simple euclidean distance\n'],
        [   'const cv.DIST_C',
            '3',
            [],
            [],
            None,
            'distance = max(|x1-x2|,|y1-y2|)\n'],
        [   'const cv.DIST_L12',
            '4',
            [],
            [],
            None,
            'L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1))\n'],
        [   'const cv.DIST_FAIR',
            '5',
            [],
            [],
            None,
            'distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998\n'],
        [   'const cv.DIST_WELSCH',
            '6',
            [],
            [],
            None,
            'distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846\n'],
        [   'const cv.DIST_HUBER',
            '7',
            [],
            [],
            None,
            'distance = |x|<c ? x^2/2 : c(|x|-c/2), c=1.345\n']],
    None,
    '@} imgproc_transform\n'
    '@addtogroup imgproc_misc\n'
    '@{\n'
    'Distance types for Distance Transform and M-estimators\n'
    '@see distanceTransform, fitLine']
parse_name: const cv.DIST_USER with ['cv'] -> fullname:cv::DIST_USER namespace:cv classpath: classname: name:DIST_USER
parse_name: const cv.DIST_L1 with ['cv'] -> fullname:cv::DIST_L1 namespace:cv classpath: classname: name:DIST_L1
parse_name: const cv.DIST_L2 with ['cv'] -> fullname:cv::DIST_L2 namespace:cv classpath: classname: name:DIST_L2
parse_name: const cv.DIST_C with ['cv'] -> fullname:cv::DIST_C namespace:cv classpath: classname: name:DIST_C
parse_name: const cv.DIST_L12 with ['cv'] -> fullname:cv::DIST_L12 namespace:cv classpath: classname: name:DIST_L12
parse_name: const cv.DIST_FAIR with ['cv'] -> fullname:cv::DIST_FAIR namespace:cv classpath: classname: name:DIST_FAIR
parse_name: const cv.DIST_WELSCH with ['cv'] -> fullname:cv::DIST_WELSCH namespace:cv classpath: classname: name:DIST_WELSCH
parse_name: const cv.DIST_HUBER with ['cv'] -> fullname:cv::DIST_HUBER namespace:cv classpath: classname: name:DIST_HUBER
parse_name: enum cv.DistanceTypes with ['cv'] -> fullname:cv::DistanceTypes namespace:cv classpath: classname: name:DistanceTypes
parse_name: const cv.DIST_USER with ['cv'] -> fullname:cv::DIST_USER namespace:cv classpath: classname: name:DIST_USER
parse_name: const cv.DIST_L1 with ['cv'] -> fullname:cv::DIST_L1 namespace:cv classpath: classname: name:DIST_L1
parse_name: const cv.DIST_L2 with ['cv'] -> fullname:cv::DIST_L2 namespace:cv classpath: classname: name:DIST_L2
parse_name: const cv.DIST_C with ['cv'] -> fullname:cv::DIST_C namespace:cv classpath: classname: name:DIST_C
parse_name: const cv.DIST_L12 with ['cv'] -> fullname:cv::DIST_L12 namespace:cv classpath: classname: name:DIST_L12
parse_name: const cv.DIST_FAIR with ['cv'] -> fullname:cv::DIST_FAIR namespace:cv classpath: classname: name:DIST_FAIR
parse_name: const cv.DIST_WELSCH with ['cv'] -> fullname:cv::DIST_WELSCH namespace:cv classpath: classname: name:DIST_WELSCH
parse_name: const cv.DIST_HUBER with ['cv'] -> fullname:cv::DIST_HUBER namespace:cv classpath: classname: name:DIST_HUBER

--- Incoming ---
[   'enum cv.DistanceTransformMasks',
    '',
    [],
    [   ['const cv.DIST_MASK_3', '3', [], [], None, 'mask=3\n'],
        ['const cv.DIST_MASK_5', '5', [], [], None, 'mask=5\n'],
        ['const cv.DIST_MASK_PRECISE', '0', [], [], None, '']],
    None,
    'Mask size for distance transform']
parse_name: const cv.DIST_MASK_3 with ['cv'] -> fullname:cv::DIST_MASK_3 namespace:cv classpath: classname: name:DIST_MASK_3
parse_name: const cv.DIST_MASK_5 with ['cv'] -> fullname:cv::DIST_MASK_5 namespace:cv classpath: classname: name:DIST_MASK_5
parse_name: const cv.DIST_MASK_PRECISE with ['cv'] -> fullname:cv::DIST_MASK_PRECISE namespace:cv classpath: classname: name:DIST_MASK_PRECISE
parse_name: enum cv.DistanceTransformMasks with ['cv'] -> fullname:cv::DistanceTransformMasks namespace:cv classpath: classname: name:DistanceTransformMasks
parse_name: const cv.DIST_MASK_3 with ['cv'] -> fullname:cv::DIST_MASK_3 namespace:cv classpath: classname: name:DIST_MASK_3
parse_name: const cv.DIST_MASK_5 with ['cv'] -> fullname:cv::DIST_MASK_5 namespace:cv classpath: classname: name:DIST_MASK_5
parse_name: const cv.DIST_MASK_PRECISE with ['cv'] -> fullname:cv::DIST_MASK_PRECISE namespace:cv classpath: classname: name:DIST_MASK_PRECISE

--- Incoming ---
[   'enum cv.ThresholdTypes',
    '',
    [],
    [   [   'const cv.THRESH_BINARY',
            '0',
            [],
            [],
            None,
            '\\f[\\texttt{dst} (x,y) =  \\fork{\\texttt{maxval}}{if '
            '\\(\\texttt{src}(x,y) > \\texttt{thresh}\\)}{0}{otherwise}\\f]\n'],
        [   'const cv.THRESH_BINARY_INV',
            '1',
            [],
            [],
            None,
            '\\f[\\texttt{dst} (x,y) =  \\fork{0}{if \\(\\texttt{src}(x,y) > '
            '\\texttt{thresh}\\)}{\\texttt{maxval}}{otherwise}\\f]\n'],
        [   'const cv.THRESH_TRUNC',
            '2',
            [],
            [],
            None,
            '\\f[\\texttt{dst} (x,y) =  \\fork{\\texttt{threshold}}{if '
            '\\(\\texttt{src}(x,y) > '
            '\\texttt{thresh}\\)}{\\texttt{src}(x,y)}{otherwise}\\f]\n'],
        [   'const cv.THRESH_TOZERO',
            '3',
            [],
            [],
            None,
            '\\f[\\texttt{dst} (x,y) =  \\fork{\\texttt{src}(x,y)}{if '
            '\\(\\texttt{src}(x,y) > \\texttt{thresh}\\)}{0}{otherwise}\\f]\n'],
        [   'const cv.THRESH_TOZERO_INV',
            '4',
            [],
            [],
            None,
            '\\f[\\texttt{dst} (x,y) =  \\fork{0}{if \\(\\texttt{src}(x,y) > '
            '\\texttt{thresh}\\)}{\\texttt{src}(x,y)}{otherwise}\\f]\n'],
        ['const cv.THRESH_MASK', '7', [], [], None, ''],
        [   'const cv.THRESH_OTSU',
            '8',
            [],
            [],
            None,
            'flag, use Otsu algorithm to choose the optimal threshold value\n'],
        [   'const cv.THRESH_TRIANGLE',
            '16',
            [],
            [],
            None,
            'flag, use Triangle algorithm to choose the optimal threshold '
            'value\n']],
    None,
    'type of the threshold operation\n![threshold types](pics/threshold.png)']
parse_name: const cv.THRESH_BINARY with ['cv'] -> fullname:cv::THRESH_BINARY namespace:cv classpath: classname: name:THRESH_BINARY
parse_name: const cv.THRESH_BINARY_INV with ['cv'] -> fullname:cv::THRESH_BINARY_INV namespace:cv classpath: classname: name:THRESH_BINARY_INV
parse_name: const cv.THRESH_TRUNC with ['cv'] -> fullname:cv::THRESH_TRUNC namespace:cv classpath: classname: name:THRESH_TRUNC
parse_name: const cv.THRESH_TOZERO with ['cv'] -> fullname:cv::THRESH_TOZERO namespace:cv classpath: classname: name:THRESH_TOZERO
parse_name: const cv.THRESH_TOZERO_INV with ['cv'] -> fullname:cv::THRESH_TOZERO_INV namespace:cv classpath: classname: name:THRESH_TOZERO_INV
parse_name: const cv.THRESH_MASK with ['cv'] -> fullname:cv::THRESH_MASK namespace:cv classpath: classname: name:THRESH_MASK
parse_name: const cv.THRESH_OTSU with ['cv'] -> fullname:cv::THRESH_OTSU namespace:cv classpath: classname: name:THRESH_OTSU
parse_name: const cv.THRESH_TRIANGLE with ['cv'] -> fullname:cv::THRESH_TRIANGLE namespace:cv classpath: classname: name:THRESH_TRIANGLE
parse_name: enum cv.ThresholdTypes with ['cv'] -> fullname:cv::ThresholdTypes namespace:cv classpath: classname: name:ThresholdTypes
parse_name: const cv.THRESH_BINARY with ['cv'] -> fullname:cv::THRESH_BINARY namespace:cv classpath: classname: name:THRESH_BINARY
parse_name: const cv.THRESH_BINARY_INV with ['cv'] -> fullname:cv::THRESH_BINARY_INV namespace:cv classpath: classname: name:THRESH_BINARY_INV
parse_name: const cv.THRESH_TRUNC with ['cv'] -> fullname:cv::THRESH_TRUNC namespace:cv classpath: classname: name:THRESH_TRUNC
parse_name: const cv.THRESH_TOZERO with ['cv'] -> fullname:cv::THRESH_TOZERO namespace:cv classpath: classname: name:THRESH_TOZERO
parse_name: const cv.THRESH_TOZERO_INV with ['cv'] -> fullname:cv::THRESH_TOZERO_INV namespace:cv classpath: classname: name:THRESH_TOZERO_INV
parse_name: const cv.THRESH_MASK with ['cv'] -> fullname:cv::THRESH_MASK namespace:cv classpath: classname: name:THRESH_MASK
parse_name: const cv.THRESH_OTSU with ['cv'] -> fullname:cv::THRESH_OTSU namespace:cv classpath: classname: name:THRESH_OTSU
parse_name: const cv.THRESH_TRIANGLE with ['cv'] -> fullname:cv::THRESH_TRIANGLE namespace:cv classpath: classname: name:THRESH_TRIANGLE

--- Incoming ---
[   'enum cv.AdaptiveThresholdTypes',
    '',
    [],
    [   ['const cv.ADAPTIVE_THRESH_MEAN_C', '0', [], [], None, ''],
        ['const cv.ADAPTIVE_THRESH_GAUSSIAN_C', '1', [], [], None, '']],
    None,
    'adaptive threshold algorithm\n@see adaptiveThreshold']
parse_name: const cv.ADAPTIVE_THRESH_MEAN_C with ['cv'] -> fullname:cv::ADAPTIVE_THRESH_MEAN_C namespace:cv classpath: classname: name:ADAPTIVE_THRESH_MEAN_C
parse_name: const cv.ADAPTIVE_THRESH_GAUSSIAN_C with ['cv'] -> fullname:cv::ADAPTIVE_THRESH_GAUSSIAN_C namespace:cv classpath: classname: name:ADAPTIVE_THRESH_GAUSSIAN_C
parse_name: enum cv.AdaptiveThresholdTypes with ['cv'] -> fullname:cv::AdaptiveThresholdTypes namespace:cv classpath: classname: name:AdaptiveThresholdTypes
parse_name: const cv.ADAPTIVE_THRESH_MEAN_C with ['cv'] -> fullname:cv::ADAPTIVE_THRESH_MEAN_C namespace:cv classpath: classname: name:ADAPTIVE_THRESH_MEAN_C
parse_name: const cv.ADAPTIVE_THRESH_GAUSSIAN_C with ['cv'] -> fullname:cv::ADAPTIVE_THRESH_GAUSSIAN_C namespace:cv classpath: classname: name:ADAPTIVE_THRESH_GAUSSIAN_C

--- Incoming ---
[   'enum cv.GrabCutClasses',
    '',
    [],
    [   [   'const cv.GC_BGD',
            '0',
            [],
            [],
            None,
            'an obvious background pixels\n'],
        [   'const cv.GC_FGD',
            '1',
            [],
            [],
            None,
            'an obvious foreground (object) pixel\n'],
        [   'const cv.GC_PR_BGD',
            '2',
            [],
            [],
            None,
            'a possible background pixel\n'],
        [   'const cv.GC_PR_FGD',
            '3',
            [],
            [],
            None,
            'a possible foreground pixel\n']],
    None,
    'class of the pixel in GrabCut algorithm']
parse_name: const cv.GC_BGD with ['cv'] -> fullname:cv::GC_BGD namespace:cv classpath: classname: name:GC_BGD
parse_name: const cv.GC_FGD with ['cv'] -> fullname:cv::GC_FGD namespace:cv classpath: classname: name:GC_FGD
parse_name: const cv.GC_PR_BGD with ['cv'] -> fullname:cv::GC_PR_BGD namespace:cv classpath: classname: name:GC_PR_BGD
parse_name: const cv.GC_PR_FGD with ['cv'] -> fullname:cv::GC_PR_FGD namespace:cv classpath: classname: name:GC_PR_FGD
parse_name: enum cv.GrabCutClasses with ['cv'] -> fullname:cv::GrabCutClasses namespace:cv classpath: classname: name:GrabCutClasses
parse_name: const cv.GC_BGD with ['cv'] -> fullname:cv::GC_BGD namespace:cv classpath: classname: name:GC_BGD
parse_name: const cv.GC_FGD with ['cv'] -> fullname:cv::GC_FGD namespace:cv classpath: classname: name:GC_FGD
parse_name: const cv.GC_PR_BGD with ['cv'] -> fullname:cv::GC_PR_BGD namespace:cv classpath: classname: name:GC_PR_BGD
parse_name: const cv.GC_PR_FGD with ['cv'] -> fullname:cv::GC_PR_FGD namespace:cv classpath: classname: name:GC_PR_FGD

--- Incoming ---
[   'enum cv.GrabCutModes',
    '',
    [],
    [   ['const cv.GC_INIT_WITH_RECT', '0', [], [], None, ''],
        ['const cv.GC_INIT_WITH_MASK', '1', [], [], None, ''],
        ['const cv.GC_EVAL', '2', [], [], None, ''],
        ['const cv.GC_EVAL_FREEZE_MODEL', '3', [], [], None, '']],
    None,
    'GrabCut algorithm flags']
parse_name: const cv.GC_INIT_WITH_RECT with ['cv'] -> fullname:cv::GC_INIT_WITH_RECT namespace:cv classpath: classname: name:GC_INIT_WITH_RECT
parse_name: const cv.GC_INIT_WITH_MASK with ['cv'] -> fullname:cv::GC_INIT_WITH_MASK namespace:cv classpath: classname: name:GC_INIT_WITH_MASK
parse_name: const cv.GC_EVAL with ['cv'] -> fullname:cv::GC_EVAL namespace:cv classpath: classname: name:GC_EVAL
parse_name: const cv.GC_EVAL_FREEZE_MODEL with ['cv'] -> fullname:cv::GC_EVAL_FREEZE_MODEL namespace:cv classpath: classname: name:GC_EVAL_FREEZE_MODEL
parse_name: enum cv.GrabCutModes with ['cv'] -> fullname:cv::GrabCutModes namespace:cv classpath: classname: name:GrabCutModes
parse_name: const cv.GC_INIT_WITH_RECT with ['cv'] -> fullname:cv::GC_INIT_WITH_RECT namespace:cv classpath: classname: name:GC_INIT_WITH_RECT
parse_name: const cv.GC_INIT_WITH_MASK with ['cv'] -> fullname:cv::GC_INIT_WITH_MASK namespace:cv classpath: classname: name:GC_INIT_WITH_MASK
parse_name: const cv.GC_EVAL with ['cv'] -> fullname:cv::GC_EVAL namespace:cv classpath: classname: name:GC_EVAL
parse_name: const cv.GC_EVAL_FREEZE_MODEL with ['cv'] -> fullname:cv::GC_EVAL_FREEZE_MODEL namespace:cv classpath: classname: name:GC_EVAL_FREEZE_MODEL

--- Incoming ---
[   'enum cv.DistanceTransformLabelTypes',
    '',
    [],
    [   ['const cv.DIST_LABEL_CCOMP', '0', [], [], None, ''],
        ['const cv.DIST_LABEL_PIXEL', '1', [], [], None, '']],
    None,
    'distanceTransform algorithm flags']
parse_name: const cv.DIST_LABEL_CCOMP with ['cv'] -> fullname:cv::DIST_LABEL_CCOMP namespace:cv classpath: classname: name:DIST_LABEL_CCOMP
parse_name: const cv.DIST_LABEL_PIXEL with ['cv'] -> fullname:cv::DIST_LABEL_PIXEL namespace:cv classpath: classname: name:DIST_LABEL_PIXEL
parse_name: enum cv.DistanceTransformLabelTypes with ['cv'] -> fullname:cv::DistanceTransformLabelTypes namespace:cv classpath: classname: name:DistanceTransformLabelTypes
parse_name: const cv.DIST_LABEL_CCOMP with ['cv'] -> fullname:cv::DIST_LABEL_CCOMP namespace:cv classpath: classname: name:DIST_LABEL_CCOMP
parse_name: const cv.DIST_LABEL_PIXEL with ['cv'] -> fullname:cv::DIST_LABEL_PIXEL namespace:cv classpath: classname: name:DIST_LABEL_PIXEL

--- Incoming ---
[   'enum cv.FloodFillFlags',
    '',
    [],
    [   ['const cv.FLOODFILL_FIXED_RANGE', '1 << 16', [], [], None, ''],
        ['const cv.FLOODFILL_MASK_ONLY', '1 << 17', [], [], None, '']],
    None,
    'floodfill algorithm flags']
parse_name: const cv.FLOODFILL_FIXED_RANGE with ['cv'] -> fullname:cv::FLOODFILL_FIXED_RANGE namespace:cv classpath: classname: name:FLOODFILL_FIXED_RANGE
parse_name: const cv.FLOODFILL_MASK_ONLY with ['cv'] -> fullname:cv::FLOODFILL_MASK_ONLY namespace:cv classpath: classname: name:FLOODFILL_MASK_ONLY
parse_name: enum cv.FloodFillFlags with ['cv'] -> fullname:cv::FloodFillFlags namespace:cv classpath: classname: name:FloodFillFlags
parse_name: const cv.FLOODFILL_FIXED_RANGE with ['cv'] -> fullname:cv::FLOODFILL_FIXED_RANGE namespace:cv classpath: classname: name:FLOODFILL_FIXED_RANGE
parse_name: const cv.FLOODFILL_MASK_ONLY with ['cv'] -> fullname:cv::FLOODFILL_MASK_ONLY namespace:cv classpath: classname: name:FLOODFILL_MASK_ONLY

--- Incoming ---
[   'enum cv.ConnectedComponentsTypes',
    '',
    [],
    [   [   'const cv.CC_STAT_LEFT',
            '0',
            [],
            [],
            None,
            'The leftmost (x) coordinate which is the inclusive start of the '
            'bounding\n'],
        [   'const cv.CC_STAT_TOP',
            '1',
            [],
            [],
            None,
            'The topmost (y) coordinate which is the inclusive start of the '
            'bounding\n'],
        [   'const cv.CC_STAT_WIDTH',
            '2',
            [],
            [],
            None,
            'The horizontal size of the bounding box\n'],
        [   'const cv.CC_STAT_HEIGHT',
            '3',
            [],
            [],
            None,
            'The vertical size of the bounding box\n'],
        [   'const cv.CC_STAT_AREA',
            '4',
            [],
            [],
            None,
            'The total area (in pixels) of the connected component\n'],
        ['const cv.CC_STAT_MAX', '5', [], [], None, '']],
    None,
    '@} imgproc_misc\n'
    '@addtogroup imgproc_shape\n'
    '@{\n'
    'connected components algorithm output formats']
parse_name: const cv.CC_STAT_LEFT with ['cv'] -> fullname:cv::CC_STAT_LEFT namespace:cv classpath: classname: name:CC_STAT_LEFT
parse_name: const cv.CC_STAT_TOP with ['cv'] -> fullname:cv::CC_STAT_TOP namespace:cv classpath: classname: name:CC_STAT_TOP
parse_name: const cv.CC_STAT_WIDTH with ['cv'] -> fullname:cv::CC_STAT_WIDTH namespace:cv classpath: classname: name:CC_STAT_WIDTH
parse_name: const cv.CC_STAT_HEIGHT with ['cv'] -> fullname:cv::CC_STAT_HEIGHT namespace:cv classpath: classname: name:CC_STAT_HEIGHT
parse_name: const cv.CC_STAT_AREA with ['cv'] -> fullname:cv::CC_STAT_AREA namespace:cv classpath: classname: name:CC_STAT_AREA
parse_name: const cv.CC_STAT_MAX with ['cv'] -> fullname:cv::CC_STAT_MAX namespace:cv classpath: classname: name:CC_STAT_MAX
parse_name: enum cv.ConnectedComponentsTypes with ['cv'] -> fullname:cv::ConnectedComponentsTypes namespace:cv classpath: classname: name:ConnectedComponentsTypes
parse_name: const cv.CC_STAT_LEFT with ['cv'] -> fullname:cv::CC_STAT_LEFT namespace:cv classpath: classname: name:CC_STAT_LEFT
parse_name: const cv.CC_STAT_TOP with ['cv'] -> fullname:cv::CC_STAT_TOP namespace:cv classpath: classname: name:CC_STAT_TOP
parse_name: const cv.CC_STAT_WIDTH with ['cv'] -> fullname:cv::CC_STAT_WIDTH namespace:cv classpath: classname: name:CC_STAT_WIDTH
parse_name: const cv.CC_STAT_HEIGHT with ['cv'] -> fullname:cv::CC_STAT_HEIGHT namespace:cv classpath: classname: name:CC_STAT_HEIGHT
parse_name: const cv.CC_STAT_AREA with ['cv'] -> fullname:cv::CC_STAT_AREA namespace:cv classpath: classname: name:CC_STAT_AREA
parse_name: const cv.CC_STAT_MAX with ['cv'] -> fullname:cv::CC_STAT_MAX namespace:cv classpath: classname: name:CC_STAT_MAX

--- Incoming ---
[   'enum cv.ConnectedComponentsAlgorithmsTypes',
    '',
    [],
    [   [   'const cv.CCL_WU',
            '0',
            [],
            [],
            None,
            'SAUF algorithm for 8-way connectivity, SAUF algorithm for 4-way '
            'connectivity\n'],
        [   'const cv.CCL_DEFAULT',
            '-1',
            [],
            [],
            None,
            'BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way '
            'connectivity\n'],
        [   'const cv.CCL_GRANA',
            '1',
            [],
            [],
            None,
            'BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way '
            'connectivity\n']],
    None,
    'connected components algorithm']
parse_name: const cv.CCL_WU with ['cv'] -> fullname:cv::CCL_WU namespace:cv classpath: classname: name:CCL_WU
parse_name: const cv.CCL_DEFAULT with ['cv'] -> fullname:cv::CCL_DEFAULT namespace:cv classpath: classname: name:CCL_DEFAULT
parse_name: const cv.CCL_GRANA with ['cv'] -> fullname:cv::CCL_GRANA namespace:cv classpath: classname: name:CCL_GRANA
parse_name: enum cv.ConnectedComponentsAlgorithmsTypes with ['cv'] -> fullname:cv::ConnectedComponentsAlgorithmsTypes namespace:cv classpath: classname: name:ConnectedComponentsAlgorithmsTypes
parse_name: const cv.CCL_WU with ['cv'] -> fullname:cv::CCL_WU namespace:cv classpath: classname: name:CCL_WU
parse_name: const cv.CCL_DEFAULT with ['cv'] -> fullname:cv::CCL_DEFAULT namespace:cv classpath: classname: name:CCL_DEFAULT
parse_name: const cv.CCL_GRANA with ['cv'] -> fullname:cv::CCL_GRANA namespace:cv classpath: classname: name:CCL_GRANA

--- Incoming ---
[   'enum cv.RetrievalModes',
    '',
    [],
    [   ['const cv.RETR_EXTERNAL', '0', [], [], None, ''],
        ['const cv.RETR_LIST', '1', [], [], None, ''],
        ['const cv.RETR_CCOMP', '2', [], [], None, ''],
        ['const cv.RETR_TREE', '3', [], [], None, ''],
        ['const cv.RETR_FLOODFILL', '4', [], [], None, '']],
    None,
    'mode of the contour retrieval algorithm']
parse_name: const cv.RETR_EXTERNAL with ['cv'] -> fullname:cv::RETR_EXTERNAL namespace:cv classpath: classname: name:RETR_EXTERNAL
parse_name: const cv.RETR_LIST with ['cv'] -> fullname:cv::RETR_LIST namespace:cv classpath: classname: name:RETR_LIST
parse_name: const cv.RETR_CCOMP with ['cv'] -> fullname:cv::RETR_CCOMP namespace:cv classpath: classname: name:RETR_CCOMP
parse_name: const cv.RETR_TREE with ['cv'] -> fullname:cv::RETR_TREE namespace:cv classpath: classname: name:RETR_TREE
parse_name: const cv.RETR_FLOODFILL with ['cv'] -> fullname:cv::RETR_FLOODFILL namespace:cv classpath: classname: name:RETR_FLOODFILL
parse_name: enum cv.RetrievalModes with ['cv'] -> fullname:cv::RetrievalModes namespace:cv classpath: classname: name:RetrievalModes
parse_name: const cv.RETR_EXTERNAL with ['cv'] -> fullname:cv::RETR_EXTERNAL namespace:cv classpath: classname: name:RETR_EXTERNAL
parse_name: const cv.RETR_LIST with ['cv'] -> fullname:cv::RETR_LIST namespace:cv classpath: classname: name:RETR_LIST
parse_name: const cv.RETR_CCOMP with ['cv'] -> fullname:cv::RETR_CCOMP namespace:cv classpath: classname: name:RETR_CCOMP
parse_name: const cv.RETR_TREE with ['cv'] -> fullname:cv::RETR_TREE namespace:cv classpath: classname: name:RETR_TREE
parse_name: const cv.RETR_FLOODFILL with ['cv'] -> fullname:cv::RETR_FLOODFILL namespace:cv classpath: classname: name:RETR_FLOODFILL

--- Incoming ---
[   'enum cv.ContourApproximationModes',
    '',
    [],
    [   ['const cv.CHAIN_APPROX_NONE', '1', [], [], None, ''],
        ['const cv.CHAIN_APPROX_SIMPLE', '2', [], [], None, ''],
        ['const cv.CHAIN_APPROX_TC89_L1', '3', [], [], None, ''],
        ['const cv.CHAIN_APPROX_TC89_KCOS', '4', [], [], None, '']],
    None,
    'the contour approximation algorithm']
parse_name: const cv.CHAIN_APPROX_NONE with ['cv'] -> fullname:cv::CHAIN_APPROX_NONE namespace:cv classpath: classname: name:CHAIN_APPROX_NONE
parse_name: const cv.CHAIN_APPROX_SIMPLE with ['cv'] -> fullname:cv::CHAIN_APPROX_SIMPLE namespace:cv classpath: classname: name:CHAIN_APPROX_SIMPLE
parse_name: const cv.CHAIN_APPROX_TC89_L1 with ['cv'] -> fullname:cv::CHAIN_APPROX_TC89_L1 namespace:cv classpath: classname: name:CHAIN_APPROX_TC89_L1
parse_name: const cv.CHAIN_APPROX_TC89_KCOS with ['cv'] -> fullname:cv::CHAIN_APPROX_TC89_KCOS namespace:cv classpath: classname: name:CHAIN_APPROX_TC89_KCOS
parse_name: enum cv.ContourApproximationModes with ['cv'] -> fullname:cv::ContourApproximationModes namespace:cv classpath: classname: name:ContourApproximationModes
parse_name: const cv.CHAIN_APPROX_NONE with ['cv'] -> fullname:cv::CHAIN_APPROX_NONE namespace:cv classpath: classname: name:CHAIN_APPROX_NONE
parse_name: const cv.CHAIN_APPROX_SIMPLE with ['cv'] -> fullname:cv::CHAIN_APPROX_SIMPLE namespace:cv classpath: classname: name:CHAIN_APPROX_SIMPLE
parse_name: const cv.CHAIN_APPROX_TC89_L1 with ['cv'] -> fullname:cv::CHAIN_APPROX_TC89_L1 namespace:cv classpath: classname: name:CHAIN_APPROX_TC89_L1
parse_name: const cv.CHAIN_APPROX_TC89_KCOS with ['cv'] -> fullname:cv::CHAIN_APPROX_TC89_KCOS namespace:cv classpath: classname: name:CHAIN_APPROX_TC89_KCOS

--- Incoming ---
[   'enum cv.ShapeMatchModes',
    '',
    [],
    [   [   'const cv.CONTOURS_MATCH_I1',
            '1',
            [],
            [],
            None,
            '\\f[I_1(A,B) =  \\sum _{i=1...7}  \\left |  \\frac{1}{m^A_i} -  '
            '\\frac{1}{m^B_i} \\right |\\f]\n'],
        [   'const cv.CONTOURS_MATCH_I2',
            '2',
            [],
            [],
            None,
            '\\f[I_2(A,B) =  \\sum _{i=1...7}  \\left | m^A_i - m^B_i  \\right '
            '|\\f]\n'],
        [   'const cv.CONTOURS_MATCH_I3',
            '3',
            [],
            [],
            None,
            '\\f[I_3(A,B) =  \\max _{i=1...7}  \\frac{ \\left| m^A_i - m^B_i '
            '\\right| }{ \\left| m^A_i \\right| }\\f]\n']],
    None,
    '@brief Shape matching methods\n'
    '\n'
    '\\f$A\\f$ denotes object1,\\f$B\\f$ denotes object2\n'
    '\n'
    '\\f$\\begin{array}{l} m^A_i =  \\mathrm{sign} (h^A_i)  \\cdot '
    '\\log{h^A_i} \\\\ m^B_i =  \\mathrm{sign} (h^B_i)  \\cdot \\log{h^B_i} '
    '\\end{array}\\f$\n'
    '\n'
    'and \\f$h^A_i, h^B_i\\f$ are the Hu moments of \\f$A\\f$ and \\f$B\\f$ , '
    'respectively.']
parse_name: const cv.CONTOURS_MATCH_I1 with ['cv'] -> fullname:cv::CONTOURS_MATCH_I1 namespace:cv classpath: classname: name:CONTOURS_MATCH_I1
parse_name: const cv.CONTOURS_MATCH_I2 with ['cv'] -> fullname:cv::CONTOURS_MATCH_I2 namespace:cv classpath: classname: name:CONTOURS_MATCH_I2
parse_name: const cv.CONTOURS_MATCH_I3 with ['cv'] -> fullname:cv::CONTOURS_MATCH_I3 namespace:cv classpath: classname: name:CONTOURS_MATCH_I3
parse_name: enum cv.ShapeMatchModes with ['cv'] -> fullname:cv::ShapeMatchModes namespace:cv classpath: classname: name:ShapeMatchModes
parse_name: const cv.CONTOURS_MATCH_I1 with ['cv'] -> fullname:cv::CONTOURS_MATCH_I1 namespace:cv classpath: classname: name:CONTOURS_MATCH_I1
parse_name: const cv.CONTOURS_MATCH_I2 with ['cv'] -> fullname:cv::CONTOURS_MATCH_I2 namespace:cv classpath: classname: name:CONTOURS_MATCH_I2
parse_name: const cv.CONTOURS_MATCH_I3 with ['cv'] -> fullname:cv::CONTOURS_MATCH_I3 namespace:cv classpath: classname: name:CONTOURS_MATCH_I3

--- Incoming ---
[   'enum cv.HoughModes',
    '',
    [],
    [   ['const cv.HOUGH_STANDARD', '0', [], [], None, ''],
        ['const cv.HOUGH_PROBABILISTIC', '1', [], [], None, ''],
        ['const cv.HOUGH_MULTI_SCALE', '2', [], [], None, ''],
        [   'const cv.HOUGH_GRADIENT',
            '3',
            [],
            [],
            None,
            'basically *21HT*, described in @cite Yuen90\n']],
    None,
    '@} imgproc_shape\n'
    '@addtogroup imgproc_feature\n'
    '@{\n'
    'Variants of a Hough transform']
parse_name: const cv.HOUGH_STANDARD with ['cv'] -> fullname:cv::HOUGH_STANDARD namespace:cv classpath: classname: name:HOUGH_STANDARD
parse_name: const cv.HOUGH_PROBABILISTIC with ['cv'] -> fullname:cv::HOUGH_PROBABILISTIC namespace:cv classpath: classname: name:HOUGH_PROBABILISTIC
parse_name: const cv.HOUGH_MULTI_SCALE with ['cv'] -> fullname:cv::HOUGH_MULTI_SCALE namespace:cv classpath: classname: name:HOUGH_MULTI_SCALE
parse_name: const cv.HOUGH_GRADIENT with ['cv'] -> fullname:cv::HOUGH_GRADIENT namespace:cv classpath: classname: name:HOUGH_GRADIENT
parse_name: enum cv.HoughModes with ['cv'] -> fullname:cv::HoughModes namespace:cv classpath: classname: name:HoughModes
parse_name: const cv.HOUGH_STANDARD with ['cv'] -> fullname:cv::HOUGH_STANDARD namespace:cv classpath: classname: name:HOUGH_STANDARD
parse_name: const cv.HOUGH_PROBABILISTIC with ['cv'] -> fullname:cv::HOUGH_PROBABILISTIC namespace:cv classpath: classname: name:HOUGH_PROBABILISTIC
parse_name: const cv.HOUGH_MULTI_SCALE with ['cv'] -> fullname:cv::HOUGH_MULTI_SCALE namespace:cv classpath: classname: name:HOUGH_MULTI_SCALE
parse_name: const cv.HOUGH_GRADIENT with ['cv'] -> fullname:cv::HOUGH_GRADIENT namespace:cv classpath: classname: name:HOUGH_GRADIENT

--- Incoming ---
[   'enum cv.LineSegmentDetectorModes',
    '',
    [],
    [   [   'const cv.LSD_REFINE_NONE',
            '0',
            [],
            [],
            None,
            'No refinement applied\n'],
        [   'const cv.LSD_REFINE_STD',
            '1',
            [],
            [],
            None,
            'Standard refinement is applied. E.g. breaking arches into smaller '
            'straighter line approximations.\n'],
        [   'const cv.LSD_REFINE_ADV',
            '2',
            [],
            [],
            None,
            'Advanced refinement. Number of false alarms is calculated, lines '
            'are\n']],
    None,
    'Variants of Line Segment %Detector']
parse_name: const cv.LSD_REFINE_NONE with ['cv'] -> fullname:cv::LSD_REFINE_NONE namespace:cv classpath: classname: name:LSD_REFINE_NONE
parse_name: const cv.LSD_REFINE_STD with ['cv'] -> fullname:cv::LSD_REFINE_STD namespace:cv classpath: classname: name:LSD_REFINE_STD
parse_name: const cv.LSD_REFINE_ADV with ['cv'] -> fullname:cv::LSD_REFINE_ADV namespace:cv classpath: classname: name:LSD_REFINE_ADV
parse_name: enum cv.LineSegmentDetectorModes with ['cv'] -> fullname:cv::LineSegmentDetectorModes namespace:cv classpath: classname: name:LineSegmentDetectorModes
parse_name: const cv.LSD_REFINE_NONE with ['cv'] -> fullname:cv::LSD_REFINE_NONE namespace:cv classpath: classname: name:LSD_REFINE_NONE
parse_name: const cv.LSD_REFINE_STD with ['cv'] -> fullname:cv::LSD_REFINE_STD namespace:cv classpath: classname: name:LSD_REFINE_STD
parse_name: const cv.LSD_REFINE_ADV with ['cv'] -> fullname:cv::LSD_REFINE_ADV namespace:cv classpath: classname: name:LSD_REFINE_ADV

--- Incoming ---
[   'enum cv.HistCompMethods',
    '',
    [],
    [   ['const cv.HISTCMP_CORREL', '0', [], [], None, ''],
        ['const cv.HISTCMP_CHISQR', '1', [], [], None, ''],
        ['const cv.HISTCMP_INTERSECT', '2', [], [], None, ''],
        ['const cv.HISTCMP_BHATTACHARYYA', '3', [], [], None, ''],
        [   'const cv.HISTCMP_HELLINGER',
            'HISTCMP_BHATTACHARYYA',
            [],
            [],
            None,
            'Synonym for HISTCMP_BHATTACHARYYA\n'],
        ['const cv.HISTCMP_CHISQR_ALT', '4', [], [], None, ''],
        ['const cv.HISTCMP_KL_DIV', '5', [], [], None, '']],
    None,
    'Histogram comparison methods\n@ingroup imgproc_hist']
parse_name: const cv.HISTCMP_CORREL with ['cv'] -> fullname:cv::HISTCMP_CORREL namespace:cv classpath: classname: name:HISTCMP_CORREL
parse_name: const cv.HISTCMP_CHISQR with ['cv'] -> fullname:cv::HISTCMP_CHISQR namespace:cv classpath: classname: name:HISTCMP_CHISQR
parse_name: const cv.HISTCMP_INTERSECT with ['cv'] -> fullname:cv::HISTCMP_INTERSECT namespace:cv classpath: classname: name:HISTCMP_INTERSECT
parse_name: const cv.HISTCMP_BHATTACHARYYA with ['cv'] -> fullname:cv::HISTCMP_BHATTACHARYYA namespace:cv classpath: classname: name:HISTCMP_BHATTACHARYYA
parse_name: const cv.HISTCMP_HELLINGER with ['cv'] -> fullname:cv::HISTCMP_HELLINGER namespace:cv classpath: classname: name:HISTCMP_HELLINGER
parse_name: const cv.HISTCMP_CHISQR_ALT with ['cv'] -> fullname:cv::HISTCMP_CHISQR_ALT namespace:cv classpath: classname: name:HISTCMP_CHISQR_ALT
parse_name: const cv.HISTCMP_KL_DIV with ['cv'] -> fullname:cv::HISTCMP_KL_DIV namespace:cv classpath: classname: name:HISTCMP_KL_DIV
parse_name: enum cv.HistCompMethods with ['cv'] -> fullname:cv::HistCompMethods namespace:cv classpath: classname: name:HistCompMethods
parse_name: const cv.HISTCMP_CORREL with ['cv'] -> fullname:cv::HISTCMP_CORREL namespace:cv classpath: classname: name:HISTCMP_CORREL
parse_name: const cv.HISTCMP_CHISQR with ['cv'] -> fullname:cv::HISTCMP_CHISQR namespace:cv classpath: classname: name:HISTCMP_CHISQR
parse_name: const cv.HISTCMP_INTERSECT with ['cv'] -> fullname:cv::HISTCMP_INTERSECT namespace:cv classpath: classname: name:HISTCMP_INTERSECT
parse_name: const cv.HISTCMP_BHATTACHARYYA with ['cv'] -> fullname:cv::HISTCMP_BHATTACHARYYA namespace:cv classpath: classname: name:HISTCMP_BHATTACHARYYA
parse_name: const cv.HISTCMP_HELLINGER with ['cv'] -> fullname:cv::HISTCMP_HELLINGER namespace:cv classpath: classname: name:HISTCMP_HELLINGER
parse_name: const cv.HISTCMP_CHISQR_ALT with ['cv'] -> fullname:cv::HISTCMP_CHISQR_ALT namespace:cv classpath: classname: name:HISTCMP_CHISQR_ALT
parse_name: const cv.HISTCMP_KL_DIV with ['cv'] -> fullname:cv::HISTCMP_KL_DIV namespace:cv classpath: classname: name:HISTCMP_KL_DIV

--- Incoming ---
[   'enum cv.ColorConversionCodes',
    '',
    [],
    [   [   'const cv.COLOR_BGR2BGRA',
            '0',
            [],
            [],
            None,
            'add alpha channel to RGB or BGR image\n'],
        ['const cv.COLOR_RGB2RGBA', 'COLOR_BGR2BGRA', [], [], None, ''],
        [   'const cv.COLOR_BGRA2BGR',
            '1',
            [],
            [],
            None,
            'remove alpha channel from RGB or BGR image\n'],
        ['const cv.COLOR_RGBA2RGB', 'COLOR_BGRA2BGR', [], [], None, ''],
        [   'const cv.COLOR_BGR2RGBA',
            '2',
            [],
            [],
            None,
            'convert between RGB and BGR color spaces (with or without alpha '
            'channel)\n'],
        ['const cv.COLOR_RGB2BGRA', 'COLOR_BGR2RGBA', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGR', '3', [], [], None, ''],
        ['const cv.COLOR_BGRA2RGB', 'COLOR_RGBA2BGR', [], [], None, ''],
        ['const cv.COLOR_BGR2RGB', '4', [], [], None, ''],
        ['const cv.COLOR_RGB2BGR', 'COLOR_BGR2RGB', [], [], None, ''],
        ['const cv.COLOR_BGRA2RGBA', '5', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGRA', 'COLOR_BGRA2RGBA', [], [], None, ''],
        [   'const cv.COLOR_BGR2GRAY',
            '6',
            [],
            [],
            None,
            'convert between RGB/BGR and grayscale, @ref '
            'color_convert_rgb_gray "color conversions"\n'],
        ['const cv.COLOR_RGB2GRAY', '7', [], [], None, ''],
        ['const cv.COLOR_GRAY2BGR', '8', [], [], None, ''],
        ['const cv.COLOR_GRAY2RGB', 'COLOR_GRAY2BGR', [], [], None, ''],
        ['const cv.COLOR_GRAY2BGRA', '9', [], [], None, ''],
        ['const cv.COLOR_GRAY2RGBA', 'COLOR_GRAY2BGRA', [], [], None, ''],
        ['const cv.COLOR_BGRA2GRAY', '10', [], [], None, ''],
        ['const cv.COLOR_RGBA2GRAY', '11', [], [], None, ''],
        [   'const cv.COLOR_BGR2BGR565',
            '12',
            [],
            [],
            None,
            'convert between RGB/BGR and BGR565 (16-bit images)\n'],
        ['const cv.COLOR_RGB2BGR565', '13', [], [], None, ''],
        ['const cv.COLOR_BGR5652BGR', '14', [], [], None, ''],
        ['const cv.COLOR_BGR5652RGB', '15', [], [], None, ''],
        ['const cv.COLOR_BGRA2BGR565', '16', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGR565', '17', [], [], None, ''],
        ['const cv.COLOR_BGR5652BGRA', '18', [], [], None, ''],
        ['const cv.COLOR_BGR5652RGBA', '19', [], [], None, ''],
        [   'const cv.COLOR_GRAY2BGR565',
            '20',
            [],
            [],
            None,
            'convert between grayscale to BGR565 (16-bit images)\n'],
        ['const cv.COLOR_BGR5652GRAY', '21', [], [], None, ''],
        [   'const cv.COLOR_BGR2BGR555',
            '22',
            [],
            [],
            None,
            'convert between RGB/BGR and BGR555 (16-bit images)\n'],
        ['const cv.COLOR_RGB2BGR555', '23', [], [], None, ''],
        ['const cv.COLOR_BGR5552BGR', '24', [], [], None, ''],
        ['const cv.COLOR_BGR5552RGB', '25', [], [], None, ''],
        ['const cv.COLOR_BGRA2BGR555', '26', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGR555', '27', [], [], None, ''],
        ['const cv.COLOR_BGR5552BGRA', '28', [], [], None, ''],
        ['const cv.COLOR_BGR5552RGBA', '29', [], [], None, ''],
        [   'const cv.COLOR_GRAY2BGR555',
            '30',
            [],
            [],
            None,
            'convert between grayscale and BGR555 (16-bit images)\n'],
        ['const cv.COLOR_BGR5552GRAY', '31', [], [], None, ''],
        [   'const cv.COLOR_BGR2XYZ',
            '32',
            [],
            [],
            None,
            'convert RGB/BGR to CIE XYZ, @ref color_convert_rgb_xyz "color '
            'conversions"\n'],
        ['const cv.COLOR_RGB2XYZ', '33', [], [], None, ''],
        ['const cv.COLOR_XYZ2BGR', '34', [], [], None, ''],
        ['const cv.COLOR_XYZ2RGB', '35', [], [], None, ''],
        [   'const cv.COLOR_BGR2YCrCb',
            '36',
            [],
            [],
            None,
            'convert RGB/BGR to luma-chroma (aka YCC), @ref '
            'color_convert_rgb_ycrcb "color conversions"\n'],
        ['const cv.COLOR_RGB2YCrCb', '37', [], [], None, ''],
        ['const cv.COLOR_YCrCb2BGR', '38', [], [], None, ''],
        ['const cv.COLOR_YCrCb2RGB', '39', [], [], None, ''],
        [   'const cv.COLOR_BGR2HSV',
            '40',
            [],
            [],
            None,
            'convert RGB/BGR to HSV (hue saturation value), @ref '
            'color_convert_rgb_hsv "color conversions"\n'],
        ['const cv.COLOR_RGB2HSV', '41', [], [], None, ''],
        [   'const cv.COLOR_BGR2Lab',
            '44',
            [],
            [],
            None,
            'convert RGB/BGR to CIE Lab, @ref color_convert_rgb_lab "color '
            'conversions"\n'],
        ['const cv.COLOR_RGB2Lab', '45', [], [], None, ''],
        [   'const cv.COLOR_BGR2Luv',
            '50',
            [],
            [],
            None,
            'convert RGB/BGR to CIE Luv, @ref color_convert_rgb_luv "color '
            'conversions"\n'],
        ['const cv.COLOR_RGB2Luv', '51', [], [], None, ''],
        [   'const cv.COLOR_BGR2HLS',
            '52',
            [],
            [],
            None,
            'convert RGB/BGR to HLS (hue lightness saturation), @ref '
            'color_convert_rgb_hls "color conversions"\n'],
        ['const cv.COLOR_RGB2HLS', '53', [], [], None, ''],
        [   'const cv.COLOR_HSV2BGR',
            '54',
            [],
            [],
            None,
            'backward conversions to RGB/BGR\n'],
        ['const cv.COLOR_HSV2RGB', '55', [], [], None, ''],
        ['const cv.COLOR_Lab2BGR', '56', [], [], None, ''],
        ['const cv.COLOR_Lab2RGB', '57', [], [], None, ''],
        ['const cv.COLOR_Luv2BGR', '58', [], [], None, ''],
        ['const cv.COLOR_Luv2RGB', '59', [], [], None, ''],
        ['const cv.COLOR_HLS2BGR', '60', [], [], None, ''],
        ['const cv.COLOR_HLS2RGB', '61', [], [], None, ''],
        ['const cv.COLOR_BGR2HSV_FULL', '66', [], [], None, ''],
        ['const cv.COLOR_RGB2HSV_FULL', '67', [], [], None, ''],
        ['const cv.COLOR_BGR2HLS_FULL', '68', [], [], None, ''],
        ['const cv.COLOR_RGB2HLS_FULL', '69', [], [], None, ''],
        ['const cv.COLOR_HSV2BGR_FULL', '70', [], [], None, ''],
        ['const cv.COLOR_HSV2RGB_FULL', '71', [], [], None, ''],
        ['const cv.COLOR_HLS2BGR_FULL', '72', [], [], None, ''],
        ['const cv.COLOR_HLS2RGB_FULL', '73', [], [], None, ''],
        ['const cv.COLOR_LBGR2Lab', '74', [], [], None, ''],
        ['const cv.COLOR_LRGB2Lab', '75', [], [], None, ''],
        ['const cv.COLOR_LBGR2Luv', '76', [], [], None, ''],
        ['const cv.COLOR_LRGB2Luv', '77', [], [], None, ''],
        ['const cv.COLOR_Lab2LBGR', '78', [], [], None, ''],
        ['const cv.COLOR_Lab2LRGB', '79', [], [], None, ''],
        ['const cv.COLOR_Luv2LBGR', '80', [], [], None, ''],
        ['const cv.COLOR_Luv2LRGB', '81', [], [], None, ''],
        [   'const cv.COLOR_BGR2YUV',
            '82',
            [],
            [],
            None,
            'convert between RGB/BGR and YUV\n'],
        ['const cv.COLOR_RGB2YUV', '83', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR', '84', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB', '85', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_NV12', '90', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_NV12', '91', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_NV21', '92', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_NV21', '93', [], [], None, ''],
        ['const cv.COLOR_YUV420sp2RGB', 'COLOR_YUV2RGB_NV21', [], [], None, ''],
        ['const cv.COLOR_YUV420sp2BGR', 'COLOR_YUV2BGR_NV21', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_NV12', '94', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_NV12', '95', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_NV21', '96', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_NV21', '97', [], [], None, ''],
        [   'const cv.COLOR_YUV420sp2RGBA',
            'COLOR_YUV2RGBA_NV21',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420sp2BGRA',
            'COLOR_YUV2BGRA_NV21',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2RGB_YV12', '98', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YV12', '99', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_IYUV', '100', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_IYUV', '101', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_I420', 'COLOR_YUV2RGB_IYUV', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_I420', 'COLOR_YUV2BGR_IYUV', [], [], None, ''],
        ['const cv.COLOR_YUV420p2RGB', 'COLOR_YUV2RGB_YV12', [], [], None, ''],
        ['const cv.COLOR_YUV420p2BGR', 'COLOR_YUV2BGR_YV12', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_YV12', '102', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_YV12', '103', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_IYUV', '104', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_IYUV', '105', [], [], None, ''],
        [   'const cv.COLOR_YUV2RGBA_I420',
            'COLOR_YUV2RGBA_IYUV',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_I420',
            'COLOR_YUV2BGRA_IYUV',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420p2RGBA',
            'COLOR_YUV2RGBA_YV12',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420p2BGRA',
            'COLOR_YUV2BGRA_YV12',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2GRAY_420', '106', [], [], None, ''],
        [   'const cv.COLOR_YUV2GRAY_NV21',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_NV12',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YV12',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_IYUV',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_I420',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420sp2GRAY',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV420p2GRAY', 'COLOR_YUV2GRAY_420', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_UYVY', '107', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_UYVY', '108', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_Y422', 'COLOR_YUV2RGB_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_Y422', 'COLOR_YUV2BGR_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_UYNV', 'COLOR_YUV2RGB_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_UYNV', 'COLOR_YUV2BGR_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_UYVY', '111', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_UYVY', '112', [], [], None, ''],
        [   'const cv.COLOR_YUV2RGBA_Y422',
            'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_Y422',
            'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2RGBA_UYNV',
            'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_UYNV',
            'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2RGB_YUY2', '115', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YUY2', '116', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_YVYU', '117', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YVYU', '118', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_YUYV', 'COLOR_YUV2RGB_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YUYV', 'COLOR_YUV2BGR_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_YUNV', 'COLOR_YUV2RGB_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YUNV', 'COLOR_YUV2BGR_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_YUY2', '119', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_YUY2', '120', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_YVYU', '121', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_YVYU', '122', [], [], None, ''],
        [   'const cv.COLOR_YUV2RGBA_YUYV',
            'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_YUYV',
            'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2RGBA_YUNV',
            'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_YUNV',
            'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2GRAY_UYVY', '123', [], [], None, ''],
        ['const cv.COLOR_YUV2GRAY_YUY2', '124', [], [], None, ''],
        [   'const cv.COLOR_YUV2GRAY_Y422',
            'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_UYNV',
            'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YVYU',
            'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YUYV',
            'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YUNV',
            'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_RGBA2mRGBA', '125', [], [], None, ''],
        ['const cv.COLOR_mRGBA2RGBA', '126', [], [], None, ''],
        ['const cv.COLOR_RGB2YUV_I420', '127', [], [], None, ''],
        ['const cv.COLOR_BGR2YUV_I420', '128', [], [], None, ''],
        ['const cv.COLOR_RGB2YUV_IYUV', 'COLOR_RGB2YUV_I420', [], [], None, ''],
        ['const cv.COLOR_BGR2YUV_IYUV', 'COLOR_BGR2YUV_I420', [], [], None, ''],
        ['const cv.COLOR_RGBA2YUV_I420', '129', [], [], None, ''],
        ['const cv.COLOR_BGRA2YUV_I420', '130', [], [], None, ''],
        [   'const cv.COLOR_RGBA2YUV_IYUV',
            'COLOR_RGBA2YUV_I420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BGRA2YUV_IYUV',
            'COLOR_BGRA2YUV_I420',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_RGB2YUV_YV12', '131', [], [], None, ''],
        ['const cv.COLOR_BGR2YUV_YV12', '132', [], [], None, ''],
        ['const cv.COLOR_RGBA2YUV_YV12', '133', [], [], None, ''],
        ['const cv.COLOR_BGRA2YUV_YV12', '134', [], [], None, ''],
        ['const cv.COLOR_BayerBG2BGR', '46', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGR', '47', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGR', '48', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGR', '49', [], [], None, ''],
        ['const cv.COLOR_BayerBG2RGB', 'COLOR_BayerRG2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerGB2RGB', 'COLOR_BayerGR2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerRG2RGB', 'COLOR_BayerBG2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerGR2RGB', 'COLOR_BayerGB2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerBG2GRAY', '86', [], [], None, ''],
        ['const cv.COLOR_BayerGB2GRAY', '87', [], [], None, ''],
        ['const cv.COLOR_BayerRG2GRAY', '88', [], [], None, ''],
        ['const cv.COLOR_BayerGR2GRAY', '89', [], [], None, ''],
        ['const cv.COLOR_BayerBG2BGR_VNG', '62', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGR_VNG', '63', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGR_VNG', '64', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGR_VNG', '65', [], [], None, ''],
        [   'const cv.COLOR_BayerBG2RGB_VNG',
            'COLOR_BayerRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGB2RGB_VNG',
            'COLOR_BayerGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerRG2RGB_VNG',
            'COLOR_BayerBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGR2RGB_VNG',
            'COLOR_BayerGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_BayerBG2BGR_EA', '135', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGR_EA', '136', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGR_EA', '137', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGR_EA', '138', [], [], None, ''],
        [   'const cv.COLOR_BayerBG2RGB_EA',
            'COLOR_BayerRG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGB2RGB_EA',
            'COLOR_BayerGR2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerRG2RGB_EA',
            'COLOR_BayerBG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGR2RGB_EA',
            'COLOR_BayerGB2BGR_EA',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_BayerBG2BGRA', '139', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGRA', '140', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGRA', '141', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGRA', '142', [], [], None, ''],
        ['const cv.COLOR_BayerBG2RGBA', 'COLOR_BayerRG2BGRA', [], [], None, ''],
        ['const cv.COLOR_BayerGB2RGBA', 'COLOR_BayerGR2BGRA', [], [], None, ''],
        ['const cv.COLOR_BayerRG2RGBA', 'COLOR_BayerBG2BGRA', [], [], None, ''],
        ['const cv.COLOR_BayerGR2RGBA', 'COLOR_BayerGB2BGRA', [], [], None, ''],
        ['const cv.COLOR_COLORCVT_MAX', '143', [], [], None, '']],
    None,
    'the color conversion codes\n'
    '@see @ref imgproc_color_conversions\n'
    '@ingroup imgproc_color_conversions']
parse_name: const cv.COLOR_BGR2BGRA with ['cv'] -> fullname:cv::COLOR_BGR2BGRA namespace:cv classpath: classname: name:COLOR_BGR2BGRA
parse_name: const cv.COLOR_RGB2RGBA with ['cv'] -> fullname:cv::COLOR_RGB2RGBA namespace:cv classpath: classname: name:COLOR_RGB2RGBA
parse_name: const cv.COLOR_BGRA2BGR with ['cv'] -> fullname:cv::COLOR_BGRA2BGR namespace:cv classpath: classname: name:COLOR_BGRA2BGR
parse_name: const cv.COLOR_RGBA2RGB with ['cv'] -> fullname:cv::COLOR_RGBA2RGB namespace:cv classpath: classname: name:COLOR_RGBA2RGB
parse_name: const cv.COLOR_BGR2RGBA with ['cv'] -> fullname:cv::COLOR_BGR2RGBA namespace:cv classpath: classname: name:COLOR_BGR2RGBA
parse_name: const cv.COLOR_RGB2BGRA with ['cv'] -> fullname:cv::COLOR_RGB2BGRA namespace:cv classpath: classname: name:COLOR_RGB2BGRA
parse_name: const cv.COLOR_RGBA2BGR with ['cv'] -> fullname:cv::COLOR_RGBA2BGR namespace:cv classpath: classname: name:COLOR_RGBA2BGR
parse_name: const cv.COLOR_BGRA2RGB with ['cv'] -> fullname:cv::COLOR_BGRA2RGB namespace:cv classpath: classname: name:COLOR_BGRA2RGB
parse_name: const cv.COLOR_BGR2RGB with ['cv'] -> fullname:cv::COLOR_BGR2RGB namespace:cv classpath: classname: name:COLOR_BGR2RGB
parse_name: const cv.COLOR_RGB2BGR with ['cv'] -> fullname:cv::COLOR_RGB2BGR namespace:cv classpath: classname: name:COLOR_RGB2BGR
parse_name: const cv.COLOR_BGRA2RGBA with ['cv'] -> fullname:cv::COLOR_BGRA2RGBA namespace:cv classpath: classname: name:COLOR_BGRA2RGBA
parse_name: const cv.COLOR_RGBA2BGRA with ['cv'] -> fullname:cv::COLOR_RGBA2BGRA namespace:cv classpath: classname: name:COLOR_RGBA2BGRA
parse_name: const cv.COLOR_BGR2GRAY with ['cv'] -> fullname:cv::COLOR_BGR2GRAY namespace:cv classpath: classname: name:COLOR_BGR2GRAY
parse_name: const cv.COLOR_RGB2GRAY with ['cv'] -> fullname:cv::COLOR_RGB2GRAY namespace:cv classpath: classname: name:COLOR_RGB2GRAY
parse_name: const cv.COLOR_GRAY2BGR with ['cv'] -> fullname:cv::COLOR_GRAY2BGR namespace:cv classpath: classname: name:COLOR_GRAY2BGR
parse_name: const cv.COLOR_GRAY2RGB with ['cv'] -> fullname:cv::COLOR_GRAY2RGB namespace:cv classpath: classname: name:COLOR_GRAY2RGB
parse_name: const cv.COLOR_GRAY2BGRA with ['cv'] -> fullname:cv::COLOR_GRAY2BGRA namespace:cv classpath: classname: name:COLOR_GRAY2BGRA
parse_name: const cv.COLOR_GRAY2RGBA with ['cv'] -> fullname:cv::COLOR_GRAY2RGBA namespace:cv classpath: classname: name:COLOR_GRAY2RGBA
parse_name: const cv.COLOR_BGRA2GRAY with ['cv'] -> fullname:cv::COLOR_BGRA2GRAY namespace:cv classpath: classname: name:COLOR_BGRA2GRAY
parse_name: const cv.COLOR_RGBA2GRAY with ['cv'] -> fullname:cv::COLOR_RGBA2GRAY namespace:cv classpath: classname: name:COLOR_RGBA2GRAY
parse_name: const cv.COLOR_BGR2BGR565 with ['cv'] -> fullname:cv::COLOR_BGR2BGR565 namespace:cv classpath: classname: name:COLOR_BGR2BGR565
parse_name: const cv.COLOR_RGB2BGR565 with ['cv'] -> fullname:cv::COLOR_RGB2BGR565 namespace:cv classpath: classname: name:COLOR_RGB2BGR565
parse_name: const cv.COLOR_BGR5652BGR with ['cv'] -> fullname:cv::COLOR_BGR5652BGR namespace:cv classpath: classname: name:COLOR_BGR5652BGR
parse_name: const cv.COLOR_BGR5652RGB with ['cv'] -> fullname:cv::COLOR_BGR5652RGB namespace:cv classpath: classname: name:COLOR_BGR5652RGB
parse_name: const cv.COLOR_BGRA2BGR565 with ['cv'] -> fullname:cv::COLOR_BGRA2BGR565 namespace:cv classpath: classname: name:COLOR_BGRA2BGR565
parse_name: const cv.COLOR_RGBA2BGR565 with ['cv'] -> fullname:cv::COLOR_RGBA2BGR565 namespace:cv classpath: classname: name:COLOR_RGBA2BGR565
parse_name: const cv.COLOR_BGR5652BGRA with ['cv'] -> fullname:cv::COLOR_BGR5652BGRA namespace:cv classpath: classname: name:COLOR_BGR5652BGRA
parse_name: const cv.COLOR_BGR5652RGBA with ['cv'] -> fullname:cv::COLOR_BGR5652RGBA namespace:cv classpath: classname: name:COLOR_BGR5652RGBA
parse_name: const cv.COLOR_GRAY2BGR565 with ['cv'] -> fullname:cv::COLOR_GRAY2BGR565 namespace:cv classpath: classname: name:COLOR_GRAY2BGR565
parse_name: const cv.COLOR_BGR5652GRAY with ['cv'] -> fullname:cv::COLOR_BGR5652GRAY namespace:cv classpath: classname: name:COLOR_BGR5652GRAY
parse_name: const cv.COLOR_BGR2BGR555 with ['cv'] -> fullname:cv::COLOR_BGR2BGR555 namespace:cv classpath: classname: name:COLOR_BGR2BGR555
parse_name: const cv.COLOR_RGB2BGR555 with ['cv'] -> fullname:cv::COLOR_RGB2BGR555 namespace:cv classpath: classname: name:COLOR_RGB2BGR555
parse_name: const cv.COLOR_BGR5552BGR with ['cv'] -> fullname:cv::COLOR_BGR5552BGR namespace:cv classpath: classname: name:COLOR_BGR5552BGR
parse_name: const cv.COLOR_BGR5552RGB with ['cv'] -> fullname:cv::COLOR_BGR5552RGB namespace:cv classpath: classname: name:COLOR_BGR5552RGB
parse_name: const cv.COLOR_BGRA2BGR555 with ['cv'] -> fullname:cv::COLOR_BGRA2BGR555 namespace:cv classpath: classname: name:COLOR_BGRA2BGR555
parse_name: const cv.COLOR_RGBA2BGR555 with ['cv'] -> fullname:cv::COLOR_RGBA2BGR555 namespace:cv classpath: classname: name:COLOR_RGBA2BGR555
parse_name: const cv.COLOR_BGR5552BGRA with ['cv'] -> fullname:cv::COLOR_BGR5552BGRA namespace:cv classpath: classname: name:COLOR_BGR5552BGRA
parse_name: const cv.COLOR_BGR5552RGBA with ['cv'] -> fullname:cv::COLOR_BGR5552RGBA namespace:cv classpath: classname: name:COLOR_BGR5552RGBA
parse_name: const cv.COLOR_GRAY2BGR555 with ['cv'] -> fullname:cv::COLOR_GRAY2BGR555 namespace:cv classpath: classname: name:COLOR_GRAY2BGR555
parse_name: const cv.COLOR_BGR5552GRAY with ['cv'] -> fullname:cv::COLOR_BGR5552GRAY namespace:cv classpath: classname: name:COLOR_BGR5552GRAY
parse_name: const cv.COLOR_BGR2XYZ with ['cv'] -> fullname:cv::COLOR_BGR2XYZ namespace:cv classpath: classname: name:COLOR_BGR2XYZ
parse_name: const cv.COLOR_RGB2XYZ with ['cv'] -> fullname:cv::COLOR_RGB2XYZ namespace:cv classpath: classname: name:COLOR_RGB2XYZ
parse_name: const cv.COLOR_XYZ2BGR with ['cv'] -> fullname:cv::COLOR_XYZ2BGR namespace:cv classpath: classname: name:COLOR_XYZ2BGR
parse_name: const cv.COLOR_XYZ2RGB with ['cv'] -> fullname:cv::COLOR_XYZ2RGB namespace:cv classpath: classname: name:COLOR_XYZ2RGB
parse_name: const cv.COLOR_BGR2YCrCb with ['cv'] -> fullname:cv::COLOR_BGR2YCrCb namespace:cv classpath: classname: name:COLOR_BGR2YCrCb
parse_name: const cv.COLOR_RGB2YCrCb with ['cv'] -> fullname:cv::COLOR_RGB2YCrCb namespace:cv classpath: classname: name:COLOR_RGB2YCrCb
parse_name: const cv.COLOR_YCrCb2BGR with ['cv'] -> fullname:cv::COLOR_YCrCb2BGR namespace:cv classpath: classname: name:COLOR_YCrCb2BGR
parse_name: const cv.COLOR_YCrCb2RGB with ['cv'] -> fullname:cv::COLOR_YCrCb2RGB namespace:cv classpath: classname: name:COLOR_YCrCb2RGB
parse_name: const cv.COLOR_BGR2HSV with ['cv'] -> fullname:cv::COLOR_BGR2HSV namespace:cv classpath: classname: name:COLOR_BGR2HSV
parse_name: const cv.COLOR_RGB2HSV with ['cv'] -> fullname:cv::COLOR_RGB2HSV namespace:cv classpath: classname: name:COLOR_RGB2HSV
parse_name: const cv.COLOR_BGR2Lab with ['cv'] -> fullname:cv::COLOR_BGR2Lab namespace:cv classpath: classname: name:COLOR_BGR2Lab
parse_name: const cv.COLOR_RGB2Lab with ['cv'] -> fullname:cv::COLOR_RGB2Lab namespace:cv classpath: classname: name:COLOR_RGB2Lab
parse_name: const cv.COLOR_BGR2Luv with ['cv'] -> fullname:cv::COLOR_BGR2Luv namespace:cv classpath: classname: name:COLOR_BGR2Luv
parse_name: const cv.COLOR_RGB2Luv with ['cv'] -> fullname:cv::COLOR_RGB2Luv namespace:cv classpath: classname: name:COLOR_RGB2Luv
parse_name: const cv.COLOR_BGR2HLS with ['cv'] -> fullname:cv::COLOR_BGR2HLS namespace:cv classpath: classname: name:COLOR_BGR2HLS
parse_name: const cv.COLOR_RGB2HLS with ['cv'] -> fullname:cv::COLOR_RGB2HLS namespace:cv classpath: classname: name:COLOR_RGB2HLS
parse_name: const cv.COLOR_HSV2BGR with ['cv'] -> fullname:cv::COLOR_HSV2BGR namespace:cv classpath: classname: name:COLOR_HSV2BGR
parse_name: const cv.COLOR_HSV2RGB with ['cv'] -> fullname:cv::COLOR_HSV2RGB namespace:cv classpath: classname: name:COLOR_HSV2RGB
parse_name: const cv.COLOR_Lab2BGR with ['cv'] -> fullname:cv::COLOR_Lab2BGR namespace:cv classpath: classname: name:COLOR_Lab2BGR
parse_name: const cv.COLOR_Lab2RGB with ['cv'] -> fullname:cv::COLOR_Lab2RGB namespace:cv classpath: classname: name:COLOR_Lab2RGB
parse_name: const cv.COLOR_Luv2BGR with ['cv'] -> fullname:cv::COLOR_Luv2BGR namespace:cv classpath: classname: name:COLOR_Luv2BGR
parse_name: const cv.COLOR_Luv2RGB with ['cv'] -> fullname:cv::COLOR_Luv2RGB namespace:cv classpath: classname: name:COLOR_Luv2RGB
parse_name: const cv.COLOR_HLS2BGR with ['cv'] -> fullname:cv::COLOR_HLS2BGR namespace:cv classpath: classname: name:COLOR_HLS2BGR
parse_name: const cv.COLOR_HLS2RGB with ['cv'] -> fullname:cv::COLOR_HLS2RGB namespace:cv classpath: classname: name:COLOR_HLS2RGB
parse_name: const cv.COLOR_BGR2HSV_FULL with ['cv'] -> fullname:cv::COLOR_BGR2HSV_FULL namespace:cv classpath: classname: name:COLOR_BGR2HSV_FULL
parse_name: const cv.COLOR_RGB2HSV_FULL with ['cv'] -> fullname:cv::COLOR_RGB2HSV_FULL namespace:cv classpath: classname: name:COLOR_RGB2HSV_FULL
parse_name: const cv.COLOR_BGR2HLS_FULL with ['cv'] -> fullname:cv::COLOR_BGR2HLS_FULL namespace:cv classpath: classname: name:COLOR_BGR2HLS_FULL
parse_name: const cv.COLOR_RGB2HLS_FULL with ['cv'] -> fullname:cv::COLOR_RGB2HLS_FULL namespace:cv classpath: classname: name:COLOR_RGB2HLS_FULL
parse_name: const cv.COLOR_HSV2BGR_FULL with ['cv'] -> fullname:cv::COLOR_HSV2BGR_FULL namespace:cv classpath: classname: name:COLOR_HSV2BGR_FULL
parse_name: const cv.COLOR_HSV2RGB_FULL with ['cv'] -> fullname:cv::COLOR_HSV2RGB_FULL namespace:cv classpath: classname: name:COLOR_HSV2RGB_FULL
parse_name: const cv.COLOR_HLS2BGR_FULL with ['cv'] -> fullname:cv::COLOR_HLS2BGR_FULL namespace:cv classpath: classname: name:COLOR_HLS2BGR_FULL
parse_name: const cv.COLOR_HLS2RGB_FULL with ['cv'] -> fullname:cv::COLOR_HLS2RGB_FULL namespace:cv classpath: classname: name:COLOR_HLS2RGB_FULL
parse_name: const cv.COLOR_LBGR2Lab with ['cv'] -> fullname:cv::COLOR_LBGR2Lab namespace:cv classpath: classname: name:COLOR_LBGR2Lab
parse_name: const cv.COLOR_LRGB2Lab with ['cv'] -> fullname:cv::COLOR_LRGB2Lab namespace:cv classpath: classname: name:COLOR_LRGB2Lab
parse_name: const cv.COLOR_LBGR2Luv with ['cv'] -> fullname:cv::COLOR_LBGR2Luv namespace:cv classpath: classname: name:COLOR_LBGR2Luv
parse_name: const cv.COLOR_LRGB2Luv with ['cv'] -> fullname:cv::COLOR_LRGB2Luv namespace:cv classpath: classname: name:COLOR_LRGB2Luv
parse_name: const cv.COLOR_Lab2LBGR with ['cv'] -> fullname:cv::COLOR_Lab2LBGR namespace:cv classpath: classname: name:COLOR_Lab2LBGR
parse_name: const cv.COLOR_Lab2LRGB with ['cv'] -> fullname:cv::COLOR_Lab2LRGB namespace:cv classpath: classname: name:COLOR_Lab2LRGB
parse_name: const cv.COLOR_Luv2LBGR with ['cv'] -> fullname:cv::COLOR_Luv2LBGR namespace:cv classpath: classname: name:COLOR_Luv2LBGR
parse_name: const cv.COLOR_Luv2LRGB with ['cv'] -> fullname:cv::COLOR_Luv2LRGB namespace:cv classpath: classname: name:COLOR_Luv2LRGB
parse_name: const cv.COLOR_BGR2YUV with ['cv'] -> fullname:cv::COLOR_BGR2YUV namespace:cv classpath: classname: name:COLOR_BGR2YUV
parse_name: const cv.COLOR_RGB2YUV with ['cv'] -> fullname:cv::COLOR_RGB2YUV namespace:cv classpath: classname: name:COLOR_RGB2YUV
parse_name: const cv.COLOR_YUV2BGR with ['cv'] -> fullname:cv::COLOR_YUV2BGR namespace:cv classpath: classname: name:COLOR_YUV2BGR
parse_name: const cv.COLOR_YUV2RGB with ['cv'] -> fullname:cv::COLOR_YUV2RGB namespace:cv classpath: classname: name:COLOR_YUV2RGB
parse_name: const cv.COLOR_YUV2RGB_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_NV12 namespace:cv classpath: classname: name:COLOR_YUV2RGB_NV12
parse_name: const cv.COLOR_YUV2BGR_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_NV12 namespace:cv classpath: classname: name:COLOR_YUV2BGR_NV12
parse_name: const cv.COLOR_YUV2RGB_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_NV21 namespace:cv classpath: classname: name:COLOR_YUV2RGB_NV21
parse_name: const cv.COLOR_YUV2BGR_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_NV21 namespace:cv classpath: classname: name:COLOR_YUV2BGR_NV21
parse_name: const cv.COLOR_YUV420sp2RGB with ['cv'] -> fullname:cv::COLOR_YUV420sp2RGB namespace:cv classpath: classname: name:COLOR_YUV420sp2RGB
parse_name: const cv.COLOR_YUV420sp2BGR with ['cv'] -> fullname:cv::COLOR_YUV420sp2BGR namespace:cv classpath: classname: name:COLOR_YUV420sp2BGR
parse_name: const cv.COLOR_YUV2RGBA_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_NV12 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_NV12
parse_name: const cv.COLOR_YUV2BGRA_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_NV12 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_NV12
parse_name: const cv.COLOR_YUV2RGBA_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_NV21 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_NV21
parse_name: const cv.COLOR_YUV2BGRA_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_NV21 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_NV21
parse_name: const cv.COLOR_YUV420sp2RGBA with ['cv'] -> fullname:cv::COLOR_YUV420sp2RGBA namespace:cv classpath: classname: name:COLOR_YUV420sp2RGBA
parse_name: const cv.COLOR_YUV420sp2BGRA with ['cv'] -> fullname:cv::COLOR_YUV420sp2BGRA namespace:cv classpath: classname: name:COLOR_YUV420sp2BGRA
parse_name: const cv.COLOR_YUV2RGB_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YV12 namespace:cv classpath: classname: name:COLOR_YUV2RGB_YV12
parse_name: const cv.COLOR_YUV2BGR_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YV12 namespace:cv classpath: classname: name:COLOR_YUV2BGR_YV12
parse_name: const cv.COLOR_YUV2RGB_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_IYUV namespace:cv classpath: classname: name:COLOR_YUV2RGB_IYUV
parse_name: const cv.COLOR_YUV2BGR_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_IYUV namespace:cv classpath: classname: name:COLOR_YUV2BGR_IYUV
parse_name: const cv.COLOR_YUV2RGB_I420 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_I420 namespace:cv classpath: classname: name:COLOR_YUV2RGB_I420
parse_name: const cv.COLOR_YUV2BGR_I420 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_I420 namespace:cv classpath: classname: name:COLOR_YUV2BGR_I420
parse_name: const cv.COLOR_YUV420p2RGB with ['cv'] -> fullname:cv::COLOR_YUV420p2RGB namespace:cv classpath: classname: name:COLOR_YUV420p2RGB
parse_name: const cv.COLOR_YUV420p2BGR with ['cv'] -> fullname:cv::COLOR_YUV420p2BGR namespace:cv classpath: classname: name:COLOR_YUV420p2BGR
parse_name: const cv.COLOR_YUV2RGBA_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YV12 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YV12
parse_name: const cv.COLOR_YUV2BGRA_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YV12 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YV12
parse_name: const cv.COLOR_YUV2RGBA_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_IYUV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_IYUV
parse_name: const cv.COLOR_YUV2BGRA_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_IYUV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_IYUV
parse_name: const cv.COLOR_YUV2RGBA_I420 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_I420 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_I420
parse_name: const cv.COLOR_YUV2BGRA_I420 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_I420 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_I420
parse_name: const cv.COLOR_YUV420p2RGBA with ['cv'] -> fullname:cv::COLOR_YUV420p2RGBA namespace:cv classpath: classname: name:COLOR_YUV420p2RGBA
parse_name: const cv.COLOR_YUV420p2BGRA with ['cv'] -> fullname:cv::COLOR_YUV420p2BGRA namespace:cv classpath: classname: name:COLOR_YUV420p2BGRA
parse_name: const cv.COLOR_YUV2GRAY_420 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_420 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_420
parse_name: const cv.COLOR_YUV2GRAY_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_NV21 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_NV21
parse_name: const cv.COLOR_YUV2GRAY_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_NV12 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_NV12
parse_name: const cv.COLOR_YUV2GRAY_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YV12 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YV12
parse_name: const cv.COLOR_YUV2GRAY_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_IYUV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_IYUV
parse_name: const cv.COLOR_YUV2GRAY_I420 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_I420 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_I420
parse_name: const cv.COLOR_YUV420sp2GRAY with ['cv'] -> fullname:cv::COLOR_YUV420sp2GRAY namespace:cv classpath: classname: name:COLOR_YUV420sp2GRAY
parse_name: const cv.COLOR_YUV420p2GRAY with ['cv'] -> fullname:cv::COLOR_YUV420p2GRAY namespace:cv classpath: classname: name:COLOR_YUV420p2GRAY
parse_name: const cv.COLOR_YUV2RGB_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2RGB_UYVY namespace:cv classpath: classname: name:COLOR_YUV2RGB_UYVY
parse_name: const cv.COLOR_YUV2BGR_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2BGR_UYVY namespace:cv classpath: classname: name:COLOR_YUV2BGR_UYVY
parse_name: const cv.COLOR_YUV2RGB_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_Y422 namespace:cv classpath: classname: name:COLOR_YUV2RGB_Y422
parse_name: const cv.COLOR_YUV2BGR_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_Y422 namespace:cv classpath: classname: name:COLOR_YUV2BGR_Y422
parse_name: const cv.COLOR_YUV2RGB_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_UYNV namespace:cv classpath: classname: name:COLOR_YUV2RGB_UYNV
parse_name: const cv.COLOR_YUV2BGR_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_UYNV namespace:cv classpath: classname: name:COLOR_YUV2BGR_UYNV
parse_name: const cv.COLOR_YUV2RGBA_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_UYVY namespace:cv classpath: classname: name:COLOR_YUV2RGBA_UYVY
parse_name: const cv.COLOR_YUV2BGRA_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_UYVY namespace:cv classpath: classname: name:COLOR_YUV2BGRA_UYVY
parse_name: const cv.COLOR_YUV2RGBA_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_Y422 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_Y422
parse_name: const cv.COLOR_YUV2BGRA_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_Y422 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_Y422
parse_name: const cv.COLOR_YUV2RGBA_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_UYNV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_UYNV
parse_name: const cv.COLOR_YUV2BGRA_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_UYNV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_UYNV
parse_name: const cv.COLOR_YUV2RGB_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2RGB_YUY2
parse_name: const cv.COLOR_YUV2BGR_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2BGR_YUY2
parse_name: const cv.COLOR_YUV2RGB_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YVYU namespace:cv classpath: classname: name:COLOR_YUV2RGB_YVYU
parse_name: const cv.COLOR_YUV2BGR_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YVYU namespace:cv classpath: classname: name:COLOR_YUV2BGR_YVYU
parse_name: const cv.COLOR_YUV2RGB_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YUYV namespace:cv classpath: classname: name:COLOR_YUV2RGB_YUYV
parse_name: const cv.COLOR_YUV2BGR_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YUYV namespace:cv classpath: classname: name:COLOR_YUV2BGR_YUYV
parse_name: const cv.COLOR_YUV2RGB_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YUNV namespace:cv classpath: classname: name:COLOR_YUV2RGB_YUNV
parse_name: const cv.COLOR_YUV2BGR_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YUNV namespace:cv classpath: classname: name:COLOR_YUV2BGR_YUNV
parse_name: const cv.COLOR_YUV2RGBA_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YUY2
parse_name: const cv.COLOR_YUV2BGRA_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YUY2
parse_name: const cv.COLOR_YUV2RGBA_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YVYU namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YVYU
parse_name: const cv.COLOR_YUV2BGRA_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YVYU namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YVYU
parse_name: const cv.COLOR_YUV2RGBA_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YUYV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YUYV
parse_name: const cv.COLOR_YUV2BGRA_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YUYV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YUYV
parse_name: const cv.COLOR_YUV2RGBA_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YUNV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YUNV
parse_name: const cv.COLOR_YUV2BGRA_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YUNV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YUNV
parse_name: const cv.COLOR_YUV2GRAY_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_UYVY namespace:cv classpath: classname: name:COLOR_YUV2GRAY_UYVY
parse_name: const cv.COLOR_YUV2GRAY_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YUY2
parse_name: const cv.COLOR_YUV2GRAY_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_Y422 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_Y422
parse_name: const cv.COLOR_YUV2GRAY_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_UYNV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_UYNV
parse_name: const cv.COLOR_YUV2GRAY_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YVYU namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YVYU
parse_name: const cv.COLOR_YUV2GRAY_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YUYV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YUYV
parse_name: const cv.COLOR_YUV2GRAY_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YUNV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YUNV
parse_name: const cv.COLOR_RGBA2mRGBA with ['cv'] -> fullname:cv::COLOR_RGBA2mRGBA namespace:cv classpath: classname: name:COLOR_RGBA2mRGBA
parse_name: const cv.COLOR_mRGBA2RGBA with ['cv'] -> fullname:cv::COLOR_mRGBA2RGBA namespace:cv classpath: classname: name:COLOR_mRGBA2RGBA
parse_name: const cv.COLOR_RGB2YUV_I420 with ['cv'] -> fullname:cv::COLOR_RGB2YUV_I420 namespace:cv classpath: classname: name:COLOR_RGB2YUV_I420
parse_name: const cv.COLOR_BGR2YUV_I420 with ['cv'] -> fullname:cv::COLOR_BGR2YUV_I420 namespace:cv classpath: classname: name:COLOR_BGR2YUV_I420
parse_name: const cv.COLOR_RGB2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_RGB2YUV_IYUV namespace:cv classpath: classname: name:COLOR_RGB2YUV_IYUV
parse_name: const cv.COLOR_BGR2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_BGR2YUV_IYUV namespace:cv classpath: classname: name:COLOR_BGR2YUV_IYUV
parse_name: const cv.COLOR_RGBA2YUV_I420 with ['cv'] -> fullname:cv::COLOR_RGBA2YUV_I420 namespace:cv classpath: classname: name:COLOR_RGBA2YUV_I420
parse_name: const cv.COLOR_BGRA2YUV_I420 with ['cv'] -> fullname:cv::COLOR_BGRA2YUV_I420 namespace:cv classpath: classname: name:COLOR_BGRA2YUV_I420
parse_name: const cv.COLOR_RGBA2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_RGBA2YUV_IYUV namespace:cv classpath: classname: name:COLOR_RGBA2YUV_IYUV
parse_name: const cv.COLOR_BGRA2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_BGRA2YUV_IYUV namespace:cv classpath: classname: name:COLOR_BGRA2YUV_IYUV
parse_name: const cv.COLOR_RGB2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_RGB2YUV_YV12 namespace:cv classpath: classname: name:COLOR_RGB2YUV_YV12
parse_name: const cv.COLOR_BGR2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_BGR2YUV_YV12 namespace:cv classpath: classname: name:COLOR_BGR2YUV_YV12
parse_name: const cv.COLOR_RGBA2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_RGBA2YUV_YV12 namespace:cv classpath: classname: name:COLOR_RGBA2YUV_YV12
parse_name: const cv.COLOR_BGRA2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_BGRA2YUV_YV12 namespace:cv classpath: classname: name:COLOR_BGRA2YUV_YV12
parse_name: const cv.COLOR_BayerBG2BGR with ['cv'] -> fullname:cv::COLOR_BayerBG2BGR namespace:cv classpath: classname: name:COLOR_BayerBG2BGR
parse_name: const cv.COLOR_BayerGB2BGR with ['cv'] -> fullname:cv::COLOR_BayerGB2BGR namespace:cv classpath: classname: name:COLOR_BayerGB2BGR
parse_name: const cv.COLOR_BayerRG2BGR with ['cv'] -> fullname:cv::COLOR_BayerRG2BGR namespace:cv classpath: classname: name:COLOR_BayerRG2BGR
parse_name: const cv.COLOR_BayerGR2BGR with ['cv'] -> fullname:cv::COLOR_BayerGR2BGR namespace:cv classpath: classname: name:COLOR_BayerGR2BGR
parse_name: const cv.COLOR_BayerBG2RGB with ['cv'] -> fullname:cv::COLOR_BayerBG2RGB namespace:cv classpath: classname: name:COLOR_BayerBG2RGB
parse_name: const cv.COLOR_BayerGB2RGB with ['cv'] -> fullname:cv::COLOR_BayerGB2RGB namespace:cv classpath: classname: name:COLOR_BayerGB2RGB
parse_name: const cv.COLOR_BayerRG2RGB with ['cv'] -> fullname:cv::COLOR_BayerRG2RGB namespace:cv classpath: classname: name:COLOR_BayerRG2RGB
parse_name: const cv.COLOR_BayerGR2RGB with ['cv'] -> fullname:cv::COLOR_BayerGR2RGB namespace:cv classpath: classname: name:COLOR_BayerGR2RGB
parse_name: const cv.COLOR_BayerBG2GRAY with ['cv'] -> fullname:cv::COLOR_BayerBG2GRAY namespace:cv classpath: classname: name:COLOR_BayerBG2GRAY
parse_name: const cv.COLOR_BayerGB2GRAY with ['cv'] -> fullname:cv::COLOR_BayerGB2GRAY namespace:cv classpath: classname: name:COLOR_BayerGB2GRAY
parse_name: const cv.COLOR_BayerRG2GRAY with ['cv'] -> fullname:cv::COLOR_BayerRG2GRAY namespace:cv classpath: classname: name:COLOR_BayerRG2GRAY
parse_name: const cv.COLOR_BayerGR2GRAY with ['cv'] -> fullname:cv::COLOR_BayerGR2GRAY namespace:cv classpath: classname: name:COLOR_BayerGR2GRAY
parse_name: const cv.COLOR_BayerBG2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerBG2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerBG2BGR_VNG
parse_name: const cv.COLOR_BayerGB2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerGB2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerGB2BGR_VNG
parse_name: const cv.COLOR_BayerRG2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerRG2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerRG2BGR_VNG
parse_name: const cv.COLOR_BayerGR2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerGR2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerGR2BGR_VNG
parse_name: const cv.COLOR_BayerBG2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerBG2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerBG2RGB_VNG
parse_name: const cv.COLOR_BayerGB2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerGB2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerGB2RGB_VNG
parse_name: const cv.COLOR_BayerRG2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerRG2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerRG2RGB_VNG
parse_name: const cv.COLOR_BayerGR2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerGR2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerGR2RGB_VNG
parse_name: const cv.COLOR_BayerBG2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerBG2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerBG2BGR_EA
parse_name: const cv.COLOR_BayerGB2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerGB2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerGB2BGR_EA
parse_name: const cv.COLOR_BayerRG2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerRG2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerRG2BGR_EA
parse_name: const cv.COLOR_BayerGR2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerGR2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerGR2BGR_EA
parse_name: const cv.COLOR_BayerBG2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerBG2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerBG2RGB_EA
parse_name: const cv.COLOR_BayerGB2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerGB2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerGB2RGB_EA
parse_name: const cv.COLOR_BayerRG2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerRG2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerRG2RGB_EA
parse_name: const cv.COLOR_BayerGR2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerGR2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerGR2RGB_EA
parse_name: const cv.COLOR_BayerBG2BGRA with ['cv'] -> fullname:cv::COLOR_BayerBG2BGRA namespace:cv classpath: classname: name:COLOR_BayerBG2BGRA
parse_name: const cv.COLOR_BayerGB2BGRA with ['cv'] -> fullname:cv::COLOR_BayerGB2BGRA namespace:cv classpath: classname: name:COLOR_BayerGB2BGRA
parse_name: const cv.COLOR_BayerRG2BGRA with ['cv'] -> fullname:cv::COLOR_BayerRG2BGRA namespace:cv classpath: classname: name:COLOR_BayerRG2BGRA
parse_name: const cv.COLOR_BayerGR2BGRA with ['cv'] -> fullname:cv::COLOR_BayerGR2BGRA namespace:cv classpath: classname: name:COLOR_BayerGR2BGRA
parse_name: const cv.COLOR_BayerBG2RGBA with ['cv'] -> fullname:cv::COLOR_BayerBG2RGBA namespace:cv classpath: classname: name:COLOR_BayerBG2RGBA
parse_name: const cv.COLOR_BayerGB2RGBA with ['cv'] -> fullname:cv::COLOR_BayerGB2RGBA namespace:cv classpath: classname: name:COLOR_BayerGB2RGBA
parse_name: const cv.COLOR_BayerRG2RGBA with ['cv'] -> fullname:cv::COLOR_BayerRG2RGBA namespace:cv classpath: classname: name:COLOR_BayerRG2RGBA
parse_name: const cv.COLOR_BayerGR2RGBA with ['cv'] -> fullname:cv::COLOR_BayerGR2RGBA namespace:cv classpath: classname: name:COLOR_BayerGR2RGBA
parse_name: const cv.COLOR_COLORCVT_MAX with ['cv'] -> fullname:cv::COLOR_COLORCVT_MAX namespace:cv classpath: classname: name:COLOR_COLORCVT_MAX
parse_name: enum cv.ColorConversionCodes with ['cv'] -> fullname:cv::ColorConversionCodes namespace:cv classpath: classname: name:ColorConversionCodes
parse_name: const cv.COLOR_BGR2BGRA with ['cv'] -> fullname:cv::COLOR_BGR2BGRA namespace:cv classpath: classname: name:COLOR_BGR2BGRA
parse_name: const cv.COLOR_RGB2RGBA with ['cv'] -> fullname:cv::COLOR_RGB2RGBA namespace:cv classpath: classname: name:COLOR_RGB2RGBA
parse_name: const cv.COLOR_BGRA2BGR with ['cv'] -> fullname:cv::COLOR_BGRA2BGR namespace:cv classpath: classname: name:COLOR_BGRA2BGR
parse_name: const cv.COLOR_RGBA2RGB with ['cv'] -> fullname:cv::COLOR_RGBA2RGB namespace:cv classpath: classname: name:COLOR_RGBA2RGB
parse_name: const cv.COLOR_BGR2RGBA with ['cv'] -> fullname:cv::COLOR_BGR2RGBA namespace:cv classpath: classname: name:COLOR_BGR2RGBA
parse_name: const cv.COLOR_RGB2BGRA with ['cv'] -> fullname:cv::COLOR_RGB2BGRA namespace:cv classpath: classname: name:COLOR_RGB2BGRA
parse_name: const cv.COLOR_RGBA2BGR with ['cv'] -> fullname:cv::COLOR_RGBA2BGR namespace:cv classpath: classname: name:COLOR_RGBA2BGR
parse_name: const cv.COLOR_BGRA2RGB with ['cv'] -> fullname:cv::COLOR_BGRA2RGB namespace:cv classpath: classname: name:COLOR_BGRA2RGB
parse_name: const cv.COLOR_BGR2RGB with ['cv'] -> fullname:cv::COLOR_BGR2RGB namespace:cv classpath: classname: name:COLOR_BGR2RGB
parse_name: const cv.COLOR_RGB2BGR with ['cv'] -> fullname:cv::COLOR_RGB2BGR namespace:cv classpath: classname: name:COLOR_RGB2BGR
parse_name: const cv.COLOR_BGRA2RGBA with ['cv'] -> fullname:cv::COLOR_BGRA2RGBA namespace:cv classpath: classname: name:COLOR_BGRA2RGBA
parse_name: const cv.COLOR_RGBA2BGRA with ['cv'] -> fullname:cv::COLOR_RGBA2BGRA namespace:cv classpath: classname: name:COLOR_RGBA2BGRA
parse_name: const cv.COLOR_BGR2GRAY with ['cv'] -> fullname:cv::COLOR_BGR2GRAY namespace:cv classpath: classname: name:COLOR_BGR2GRAY
parse_name: const cv.COLOR_RGB2GRAY with ['cv'] -> fullname:cv::COLOR_RGB2GRAY namespace:cv classpath: classname: name:COLOR_RGB2GRAY
parse_name: const cv.COLOR_GRAY2BGR with ['cv'] -> fullname:cv::COLOR_GRAY2BGR namespace:cv classpath: classname: name:COLOR_GRAY2BGR
parse_name: const cv.COLOR_GRAY2RGB with ['cv'] -> fullname:cv::COLOR_GRAY2RGB namespace:cv classpath: classname: name:COLOR_GRAY2RGB
parse_name: const cv.COLOR_GRAY2BGRA with ['cv'] -> fullname:cv::COLOR_GRAY2BGRA namespace:cv classpath: classname: name:COLOR_GRAY2BGRA
parse_name: const cv.COLOR_GRAY2RGBA with ['cv'] -> fullname:cv::COLOR_GRAY2RGBA namespace:cv classpath: classname: name:COLOR_GRAY2RGBA
parse_name: const cv.COLOR_BGRA2GRAY with ['cv'] -> fullname:cv::COLOR_BGRA2GRAY namespace:cv classpath: classname: name:COLOR_BGRA2GRAY
parse_name: const cv.COLOR_RGBA2GRAY with ['cv'] -> fullname:cv::COLOR_RGBA2GRAY namespace:cv classpath: classname: name:COLOR_RGBA2GRAY
parse_name: const cv.COLOR_BGR2BGR565 with ['cv'] -> fullname:cv::COLOR_BGR2BGR565 namespace:cv classpath: classname: name:COLOR_BGR2BGR565
parse_name: const cv.COLOR_RGB2BGR565 with ['cv'] -> fullname:cv::COLOR_RGB2BGR565 namespace:cv classpath: classname: name:COLOR_RGB2BGR565
parse_name: const cv.COLOR_BGR5652BGR with ['cv'] -> fullname:cv::COLOR_BGR5652BGR namespace:cv classpath: classname: name:COLOR_BGR5652BGR
parse_name: const cv.COLOR_BGR5652RGB with ['cv'] -> fullname:cv::COLOR_BGR5652RGB namespace:cv classpath: classname: name:COLOR_BGR5652RGB
parse_name: const cv.COLOR_BGRA2BGR565 with ['cv'] -> fullname:cv::COLOR_BGRA2BGR565 namespace:cv classpath: classname: name:COLOR_BGRA2BGR565
parse_name: const cv.COLOR_RGBA2BGR565 with ['cv'] -> fullname:cv::COLOR_RGBA2BGR565 namespace:cv classpath: classname: name:COLOR_RGBA2BGR565
parse_name: const cv.COLOR_BGR5652BGRA with ['cv'] -> fullname:cv::COLOR_BGR5652BGRA namespace:cv classpath: classname: name:COLOR_BGR5652BGRA
parse_name: const cv.COLOR_BGR5652RGBA with ['cv'] -> fullname:cv::COLOR_BGR5652RGBA namespace:cv classpath: classname: name:COLOR_BGR5652RGBA
parse_name: const cv.COLOR_GRAY2BGR565 with ['cv'] -> fullname:cv::COLOR_GRAY2BGR565 namespace:cv classpath: classname: name:COLOR_GRAY2BGR565
parse_name: const cv.COLOR_BGR5652GRAY with ['cv'] -> fullname:cv::COLOR_BGR5652GRAY namespace:cv classpath: classname: name:COLOR_BGR5652GRAY
parse_name: const cv.COLOR_BGR2BGR555 with ['cv'] -> fullname:cv::COLOR_BGR2BGR555 namespace:cv classpath: classname: name:COLOR_BGR2BGR555
parse_name: const cv.COLOR_RGB2BGR555 with ['cv'] -> fullname:cv::COLOR_RGB2BGR555 namespace:cv classpath: classname: name:COLOR_RGB2BGR555
parse_name: const cv.COLOR_BGR5552BGR with ['cv'] -> fullname:cv::COLOR_BGR5552BGR namespace:cv classpath: classname: name:COLOR_BGR5552BGR
parse_name: const cv.COLOR_BGR5552RGB with ['cv'] -> fullname:cv::COLOR_BGR5552RGB namespace:cv classpath: classname: name:COLOR_BGR5552RGB
parse_name: const cv.COLOR_BGRA2BGR555 with ['cv'] -> fullname:cv::COLOR_BGRA2BGR555 namespace:cv classpath: classname: name:COLOR_BGRA2BGR555
parse_name: const cv.COLOR_RGBA2BGR555 with ['cv'] -> fullname:cv::COLOR_RGBA2BGR555 namespace:cv classpath: classname: name:COLOR_RGBA2BGR555
parse_name: const cv.COLOR_BGR5552BGRA with ['cv'] -> fullname:cv::COLOR_BGR5552BGRA namespace:cv classpath: classname: name:COLOR_BGR5552BGRA
parse_name: const cv.COLOR_BGR5552RGBA with ['cv'] -> fullname:cv::COLOR_BGR5552RGBA namespace:cv classpath: classname: name:COLOR_BGR5552RGBA
parse_name: const cv.COLOR_GRAY2BGR555 with ['cv'] -> fullname:cv::COLOR_GRAY2BGR555 namespace:cv classpath: classname: name:COLOR_GRAY2BGR555
parse_name: const cv.COLOR_BGR5552GRAY with ['cv'] -> fullname:cv::COLOR_BGR5552GRAY namespace:cv classpath: classname: name:COLOR_BGR5552GRAY
parse_name: const cv.COLOR_BGR2XYZ with ['cv'] -> fullname:cv::COLOR_BGR2XYZ namespace:cv classpath: classname: name:COLOR_BGR2XYZ
parse_name: const cv.COLOR_RGB2XYZ with ['cv'] -> fullname:cv::COLOR_RGB2XYZ namespace:cv classpath: classname: name:COLOR_RGB2XYZ
parse_name: const cv.COLOR_XYZ2BGR with ['cv'] -> fullname:cv::COLOR_XYZ2BGR namespace:cv classpath: classname: name:COLOR_XYZ2BGR
parse_name: const cv.COLOR_XYZ2RGB with ['cv'] -> fullname:cv::COLOR_XYZ2RGB namespace:cv classpath: classname: name:COLOR_XYZ2RGB
parse_name: const cv.COLOR_BGR2YCrCb with ['cv'] -> fullname:cv::COLOR_BGR2YCrCb namespace:cv classpath: classname: name:COLOR_BGR2YCrCb
parse_name: const cv.COLOR_RGB2YCrCb with ['cv'] -> fullname:cv::COLOR_RGB2YCrCb namespace:cv classpath: classname: name:COLOR_RGB2YCrCb
parse_name: const cv.COLOR_YCrCb2BGR with ['cv'] -> fullname:cv::COLOR_YCrCb2BGR namespace:cv classpath: classname: name:COLOR_YCrCb2BGR
parse_name: const cv.COLOR_YCrCb2RGB with ['cv'] -> fullname:cv::COLOR_YCrCb2RGB namespace:cv classpath: classname: name:COLOR_YCrCb2RGB
parse_name: const cv.COLOR_BGR2HSV with ['cv'] -> fullname:cv::COLOR_BGR2HSV namespace:cv classpath: classname: name:COLOR_BGR2HSV
parse_name: const cv.COLOR_RGB2HSV with ['cv'] -> fullname:cv::COLOR_RGB2HSV namespace:cv classpath: classname: name:COLOR_RGB2HSV
parse_name: const cv.COLOR_BGR2Lab with ['cv'] -> fullname:cv::COLOR_BGR2Lab namespace:cv classpath: classname: name:COLOR_BGR2Lab
parse_name: const cv.COLOR_RGB2Lab with ['cv'] -> fullname:cv::COLOR_RGB2Lab namespace:cv classpath: classname: name:COLOR_RGB2Lab
parse_name: const cv.COLOR_BGR2Luv with ['cv'] -> fullname:cv::COLOR_BGR2Luv namespace:cv classpath: classname: name:COLOR_BGR2Luv
parse_name: const cv.COLOR_RGB2Luv with ['cv'] -> fullname:cv::COLOR_RGB2Luv namespace:cv classpath: classname: name:COLOR_RGB2Luv
parse_name: const cv.COLOR_BGR2HLS with ['cv'] -> fullname:cv::COLOR_BGR2HLS namespace:cv classpath: classname: name:COLOR_BGR2HLS
parse_name: const cv.COLOR_RGB2HLS with ['cv'] -> fullname:cv::COLOR_RGB2HLS namespace:cv classpath: classname: name:COLOR_RGB2HLS
parse_name: const cv.COLOR_HSV2BGR with ['cv'] -> fullname:cv::COLOR_HSV2BGR namespace:cv classpath: classname: name:COLOR_HSV2BGR
parse_name: const cv.COLOR_HSV2RGB with ['cv'] -> fullname:cv::COLOR_HSV2RGB namespace:cv classpath: classname: name:COLOR_HSV2RGB
parse_name: const cv.COLOR_Lab2BGR with ['cv'] -> fullname:cv::COLOR_Lab2BGR namespace:cv classpath: classname: name:COLOR_Lab2BGR
parse_name: const cv.COLOR_Lab2RGB with ['cv'] -> fullname:cv::COLOR_Lab2RGB namespace:cv classpath: classname: name:COLOR_Lab2RGB
parse_name: const cv.COLOR_Luv2BGR with ['cv'] -> fullname:cv::COLOR_Luv2BGR namespace:cv classpath: classname: name:COLOR_Luv2BGR
parse_name: const cv.COLOR_Luv2RGB with ['cv'] -> fullname:cv::COLOR_Luv2RGB namespace:cv classpath: classname: name:COLOR_Luv2RGB
parse_name: const cv.COLOR_HLS2BGR with ['cv'] -> fullname:cv::COLOR_HLS2BGR namespace:cv classpath: classname: name:COLOR_HLS2BGR
parse_name: const cv.COLOR_HLS2RGB with ['cv'] -> fullname:cv::COLOR_HLS2RGB namespace:cv classpath: classname: name:COLOR_HLS2RGB
parse_name: const cv.COLOR_BGR2HSV_FULL with ['cv'] -> fullname:cv::COLOR_BGR2HSV_FULL namespace:cv classpath: classname: name:COLOR_BGR2HSV_FULL
parse_name: const cv.COLOR_RGB2HSV_FULL with ['cv'] -> fullname:cv::COLOR_RGB2HSV_FULL namespace:cv classpath: classname: name:COLOR_RGB2HSV_FULL
parse_name: const cv.COLOR_BGR2HLS_FULL with ['cv'] -> fullname:cv::COLOR_BGR2HLS_FULL namespace:cv classpath: classname: name:COLOR_BGR2HLS_FULL
parse_name: const cv.COLOR_RGB2HLS_FULL with ['cv'] -> fullname:cv::COLOR_RGB2HLS_FULL namespace:cv classpath: classname: name:COLOR_RGB2HLS_FULL
parse_name: const cv.COLOR_HSV2BGR_FULL with ['cv'] -> fullname:cv::COLOR_HSV2BGR_FULL namespace:cv classpath: classname: name:COLOR_HSV2BGR_FULL
parse_name: const cv.COLOR_HSV2RGB_FULL with ['cv'] -> fullname:cv::COLOR_HSV2RGB_FULL namespace:cv classpath: classname: name:COLOR_HSV2RGB_FULL
parse_name: const cv.COLOR_HLS2BGR_FULL with ['cv'] -> fullname:cv::COLOR_HLS2BGR_FULL namespace:cv classpath: classname: name:COLOR_HLS2BGR_FULL
parse_name: const cv.COLOR_HLS2RGB_FULL with ['cv'] -> fullname:cv::COLOR_HLS2RGB_FULL namespace:cv classpath: classname: name:COLOR_HLS2RGB_FULL
parse_name: const cv.COLOR_LBGR2Lab with ['cv'] -> fullname:cv::COLOR_LBGR2Lab namespace:cv classpath: classname: name:COLOR_LBGR2Lab
parse_name: const cv.COLOR_LRGB2Lab with ['cv'] -> fullname:cv::COLOR_LRGB2Lab namespace:cv classpath: classname: name:COLOR_LRGB2Lab
parse_name: const cv.COLOR_LBGR2Luv with ['cv'] -> fullname:cv::COLOR_LBGR2Luv namespace:cv classpath: classname: name:COLOR_LBGR2Luv
parse_name: const cv.COLOR_LRGB2Luv with ['cv'] -> fullname:cv::COLOR_LRGB2Luv namespace:cv classpath: classname: name:COLOR_LRGB2Luv
parse_name: const cv.COLOR_Lab2LBGR with ['cv'] -> fullname:cv::COLOR_Lab2LBGR namespace:cv classpath: classname: name:COLOR_Lab2LBGR
parse_name: const cv.COLOR_Lab2LRGB with ['cv'] -> fullname:cv::COLOR_Lab2LRGB namespace:cv classpath: classname: name:COLOR_Lab2LRGB
parse_name: const cv.COLOR_Luv2LBGR with ['cv'] -> fullname:cv::COLOR_Luv2LBGR namespace:cv classpath: classname: name:COLOR_Luv2LBGR
parse_name: const cv.COLOR_Luv2LRGB with ['cv'] -> fullname:cv::COLOR_Luv2LRGB namespace:cv classpath: classname: name:COLOR_Luv2LRGB
parse_name: const cv.COLOR_BGR2YUV with ['cv'] -> fullname:cv::COLOR_BGR2YUV namespace:cv classpath: classname: name:COLOR_BGR2YUV
parse_name: const cv.COLOR_RGB2YUV with ['cv'] -> fullname:cv::COLOR_RGB2YUV namespace:cv classpath: classname: name:COLOR_RGB2YUV
parse_name: const cv.COLOR_YUV2BGR with ['cv'] -> fullname:cv::COLOR_YUV2BGR namespace:cv classpath: classname: name:COLOR_YUV2BGR
parse_name: const cv.COLOR_YUV2RGB with ['cv'] -> fullname:cv::COLOR_YUV2RGB namespace:cv classpath: classname: name:COLOR_YUV2RGB
parse_name: const cv.COLOR_YUV2RGB_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_NV12 namespace:cv classpath: classname: name:COLOR_YUV2RGB_NV12
parse_name: const cv.COLOR_YUV2BGR_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_NV12 namespace:cv classpath: classname: name:COLOR_YUV2BGR_NV12
parse_name: const cv.COLOR_YUV2RGB_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_NV21 namespace:cv classpath: classname: name:COLOR_YUV2RGB_NV21
parse_name: const cv.COLOR_YUV2BGR_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_NV21 namespace:cv classpath: classname: name:COLOR_YUV2BGR_NV21
parse_name: const cv.COLOR_YUV420sp2RGB with ['cv'] -> fullname:cv::COLOR_YUV420sp2RGB namespace:cv classpath: classname: name:COLOR_YUV420sp2RGB
parse_name: const cv.COLOR_YUV420sp2BGR with ['cv'] -> fullname:cv::COLOR_YUV420sp2BGR namespace:cv classpath: classname: name:COLOR_YUV420sp2BGR
parse_name: const cv.COLOR_YUV2RGBA_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_NV12 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_NV12
parse_name: const cv.COLOR_YUV2BGRA_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_NV12 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_NV12
parse_name: const cv.COLOR_YUV2RGBA_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_NV21 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_NV21
parse_name: const cv.COLOR_YUV2BGRA_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_NV21 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_NV21
parse_name: const cv.COLOR_YUV420sp2RGBA with ['cv'] -> fullname:cv::COLOR_YUV420sp2RGBA namespace:cv classpath: classname: name:COLOR_YUV420sp2RGBA
parse_name: const cv.COLOR_YUV420sp2BGRA with ['cv'] -> fullname:cv::COLOR_YUV420sp2BGRA namespace:cv classpath: classname: name:COLOR_YUV420sp2BGRA
parse_name: const cv.COLOR_YUV2RGB_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YV12 namespace:cv classpath: classname: name:COLOR_YUV2RGB_YV12
parse_name: const cv.COLOR_YUV2BGR_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YV12 namespace:cv classpath: classname: name:COLOR_YUV2BGR_YV12
parse_name: const cv.COLOR_YUV2RGB_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_IYUV namespace:cv classpath: classname: name:COLOR_YUV2RGB_IYUV
parse_name: const cv.COLOR_YUV2BGR_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_IYUV namespace:cv classpath: classname: name:COLOR_YUV2BGR_IYUV
parse_name: const cv.COLOR_YUV2RGB_I420 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_I420 namespace:cv classpath: classname: name:COLOR_YUV2RGB_I420
parse_name: const cv.COLOR_YUV2BGR_I420 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_I420 namespace:cv classpath: classname: name:COLOR_YUV2BGR_I420
parse_name: const cv.COLOR_YUV420p2RGB with ['cv'] -> fullname:cv::COLOR_YUV420p2RGB namespace:cv classpath: classname: name:COLOR_YUV420p2RGB
parse_name: const cv.COLOR_YUV420p2BGR with ['cv'] -> fullname:cv::COLOR_YUV420p2BGR namespace:cv classpath: classname: name:COLOR_YUV420p2BGR
parse_name: const cv.COLOR_YUV2RGBA_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YV12 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YV12
parse_name: const cv.COLOR_YUV2BGRA_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YV12 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YV12
parse_name: const cv.COLOR_YUV2RGBA_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_IYUV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_IYUV
parse_name: const cv.COLOR_YUV2BGRA_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_IYUV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_IYUV
parse_name: const cv.COLOR_YUV2RGBA_I420 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_I420 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_I420
parse_name: const cv.COLOR_YUV2BGRA_I420 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_I420 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_I420
parse_name: const cv.COLOR_YUV420p2RGBA with ['cv'] -> fullname:cv::COLOR_YUV420p2RGBA namespace:cv classpath: classname: name:COLOR_YUV420p2RGBA
parse_name: const cv.COLOR_YUV420p2BGRA with ['cv'] -> fullname:cv::COLOR_YUV420p2BGRA namespace:cv classpath: classname: name:COLOR_YUV420p2BGRA
parse_name: const cv.COLOR_YUV2GRAY_420 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_420 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_420
parse_name: const cv.COLOR_YUV2GRAY_NV21 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_NV21 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_NV21
parse_name: const cv.COLOR_YUV2GRAY_NV12 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_NV12 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_NV12
parse_name: const cv.COLOR_YUV2GRAY_YV12 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YV12 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YV12
parse_name: const cv.COLOR_YUV2GRAY_IYUV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_IYUV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_IYUV
parse_name: const cv.COLOR_YUV2GRAY_I420 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_I420 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_I420
parse_name: const cv.COLOR_YUV420sp2GRAY with ['cv'] -> fullname:cv::COLOR_YUV420sp2GRAY namespace:cv classpath: classname: name:COLOR_YUV420sp2GRAY
parse_name: const cv.COLOR_YUV420p2GRAY with ['cv'] -> fullname:cv::COLOR_YUV420p2GRAY namespace:cv classpath: classname: name:COLOR_YUV420p2GRAY
parse_name: const cv.COLOR_YUV2RGB_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2RGB_UYVY namespace:cv classpath: classname: name:COLOR_YUV2RGB_UYVY
parse_name: const cv.COLOR_YUV2BGR_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2BGR_UYVY namespace:cv classpath: classname: name:COLOR_YUV2BGR_UYVY
parse_name: const cv.COLOR_YUV2RGB_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_Y422 namespace:cv classpath: classname: name:COLOR_YUV2RGB_Y422
parse_name: const cv.COLOR_YUV2BGR_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_Y422 namespace:cv classpath: classname: name:COLOR_YUV2BGR_Y422
parse_name: const cv.COLOR_YUV2RGB_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_UYNV namespace:cv classpath: classname: name:COLOR_YUV2RGB_UYNV
parse_name: const cv.COLOR_YUV2BGR_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_UYNV namespace:cv classpath: classname: name:COLOR_YUV2BGR_UYNV
parse_name: const cv.COLOR_YUV2RGBA_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_UYVY namespace:cv classpath: classname: name:COLOR_YUV2RGBA_UYVY
parse_name: const cv.COLOR_YUV2BGRA_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_UYVY namespace:cv classpath: classname: name:COLOR_YUV2BGRA_UYVY
parse_name: const cv.COLOR_YUV2RGBA_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_Y422 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_Y422
parse_name: const cv.COLOR_YUV2BGRA_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_Y422 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_Y422
parse_name: const cv.COLOR_YUV2RGBA_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_UYNV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_UYNV
parse_name: const cv.COLOR_YUV2BGRA_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_UYNV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_UYNV
parse_name: const cv.COLOR_YUV2RGB_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2RGB_YUY2
parse_name: const cv.COLOR_YUV2BGR_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2BGR_YUY2
parse_name: const cv.COLOR_YUV2RGB_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YVYU namespace:cv classpath: classname: name:COLOR_YUV2RGB_YVYU
parse_name: const cv.COLOR_YUV2BGR_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YVYU namespace:cv classpath: classname: name:COLOR_YUV2BGR_YVYU
parse_name: const cv.COLOR_YUV2RGB_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YUYV namespace:cv classpath: classname: name:COLOR_YUV2RGB_YUYV
parse_name: const cv.COLOR_YUV2BGR_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YUYV namespace:cv classpath: classname: name:COLOR_YUV2BGR_YUYV
parse_name: const cv.COLOR_YUV2RGB_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2RGB_YUNV namespace:cv classpath: classname: name:COLOR_YUV2RGB_YUNV
parse_name: const cv.COLOR_YUV2BGR_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2BGR_YUNV namespace:cv classpath: classname: name:COLOR_YUV2BGR_YUNV
parse_name: const cv.COLOR_YUV2RGBA_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YUY2
parse_name: const cv.COLOR_YUV2BGRA_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YUY2
parse_name: const cv.COLOR_YUV2RGBA_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YVYU namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YVYU
parse_name: const cv.COLOR_YUV2BGRA_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YVYU namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YVYU
parse_name: const cv.COLOR_YUV2RGBA_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YUYV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YUYV
parse_name: const cv.COLOR_YUV2BGRA_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YUYV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YUYV
parse_name: const cv.COLOR_YUV2RGBA_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2RGBA_YUNV namespace:cv classpath: classname: name:COLOR_YUV2RGBA_YUNV
parse_name: const cv.COLOR_YUV2BGRA_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2BGRA_YUNV namespace:cv classpath: classname: name:COLOR_YUV2BGRA_YUNV
parse_name: const cv.COLOR_YUV2GRAY_UYVY with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_UYVY namespace:cv classpath: classname: name:COLOR_YUV2GRAY_UYVY
parse_name: const cv.COLOR_YUV2GRAY_YUY2 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YUY2 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YUY2
parse_name: const cv.COLOR_YUV2GRAY_Y422 with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_Y422 namespace:cv classpath: classname: name:COLOR_YUV2GRAY_Y422
parse_name: const cv.COLOR_YUV2GRAY_UYNV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_UYNV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_UYNV
parse_name: const cv.COLOR_YUV2GRAY_YVYU with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YVYU namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YVYU
parse_name: const cv.COLOR_YUV2GRAY_YUYV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YUYV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YUYV
parse_name: const cv.COLOR_YUV2GRAY_YUNV with ['cv'] -> fullname:cv::COLOR_YUV2GRAY_YUNV namespace:cv classpath: classname: name:COLOR_YUV2GRAY_YUNV
parse_name: const cv.COLOR_RGBA2mRGBA with ['cv'] -> fullname:cv::COLOR_RGBA2mRGBA namespace:cv classpath: classname: name:COLOR_RGBA2mRGBA
parse_name: const cv.COLOR_mRGBA2RGBA with ['cv'] -> fullname:cv::COLOR_mRGBA2RGBA namespace:cv classpath: classname: name:COLOR_mRGBA2RGBA
parse_name: const cv.COLOR_RGB2YUV_I420 with ['cv'] -> fullname:cv::COLOR_RGB2YUV_I420 namespace:cv classpath: classname: name:COLOR_RGB2YUV_I420
parse_name: const cv.COLOR_BGR2YUV_I420 with ['cv'] -> fullname:cv::COLOR_BGR2YUV_I420 namespace:cv classpath: classname: name:COLOR_BGR2YUV_I420
parse_name: const cv.COLOR_RGB2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_RGB2YUV_IYUV namespace:cv classpath: classname: name:COLOR_RGB2YUV_IYUV
parse_name: const cv.COLOR_BGR2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_BGR2YUV_IYUV namespace:cv classpath: classname: name:COLOR_BGR2YUV_IYUV
parse_name: const cv.COLOR_RGBA2YUV_I420 with ['cv'] -> fullname:cv::COLOR_RGBA2YUV_I420 namespace:cv classpath: classname: name:COLOR_RGBA2YUV_I420
parse_name: const cv.COLOR_BGRA2YUV_I420 with ['cv'] -> fullname:cv::COLOR_BGRA2YUV_I420 namespace:cv classpath: classname: name:COLOR_BGRA2YUV_I420
parse_name: const cv.COLOR_RGBA2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_RGBA2YUV_IYUV namespace:cv classpath: classname: name:COLOR_RGBA2YUV_IYUV
parse_name: const cv.COLOR_BGRA2YUV_IYUV with ['cv'] -> fullname:cv::COLOR_BGRA2YUV_IYUV namespace:cv classpath: classname: name:COLOR_BGRA2YUV_IYUV
parse_name: const cv.COLOR_RGB2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_RGB2YUV_YV12 namespace:cv classpath: classname: name:COLOR_RGB2YUV_YV12
parse_name: const cv.COLOR_BGR2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_BGR2YUV_YV12 namespace:cv classpath: classname: name:COLOR_BGR2YUV_YV12
parse_name: const cv.COLOR_RGBA2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_RGBA2YUV_YV12 namespace:cv classpath: classname: name:COLOR_RGBA2YUV_YV12
parse_name: const cv.COLOR_BGRA2YUV_YV12 with ['cv'] -> fullname:cv::COLOR_BGRA2YUV_YV12 namespace:cv classpath: classname: name:COLOR_BGRA2YUV_YV12
parse_name: const cv.COLOR_BayerBG2BGR with ['cv'] -> fullname:cv::COLOR_BayerBG2BGR namespace:cv classpath: classname: name:COLOR_BayerBG2BGR
parse_name: const cv.COLOR_BayerGB2BGR with ['cv'] -> fullname:cv::COLOR_BayerGB2BGR namespace:cv classpath: classname: name:COLOR_BayerGB2BGR
parse_name: const cv.COLOR_BayerRG2BGR with ['cv'] -> fullname:cv::COLOR_BayerRG2BGR namespace:cv classpath: classname: name:COLOR_BayerRG2BGR
parse_name: const cv.COLOR_BayerGR2BGR with ['cv'] -> fullname:cv::COLOR_BayerGR2BGR namespace:cv classpath: classname: name:COLOR_BayerGR2BGR
parse_name: const cv.COLOR_BayerBG2RGB with ['cv'] -> fullname:cv::COLOR_BayerBG2RGB namespace:cv classpath: classname: name:COLOR_BayerBG2RGB
parse_name: const cv.COLOR_BayerGB2RGB with ['cv'] -> fullname:cv::COLOR_BayerGB2RGB namespace:cv classpath: classname: name:COLOR_BayerGB2RGB
parse_name: const cv.COLOR_BayerRG2RGB with ['cv'] -> fullname:cv::COLOR_BayerRG2RGB namespace:cv classpath: classname: name:COLOR_BayerRG2RGB
parse_name: const cv.COLOR_BayerGR2RGB with ['cv'] -> fullname:cv::COLOR_BayerGR2RGB namespace:cv classpath: classname: name:COLOR_BayerGR2RGB
parse_name: const cv.COLOR_BayerBG2GRAY with ['cv'] -> fullname:cv::COLOR_BayerBG2GRAY namespace:cv classpath: classname: name:COLOR_BayerBG2GRAY
parse_name: const cv.COLOR_BayerGB2GRAY with ['cv'] -> fullname:cv::COLOR_BayerGB2GRAY namespace:cv classpath: classname: name:COLOR_BayerGB2GRAY
parse_name: const cv.COLOR_BayerRG2GRAY with ['cv'] -> fullname:cv::COLOR_BayerRG2GRAY namespace:cv classpath: classname: name:COLOR_BayerRG2GRAY
parse_name: const cv.COLOR_BayerGR2GRAY with ['cv'] -> fullname:cv::COLOR_BayerGR2GRAY namespace:cv classpath: classname: name:COLOR_BayerGR2GRAY
parse_name: const cv.COLOR_BayerBG2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerBG2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerBG2BGR_VNG
parse_name: const cv.COLOR_BayerGB2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerGB2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerGB2BGR_VNG
parse_name: const cv.COLOR_BayerRG2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerRG2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerRG2BGR_VNG
parse_name: const cv.COLOR_BayerGR2BGR_VNG with ['cv'] -> fullname:cv::COLOR_BayerGR2BGR_VNG namespace:cv classpath: classname: name:COLOR_BayerGR2BGR_VNG
parse_name: const cv.COLOR_BayerBG2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerBG2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerBG2RGB_VNG
parse_name: const cv.COLOR_BayerGB2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerGB2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerGB2RGB_VNG
parse_name: const cv.COLOR_BayerRG2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerRG2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerRG2RGB_VNG
parse_name: const cv.COLOR_BayerGR2RGB_VNG with ['cv'] -> fullname:cv::COLOR_BayerGR2RGB_VNG namespace:cv classpath: classname: name:COLOR_BayerGR2RGB_VNG
parse_name: const cv.COLOR_BayerBG2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerBG2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerBG2BGR_EA
parse_name: const cv.COLOR_BayerGB2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerGB2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerGB2BGR_EA
parse_name: const cv.COLOR_BayerRG2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerRG2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerRG2BGR_EA
parse_name: const cv.COLOR_BayerGR2BGR_EA with ['cv'] -> fullname:cv::COLOR_BayerGR2BGR_EA namespace:cv classpath: classname: name:COLOR_BayerGR2BGR_EA
parse_name: const cv.COLOR_BayerBG2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerBG2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerBG2RGB_EA
parse_name: const cv.COLOR_BayerGB2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerGB2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerGB2RGB_EA
parse_name: const cv.COLOR_BayerRG2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerRG2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerRG2RGB_EA
parse_name: const cv.COLOR_BayerGR2RGB_EA with ['cv'] -> fullname:cv::COLOR_BayerGR2RGB_EA namespace:cv classpath: classname: name:COLOR_BayerGR2RGB_EA
parse_name: const cv.COLOR_BayerBG2BGRA with ['cv'] -> fullname:cv::COLOR_BayerBG2BGRA namespace:cv classpath: classname: name:COLOR_BayerBG2BGRA
parse_name: const cv.COLOR_BayerGB2BGRA with ['cv'] -> fullname:cv::COLOR_BayerGB2BGRA namespace:cv classpath: classname: name:COLOR_BayerGB2BGRA
parse_name: const cv.COLOR_BayerRG2BGRA with ['cv'] -> fullname:cv::COLOR_BayerRG2BGRA namespace:cv classpath: classname: name:COLOR_BayerRG2BGRA
parse_name: const cv.COLOR_BayerGR2BGRA with ['cv'] -> fullname:cv::COLOR_BayerGR2BGRA namespace:cv classpath: classname: name:COLOR_BayerGR2BGRA
parse_name: const cv.COLOR_BayerBG2RGBA with ['cv'] -> fullname:cv::COLOR_BayerBG2RGBA namespace:cv classpath: classname: name:COLOR_BayerBG2RGBA
parse_name: const cv.COLOR_BayerGB2RGBA with ['cv'] -> fullname:cv::COLOR_BayerGB2RGBA namespace:cv classpath: classname: name:COLOR_BayerGB2RGBA
parse_name: const cv.COLOR_BayerRG2RGBA with ['cv'] -> fullname:cv::COLOR_BayerRG2RGBA namespace:cv classpath: classname: name:COLOR_BayerRG2RGBA
parse_name: const cv.COLOR_BayerGR2RGBA with ['cv'] -> fullname:cv::COLOR_BayerGR2RGBA namespace:cv classpath: classname: name:COLOR_BayerGR2RGBA
parse_name: const cv.COLOR_COLORCVT_MAX with ['cv'] -> fullname:cv::COLOR_COLORCVT_MAX namespace:cv classpath: classname: name:COLOR_COLORCVT_MAX

--- Incoming ---
[   'enum cv.RectanglesIntersectTypes',
    '',
    [],
    [   ['const cv.INTERSECT_NONE', '0', [], [], None, 'No intersection\n'],
        [   'const cv.INTERSECT_PARTIAL',
            '1',
            [],
            [],
            None,
            'There is a partial intersection\n'],
        [   'const cv.INTERSECT_FULL',
            '2',
            [],
            [],
            None,
            'One of the rectangle is fully enclosed in the other\n']],
    None,
    '@addtogroup imgproc_shape\n@{\ntypes of intersection between rectangles']
parse_name: const cv.INTERSECT_NONE with ['cv'] -> fullname:cv::INTERSECT_NONE namespace:cv classpath: classname: name:INTERSECT_NONE
parse_name: const cv.INTERSECT_PARTIAL with ['cv'] -> fullname:cv::INTERSECT_PARTIAL namespace:cv classpath: classname: name:INTERSECT_PARTIAL
parse_name: const cv.INTERSECT_FULL with ['cv'] -> fullname:cv::INTERSECT_FULL namespace:cv classpath: classname: name:INTERSECT_FULL
parse_name: enum cv.RectanglesIntersectTypes with ['cv'] -> fullname:cv::RectanglesIntersectTypes namespace:cv classpath: classname: name:RectanglesIntersectTypes
parse_name: const cv.INTERSECT_NONE with ['cv'] -> fullname:cv::INTERSECT_NONE namespace:cv classpath: classname: name:INTERSECT_NONE
parse_name: const cv.INTERSECT_PARTIAL with ['cv'] -> fullname:cv::INTERSECT_PARTIAL namespace:cv classpath: classname: name:INTERSECT_PARTIAL
parse_name: const cv.INTERSECT_FULL with ['cv'] -> fullname:cv::INTERSECT_FULL namespace:cv classpath: classname: name:INTERSECT_FULL

--- Incoming ---
[   'enum cv.LineTypes',
    '',
    [],
    [   ['const cv.FILLED', '-1', [], [], None, ''],
        ['const cv.LINE_4', '4', [], [], None, '4-connected line\n'],
        ['const cv.LINE_8', '8', [], [], None, '8-connected line\n'],
        ['const cv.LINE_AA', '16', [], [], None, 'antialiased line\n']],
    None,
    'types of line\n@ingroup imgproc_draw']
parse_name: const cv.FILLED with ['cv'] -> fullname:cv::FILLED namespace:cv classpath: classname: name:FILLED
parse_name: const cv.LINE_4 with ['cv'] -> fullname:cv::LINE_4 namespace:cv classpath: classname: name:LINE_4
parse_name: const cv.LINE_8 with ['cv'] -> fullname:cv::LINE_8 namespace:cv classpath: classname: name:LINE_8
parse_name: const cv.LINE_AA with ['cv'] -> fullname:cv::LINE_AA namespace:cv classpath: classname: name:LINE_AA
parse_name: enum cv.LineTypes with ['cv'] -> fullname:cv::LineTypes namespace:cv classpath: classname: name:LineTypes
parse_name: const cv.FILLED with ['cv'] -> fullname:cv::FILLED namespace:cv classpath: classname: name:FILLED
parse_name: const cv.LINE_4 with ['cv'] -> fullname:cv::LINE_4 namespace:cv classpath: classname: name:LINE_4
parse_name: const cv.LINE_8 with ['cv'] -> fullname:cv::LINE_8 namespace:cv classpath: classname: name:LINE_8
parse_name: const cv.LINE_AA with ['cv'] -> fullname:cv::LINE_AA namespace:cv classpath: classname: name:LINE_AA

--- Incoming ---
[   'enum cv.HersheyFonts',
    '',
    [],
    [   [   'const cv.FONT_HERSHEY_SIMPLEX',
            '0',
            [],
            [],
            None,
            'normal size sans-serif font\n'],
        [   'const cv.FONT_HERSHEY_PLAIN',
            '1',
            [],
            [],
            None,
            'small size sans-serif font\n'],
        [   'const cv.FONT_HERSHEY_DUPLEX',
            '2',
            [],
            [],
            None,
            'normal size sans-serif font (more complex than '
            'FONT_HERSHEY_SIMPLEX)\n'],
        [   'const cv.FONT_HERSHEY_COMPLEX',
            '3',
            [],
            [],
            None,
            'normal size serif font\n'],
        [   'const cv.FONT_HERSHEY_TRIPLEX',
            '4',
            [],
            [],
            None,
            'normal size serif font (more complex than '
            'FONT_HERSHEY_COMPLEX)\n'],
        [   'const cv.FONT_HERSHEY_COMPLEX_SMALL',
            '5',
            [],
            [],
            None,
            'smaller version of FONT_HERSHEY_COMPLEX\n'],
        [   'const cv.FONT_HERSHEY_SCRIPT_SIMPLEX',
            '6',
            [],
            [],
            None,
            'hand-writing style font\n'],
        [   'const cv.FONT_HERSHEY_SCRIPT_COMPLEX',
            '7',
            [],
            [],
            None,
            'more complex variant of FONT_HERSHEY_SCRIPT_SIMPLEX\n'],
        ['const cv.FONT_ITALIC', '16', [], [], None, 'flag for italic font\n']],
    None,
    'Only a subset of Hershey fonts '
    '<https://en.wikipedia.org/wiki/Hershey_fonts> are supported\n'
    '@ingroup imgproc_draw']
parse_name: const cv.FONT_HERSHEY_SIMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_SIMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SIMPLEX
parse_name: const cv.FONT_HERSHEY_PLAIN with ['cv'] -> fullname:cv::FONT_HERSHEY_PLAIN namespace:cv classpath: classname: name:FONT_HERSHEY_PLAIN
parse_name: const cv.FONT_HERSHEY_DUPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_DUPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_DUPLEX
parse_name: const cv.FONT_HERSHEY_COMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_COMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_COMPLEX
parse_name: const cv.FONT_HERSHEY_TRIPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_TRIPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_TRIPLEX
parse_name: const cv.FONT_HERSHEY_COMPLEX_SMALL with ['cv'] -> fullname:cv::FONT_HERSHEY_COMPLEX_SMALL namespace:cv classpath: classname: name:FONT_HERSHEY_COMPLEX_SMALL
parse_name: const cv.FONT_HERSHEY_SCRIPT_SIMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_SCRIPT_SIMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SCRIPT_SIMPLEX
parse_name: const cv.FONT_HERSHEY_SCRIPT_COMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_SCRIPT_COMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SCRIPT_COMPLEX
parse_name: const cv.FONT_ITALIC with ['cv'] -> fullname:cv::FONT_ITALIC namespace:cv classpath: classname: name:FONT_ITALIC
parse_name: enum cv.HersheyFonts with ['cv'] -> fullname:cv::HersheyFonts namespace:cv classpath: classname: name:HersheyFonts
parse_name: const cv.FONT_HERSHEY_SIMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_SIMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SIMPLEX
parse_name: const cv.FONT_HERSHEY_PLAIN with ['cv'] -> fullname:cv::FONT_HERSHEY_PLAIN namespace:cv classpath: classname: name:FONT_HERSHEY_PLAIN
parse_name: const cv.FONT_HERSHEY_DUPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_DUPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_DUPLEX
parse_name: const cv.FONT_HERSHEY_COMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_COMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_COMPLEX
parse_name: const cv.FONT_HERSHEY_TRIPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_TRIPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_TRIPLEX
parse_name: const cv.FONT_HERSHEY_COMPLEX_SMALL with ['cv'] -> fullname:cv::FONT_HERSHEY_COMPLEX_SMALL namespace:cv classpath: classname: name:FONT_HERSHEY_COMPLEX_SMALL
parse_name: const cv.FONT_HERSHEY_SCRIPT_SIMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_SCRIPT_SIMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SCRIPT_SIMPLEX
parse_name: const cv.FONT_HERSHEY_SCRIPT_COMPLEX with ['cv'] -> fullname:cv::FONT_HERSHEY_SCRIPT_COMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SCRIPT_COMPLEX
parse_name: const cv.FONT_ITALIC with ['cv'] -> fullname:cv::FONT_ITALIC namespace:cv classpath: classname: name:FONT_ITALIC

--- Incoming ---
[   'enum cv.MarkerTypes',
    '',
    [],
    [   [   'const cv.MARKER_CROSS',
            '0',
            [],
            [],
            None,
            'A crosshair marker shape\n'],
        [   'const cv.MARKER_TILTED_CROSS',
            '1',
            [],
            [],
            None,
            'A 45 degree tilted crosshair marker shape\n'],
        [   'const cv.MARKER_STAR',
            '2',
            [],
            [],
            None,
            'A star marker shape, combination of cross and tilted cross\n'],
        [   'const cv.MARKER_DIAMOND',
            '3',
            [],
            [],
            None,
            'A diamond marker shape\n'],
        [   'const cv.MARKER_SQUARE',
            '4',
            [],
            [],
            None,
            'A square marker shape\n'],
        [   'const cv.MARKER_TRIANGLE_UP',
            '5',
            [],
            [],
            None,
            'An upwards pointing triangle marker shape\n'],
        [   'const cv.MARKER_TRIANGLE_DOWN',
            '6',
            [],
            [],
            None,
            'A downwards pointing triangle marker shape\n']],
    None,
    'Possible set of marker types used for the cv::drawMarker function\n'
    '@ingroup imgproc_draw']
parse_name: const cv.MARKER_CROSS with ['cv'] -> fullname:cv::MARKER_CROSS namespace:cv classpath: classname: name:MARKER_CROSS
parse_name: const cv.MARKER_TILTED_CROSS with ['cv'] -> fullname:cv::MARKER_TILTED_CROSS namespace:cv classpath: classname: name:MARKER_TILTED_CROSS
parse_name: const cv.MARKER_STAR with ['cv'] -> fullname:cv::MARKER_STAR namespace:cv classpath: classname: name:MARKER_STAR
parse_name: const cv.MARKER_DIAMOND with ['cv'] -> fullname:cv::MARKER_DIAMOND namespace:cv classpath: classname: name:MARKER_DIAMOND
parse_name: const cv.MARKER_SQUARE with ['cv'] -> fullname:cv::MARKER_SQUARE namespace:cv classpath: classname: name:MARKER_SQUARE
parse_name: const cv.MARKER_TRIANGLE_UP with ['cv'] -> fullname:cv::MARKER_TRIANGLE_UP namespace:cv classpath: classname: name:MARKER_TRIANGLE_UP
parse_name: const cv.MARKER_TRIANGLE_DOWN with ['cv'] -> fullname:cv::MARKER_TRIANGLE_DOWN namespace:cv classpath: classname: name:MARKER_TRIANGLE_DOWN
parse_name: enum cv.MarkerTypes with ['cv'] -> fullname:cv::MarkerTypes namespace:cv classpath: classname: name:MarkerTypes
parse_name: const cv.MARKER_CROSS with ['cv'] -> fullname:cv::MARKER_CROSS namespace:cv classpath: classname: name:MARKER_CROSS
parse_name: const cv.MARKER_TILTED_CROSS with ['cv'] -> fullname:cv::MARKER_TILTED_CROSS namespace:cv classpath: classname: name:MARKER_TILTED_CROSS
parse_name: const cv.MARKER_STAR with ['cv'] -> fullname:cv::MARKER_STAR namespace:cv classpath: classname: name:MARKER_STAR
parse_name: const cv.MARKER_DIAMOND with ['cv'] -> fullname:cv::MARKER_DIAMOND namespace:cv classpath: classname: name:MARKER_DIAMOND
parse_name: const cv.MARKER_SQUARE with ['cv'] -> fullname:cv::MARKER_SQUARE namespace:cv classpath: classname: name:MARKER_SQUARE
parse_name: const cv.MARKER_TRIANGLE_UP with ['cv'] -> fullname:cv::MARKER_TRIANGLE_UP namespace:cv classpath: classname: name:MARKER_TRIANGLE_UP
parse_name: const cv.MARKER_TRIANGLE_DOWN with ['cv'] -> fullname:cv::MARKER_TRIANGLE_DOWN namespace:cv classpath: classname: name:MARKER_TRIANGLE_DOWN

--- Incoming ---
[   'class cv.GeneralizedHough',
    ': cv::Algorithm',
    [],
    [],
    None,
    '@brief finds arbitrary template in the grayscale image using Generalized '
    'Hough Transform']
parse_name: class cv.GeneralizedHough with ['cv'] -> fullname:cv::GeneralizedHough namespace:cv classpath: classname: name:GeneralizedHough
register class cv::GeneralizedHough (['class cv.GeneralizedHough', ': cv::Algorithm', [], [], None, '@brief finds arbitrary template in the grayscale image using Generalized Hough Transform']) impl:cv::Algorithm

--- Incoming ---
[   'cv.GeneralizedHough.setTemplate',
    'void',
    ['/A'],
    [   ['InputArray', 'templ', '', []],
        ['Point', 'templCenter', 'Point(-1, -1)', []]],
    None,
    'set template to search']
parse_name: cv.GeneralizedHough.setTemplate with ['cv'] -> fullname:cv::GeneralizedHough::setTemplate namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:setTemplate
register (method) setTemplate in cv::GeneralizedHough (trait) (cv_GeneralizedHough_setTemplate__InputArray_Point)

--- Incoming ---
[   'cv.GeneralizedHough.setTemplate',
    'void',
    ['/A'],
    [   ['InputArray', 'edges', '', []],
        ['InputArray', 'dx', '', []],
        ['InputArray', 'dy', '', []],
        ['Point', 'templCenter', 'Point(-1, -1)', []]],
    None,
    '']
parse_name: cv.GeneralizedHough.setTemplate with ['cv'] -> fullname:cv::GeneralizedHough::setTemplate namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:setTemplate
register (method) setTemplate in cv::GeneralizedHough (trait) (cv_GeneralizedHough_setTemplate__InputArray__InputArray__InputArray_Point)

--- Incoming ---
[   'cv.GeneralizedHough.detect',
    'void',
    ['/A'],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'positions', '', []],
        ['OutputArray', 'votes', 'noArray()', []]],
    None,
    'find template on image']
parse_name: cv.GeneralizedHough.detect with ['cv'] -> fullname:cv::GeneralizedHough::detect namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:detect
register (method) detect in cv::GeneralizedHough (trait) (cv_GeneralizedHough_detect__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.GeneralizedHough.detect',
    'void',
    ['/A'],
    [   ['InputArray', 'edges', '', []],
        ['InputArray', 'dx', '', []],
        ['InputArray', 'dy', '', []],
        ['OutputArray', 'positions', '', []],
        ['OutputArray', 'votes', 'noArray()', []]],
    None,
    '']
parse_name: cv.GeneralizedHough.detect with ['cv'] -> fullname:cv::GeneralizedHough::detect namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:detect
register (method) detect in cv::GeneralizedHough (trait) (cv_GeneralizedHough_detect__InputArray__InputArray__InputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.GeneralizedHough.setCannyLowThresh',
    'void',
    ['/A'],
    [['int', 'cannyLowThresh', '', []]],
    None,
    'Canny low threshold.']
parse_name: cv.GeneralizedHough.setCannyLowThresh with ['cv'] -> fullname:cv::GeneralizedHough::setCannyLowThresh namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:setCannyLowThresh
register (method) setCannyLowThresh in cv::GeneralizedHough (trait) (cv_GeneralizedHough_setCannyLowThresh_int)

--- Incoming ---
['cv.GeneralizedHough.getCannyLowThresh', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHough.getCannyLowThresh with ['cv'] -> fullname:cv::GeneralizedHough::getCannyLowThresh namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:getCannyLowThresh
register (method) getCannyLowThresh in cv::GeneralizedHough (trait) (cv_GeneralizedHough_getCannyLowThresh_const)

--- Incoming ---
[   'cv.GeneralizedHough.setCannyHighThresh',
    'void',
    ['/A'],
    [['int', 'cannyHighThresh', '', []]],
    None,
    'Canny high threshold.']
parse_name: cv.GeneralizedHough.setCannyHighThresh with ['cv'] -> fullname:cv::GeneralizedHough::setCannyHighThresh namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:setCannyHighThresh
register (method) setCannyHighThresh in cv::GeneralizedHough (trait) (cv_GeneralizedHough_setCannyHighThresh_int)

--- Incoming ---
['cv.GeneralizedHough.getCannyHighThresh', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHough.getCannyHighThresh with ['cv'] -> fullname:cv::GeneralizedHough::getCannyHighThresh namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:getCannyHighThresh
register (method) getCannyHighThresh in cv::GeneralizedHough (trait) (cv_GeneralizedHough_getCannyHighThresh_const)

--- Incoming ---
[   'cv.GeneralizedHough.setMinDist',
    'void',
    ['/A'],
    [['double', 'minDist', '', []]],
    None,
    'Minimum distance between the centers of the detected objects.']
parse_name: cv.GeneralizedHough.setMinDist with ['cv'] -> fullname:cv::GeneralizedHough::setMinDist namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:setMinDist
register (method) setMinDist in cv::GeneralizedHough (trait) (cv_GeneralizedHough_setMinDist_double)

--- Incoming ---
['cv.GeneralizedHough.getMinDist', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHough.getMinDist with ['cv'] -> fullname:cv::GeneralizedHough::getMinDist namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:getMinDist
register (method) getMinDist in cv::GeneralizedHough (trait) (cv_GeneralizedHough_getMinDist_const)

--- Incoming ---
[   'cv.GeneralizedHough.setDp',
    'void',
    ['/A'],
    [['double', 'dp', '', []]],
    None,
    'Inverse ratio of the accumulator resolution to the image resolution.']
parse_name: cv.GeneralizedHough.setDp with ['cv'] -> fullname:cv::GeneralizedHough::setDp namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:setDp
register (method) setDp in cv::GeneralizedHough (trait) (cv_GeneralizedHough_setDp_double)

--- Incoming ---
['cv.GeneralizedHough.getDp', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHough.getDp with ['cv'] -> fullname:cv::GeneralizedHough::getDp namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:getDp
register (method) getDp in cv::GeneralizedHough (trait) (cv_GeneralizedHough_getDp_const)

--- Incoming ---
[   'cv.GeneralizedHough.setMaxBufferSize',
    'void',
    ['/A'],
    [['int', 'maxBufferSize', '', []]],
    None,
    'Maximal size of inner buffers.']
parse_name: cv.GeneralizedHough.setMaxBufferSize with ['cv'] -> fullname:cv::GeneralizedHough::setMaxBufferSize namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:setMaxBufferSize
register (method) setMaxBufferSize in cv::GeneralizedHough (trait) (cv_GeneralizedHough_setMaxBufferSize_int)

--- Incoming ---
['cv.GeneralizedHough.getMaxBufferSize', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHough.getMaxBufferSize with ['cv'] -> fullname:cv::GeneralizedHough::getMaxBufferSize namespace:cv classpath:GeneralizedHough classname:GeneralizedHough name:getMaxBufferSize
register (method) getMaxBufferSize in cv::GeneralizedHough (trait) (cv_GeneralizedHough_getMaxBufferSize_const)

--- Incoming ---
[   'class cv.GeneralizedHoughBallard',
    ': cv::GeneralizedHough',
    [],
    [],
    None,
    '@brief finds arbitrary template in the grayscale image using Generalized '
    'Hough Transform\n'
    '\n'
    'Detects position only without translation and rotation @cite Ballard1981 '
    '.']
parse_name: class cv.GeneralizedHoughBallard with ['cv'] -> fullname:cv::GeneralizedHoughBallard namespace:cv classpath: classname: name:GeneralizedHoughBallard
register class cv::GeneralizedHoughBallard (['class cv.GeneralizedHoughBallard', ': cv::GeneralizedHough', [], [], None, '@brief finds arbitrary template in the grayscale image using Generalized Hough Transform\n\nDetects position only without translation and rotation @cite Ballard1981 .']) impl:cv::GeneralizedHough

--- Incoming ---
[   'cv.GeneralizedHoughBallard.setLevels',
    'void',
    ['/A'],
    [['int', 'levels', '', []]],
    None,
    'R-Table levels.']
parse_name: cv.GeneralizedHoughBallard.setLevels with ['cv'] -> fullname:cv::GeneralizedHoughBallard::setLevels namespace:cv classpath:GeneralizedHoughBallard classname:GeneralizedHoughBallard name:setLevels
register (method) setLevels in cv::GeneralizedHoughBallard (trait) (cv_GeneralizedHoughBallard_setLevels_int)

--- Incoming ---
['cv.GeneralizedHoughBallard.getLevels', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughBallard.getLevels with ['cv'] -> fullname:cv::GeneralizedHoughBallard::getLevels namespace:cv classpath:GeneralizedHoughBallard classname:GeneralizedHoughBallard name:getLevels
register (method) getLevels in cv::GeneralizedHoughBallard (trait) (cv_GeneralizedHoughBallard_getLevels_const)

--- Incoming ---
[   'cv.GeneralizedHoughBallard.setVotesThreshold',
    'void',
    ['/A'],
    [['int', 'votesThreshold', '', []]],
    None,
    'The accumulator threshold for the template centers at the detection '
    'stage. The smaller it is, the more false positions may be detected.']
parse_name: cv.GeneralizedHoughBallard.setVotesThreshold with ['cv'] -> fullname:cv::GeneralizedHoughBallard::setVotesThreshold namespace:cv classpath:GeneralizedHoughBallard classname:GeneralizedHoughBallard name:setVotesThreshold
register (method) setVotesThreshold in cv::GeneralizedHoughBallard (trait) (cv_GeneralizedHoughBallard_setVotesThreshold_int)

--- Incoming ---
[   'cv.GeneralizedHoughBallard.getVotesThreshold',
    'int',
    ['/A', '/C'],
    [],
    None,
    '']
parse_name: cv.GeneralizedHoughBallard.getVotesThreshold with ['cv'] -> fullname:cv::GeneralizedHoughBallard::getVotesThreshold namespace:cv classpath:GeneralizedHoughBallard classname:GeneralizedHoughBallard name:getVotesThreshold
register (method) getVotesThreshold in cv::GeneralizedHoughBallard (trait) (cv_GeneralizedHoughBallard_getVotesThreshold_const)

--- Incoming ---
[   'class cv.GeneralizedHoughGuil',
    ': cv::GeneralizedHough',
    [],
    [],
    None,
    '@brief finds arbitrary template in the grayscale image using Generalized '
    'Hough Transform\n'
    '\n'
    'Detects position, translation and rotation @cite Guil1999 .']
parse_name: class cv.GeneralizedHoughGuil with ['cv'] -> fullname:cv::GeneralizedHoughGuil namespace:cv classpath: classname: name:GeneralizedHoughGuil
register class cv::GeneralizedHoughGuil (['class cv.GeneralizedHoughGuil', ': cv::GeneralizedHough', [], [], None, '@brief finds arbitrary template in the grayscale image using Generalized Hough Transform\n\nDetects position, translation and rotation @cite Guil1999 .']) impl:cv::GeneralizedHough

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setXi',
    'void',
    ['/A'],
    [['double', 'xi', '', []]],
    None,
    'Angle difference in degrees between two points in feature.']
parse_name: cv.GeneralizedHoughGuil.setXi with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setXi namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setXi
register (method) setXi in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setXi_double)

--- Incoming ---
['cv.GeneralizedHoughGuil.getXi', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getXi with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getXi namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getXi
register (method) getXi in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getXi_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setLevels',
    'void',
    ['/A'],
    [['int', 'levels', '', []]],
    None,
    'Feature table levels.']
parse_name: cv.GeneralizedHoughGuil.setLevels with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setLevels namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setLevels
register (method) setLevels in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setLevels_int)

--- Incoming ---
['cv.GeneralizedHoughGuil.getLevels', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getLevels with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getLevels namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getLevels
register (method) getLevels in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getLevels_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setAngleEpsilon',
    'void',
    ['/A'],
    [['double', 'angleEpsilon', '', []]],
    None,
    'Maximal difference between angles that treated as equal.']
parse_name: cv.GeneralizedHoughGuil.setAngleEpsilon with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setAngleEpsilon namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setAngleEpsilon
register (method) setAngleEpsilon in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setAngleEpsilon_double)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getAngleEpsilon',
    'double',
    ['/A', '/C'],
    [],
    None,
    '']
parse_name: cv.GeneralizedHoughGuil.getAngleEpsilon with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getAngleEpsilon namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getAngleEpsilon
register (method) getAngleEpsilon in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getAngleEpsilon_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMinAngle',
    'void',
    ['/A'],
    [['double', 'minAngle', '', []]],
    None,
    'Minimal rotation angle to detect in degrees.']
parse_name: cv.GeneralizedHoughGuil.setMinAngle with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setMinAngle namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setMinAngle
register (method) setMinAngle in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setMinAngle_double)

--- Incoming ---
['cv.GeneralizedHoughGuil.getMinAngle', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getMinAngle with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getMinAngle namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getMinAngle
register (method) getMinAngle in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getMinAngle_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMaxAngle',
    'void',
    ['/A'],
    [['double', 'maxAngle', '', []]],
    None,
    'Maximal rotation angle to detect in degrees.']
parse_name: cv.GeneralizedHoughGuil.setMaxAngle with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setMaxAngle namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setMaxAngle
register (method) setMaxAngle in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setMaxAngle_double)

--- Incoming ---
['cv.GeneralizedHoughGuil.getMaxAngle', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getMaxAngle with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getMaxAngle namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getMaxAngle
register (method) getMaxAngle in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getMaxAngle_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setAngleStep',
    'void',
    ['/A'],
    [['double', 'angleStep', '', []]],
    None,
    'Angle step in degrees.']
parse_name: cv.GeneralizedHoughGuil.setAngleStep with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setAngleStep namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setAngleStep
register (method) setAngleStep in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setAngleStep_double)

--- Incoming ---
['cv.GeneralizedHoughGuil.getAngleStep', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getAngleStep with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getAngleStep namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getAngleStep
register (method) getAngleStep in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getAngleStep_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setAngleThresh',
    'void',
    ['/A'],
    [['int', 'angleThresh', '', []]],
    None,
    'Angle votes threshold.']
parse_name: cv.GeneralizedHoughGuil.setAngleThresh with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setAngleThresh namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setAngleThresh
register (method) setAngleThresh in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setAngleThresh_int)

--- Incoming ---
['cv.GeneralizedHoughGuil.getAngleThresh', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getAngleThresh with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getAngleThresh namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getAngleThresh
register (method) getAngleThresh in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getAngleThresh_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMinScale',
    'void',
    ['/A'],
    [['double', 'minScale', '', []]],
    None,
    'Minimal scale to detect.']
parse_name: cv.GeneralizedHoughGuil.setMinScale with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setMinScale namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setMinScale
register (method) setMinScale in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setMinScale_double)

--- Incoming ---
['cv.GeneralizedHoughGuil.getMinScale', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getMinScale with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getMinScale namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getMinScale
register (method) getMinScale in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getMinScale_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMaxScale',
    'void',
    ['/A'],
    [['double', 'maxScale', '', []]],
    None,
    'Maximal scale to detect.']
parse_name: cv.GeneralizedHoughGuil.setMaxScale with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setMaxScale namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setMaxScale
register (method) setMaxScale in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setMaxScale_double)

--- Incoming ---
['cv.GeneralizedHoughGuil.getMaxScale', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getMaxScale with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getMaxScale namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getMaxScale
register (method) getMaxScale in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getMaxScale_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setScaleStep',
    'void',
    ['/A'],
    [['double', 'scaleStep', '', []]],
    None,
    'Scale step.']
parse_name: cv.GeneralizedHoughGuil.setScaleStep with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setScaleStep namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setScaleStep
register (method) setScaleStep in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setScaleStep_double)

--- Incoming ---
['cv.GeneralizedHoughGuil.getScaleStep', 'double', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getScaleStep with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getScaleStep namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getScaleStep
register (method) getScaleStep in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getScaleStep_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setScaleThresh',
    'void',
    ['/A'],
    [['int', 'scaleThresh', '', []]],
    None,
    'Scale votes threshold.']
parse_name: cv.GeneralizedHoughGuil.setScaleThresh with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setScaleThresh namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setScaleThresh
register (method) setScaleThresh in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setScaleThresh_int)

--- Incoming ---
['cv.GeneralizedHoughGuil.getScaleThresh', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getScaleThresh with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getScaleThresh namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getScaleThresh
register (method) getScaleThresh in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getScaleThresh_const)

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setPosThresh',
    'void',
    ['/A'],
    [['int', 'posThresh', '', []]],
    None,
    'Position votes threshold.']
parse_name: cv.GeneralizedHoughGuil.setPosThresh with ['cv'] -> fullname:cv::GeneralizedHoughGuil::setPosThresh namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:setPosThresh
register (method) setPosThresh in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_setPosThresh_int)

--- Incoming ---
['cv.GeneralizedHoughGuil.getPosThresh', 'int', ['/A', '/C'], [], None, '']
parse_name: cv.GeneralizedHoughGuil.getPosThresh with ['cv'] -> fullname:cv::GeneralizedHoughGuil::getPosThresh namespace:cv classpath:GeneralizedHoughGuil classname:GeneralizedHoughGuil name:getPosThresh
register (method) getPosThresh in cv::GeneralizedHoughGuil (trait) (cv_GeneralizedHoughGuil_getPosThresh_const)

--- Incoming ---
[   'class cv.CLAHE',
    ': cv::Algorithm',
    [],
    [],
    None,
    '@brief Base class for Contrast Limited Adaptive Histogram Equalization.']
parse_name: class cv.CLAHE with ['cv'] -> fullname:cv::CLAHE namespace:cv classpath: classname: name:CLAHE
register class cv::CLAHE (['class cv.CLAHE', ': cv::Algorithm', [], [], None, '@brief Base class for Contrast Limited Adaptive Histogram Equalization.']) impl:cv::Algorithm

--- Incoming ---
[   'cv.CLAHE.apply',
    'void',
    ['/A'],
    [['InputArray', 'src', '', []], ['OutputArray', 'dst', '', []]],
    None,
    '@brief Equalizes the histogram of a grayscale image using Contrast '
    'Limited Adaptive Histogram Equalization.\n'
    '\n'
    '@param src Source image of type CV_8UC1 or CV_16UC1.\n'
    '@param dst Destination image.']
parse_name: cv.CLAHE.apply with ['cv'] -> fullname:cv::CLAHE::apply namespace:cv classpath:CLAHE classname:CLAHE name:apply
register (method) apply in cv::CLAHE (trait) (cv_CLAHE_apply__InputArray__OutputArray)

--- Incoming ---
[   'cv.CLAHE.setClipLimit',
    'void',
    ['/A'],
    [['double', 'clipLimit', '', []]],
    None,
    '@brief Sets threshold for contrast limiting.\n'
    '\n'
    '@param clipLimit threshold value.']
parse_name: cv.CLAHE.setClipLimit with ['cv'] -> fullname:cv::CLAHE::setClipLimit namespace:cv classpath:CLAHE classname:CLAHE name:setClipLimit
register (method) setClipLimit in cv::CLAHE (trait) (cv_CLAHE_setClipLimit_double)

--- Incoming ---
[   'cv.CLAHE.getClipLimit',
    'double',
    ['/A', '/C'],
    [],
    None,
    'Returns threshold value for contrast limiting.']
parse_name: cv.CLAHE.getClipLimit with ['cv'] -> fullname:cv::CLAHE::getClipLimit namespace:cv classpath:CLAHE classname:CLAHE name:getClipLimit
register (method) getClipLimit in cv::CLAHE (trait) (cv_CLAHE_getClipLimit_const)

--- Incoming ---
[   'cv.CLAHE.setTilesGridSize',
    'void',
    ['/A'],
    [['Size', 'tileGridSize', '', []]],
    None,
    '@brief Sets size of grid for histogram equalization. Input image will be '
    'divided into\n'
    'equally sized rectangular tiles.\n'
    '\n'
    '@param tileGridSize defines the number of tiles in row and column.']
parse_name: cv.CLAHE.setTilesGridSize with ['cv'] -> fullname:cv::CLAHE::setTilesGridSize namespace:cv classpath:CLAHE classname:CLAHE name:setTilesGridSize
register (method) setTilesGridSize in cv::CLAHE (trait) (cv_CLAHE_setTilesGridSize_Size)

--- Incoming ---
[   'cv.CLAHE.getTilesGridSize',
    'Size',
    ['/A', '/C'],
    [],
    None,
    '@brief Returns Size defines the number of tiles in row and column.']
parse_name: cv.CLAHE.getTilesGridSize with ['cv'] -> fullname:cv::CLAHE::getTilesGridSize namespace:cv classpath:CLAHE classname:CLAHE name:getTilesGridSize
register (method) getTilesGridSize in cv::CLAHE (trait) (cv_CLAHE_getTilesGridSize_const)

--- Incoming ---
['cv.CLAHE.collectGarbage', 'void', ['/A'], [], None, '']
parse_name: cv.CLAHE.collectGarbage with ['cv'] -> fullname:cv::CLAHE::collectGarbage namespace:cv classpath:CLAHE classname:CLAHE name:collectGarbage
register (method) collectGarbage in cv::CLAHE (trait) (cv_CLAHE_collectGarbage)

--- Incoming ---
[   'class cv.Subdiv2D',
    '',
    [],
    [],
    None,
    '@} imgproc_hist\n@addtogroup imgproc_subdiv2d\n@{']
parse_name: class cv.Subdiv2D with ['cv'] -> fullname:cv::Subdiv2D namespace:cv classpath: classname: name:Subdiv2D
register class cv::Subdiv2D (['class cv.Subdiv2D', '', [], [], None, '@} imgproc_hist\n@addtogroup imgproc_subdiv2d\n@{'])

--- Incoming ---
[   'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   [   'const cv.Subdiv2D.PTLOC_ERROR',
            '-2',
            [],
            [],
            None,
            'Point location error\n'],
        [   'const cv.Subdiv2D.PTLOC_OUTSIDE_RECT',
            '-1',
            [],
            [],
            None,
            'Point outside the subdivision bounding rect\n'],
        [   'const cv.Subdiv2D.PTLOC_INSIDE',
            '0',
            [],
            [],
            None,
            'Point inside some facet\n'],
        [   'const cv.Subdiv2D.PTLOC_VERTEX',
            '1',
            [],
            [],
            None,
            'Point coincides with one of the subdivision vertices\n'],
        [   'const cv.Subdiv2D.PTLOC_ON_EDGE',
            '2',
            [],
            [],
            None,
            'Point on some edge\n']],
    None,
    'Subdiv2D point location cases']
parse_name: const cv.Subdiv2D.PTLOC_ERROR with ['cv'] -> fullname:cv::Subdiv2D::PTLOC_ERROR namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PTLOC_ERROR
parse_name: const cv.Subdiv2D.PTLOC_OUTSIDE_RECT with ['cv'] -> fullname:cv::Subdiv2D::PTLOC_OUTSIDE_RECT namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PTLOC_OUTSIDE_RECT
parse_name: const cv.Subdiv2D.PTLOC_INSIDE with ['cv'] -> fullname:cv::Subdiv2D::PTLOC_INSIDE namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PTLOC_INSIDE
parse_name: const cv.Subdiv2D.PTLOC_VERTEX with ['cv'] -> fullname:cv::Subdiv2D::PTLOC_VERTEX namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PTLOC_VERTEX
parse_name: const cv.Subdiv2D.PTLOC_ON_EDGE with ['cv'] -> fullname:cv::Subdiv2D::PTLOC_ON_EDGE namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PTLOC_ON_EDGE

--- Incoming ---
[   'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   ['const cv.Subdiv2D.NEXT_AROUND_ORG', '0x00', [], [], None, ''],
        ['const cv.Subdiv2D.NEXT_AROUND_DST', '0x22', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_ORG', '0x11', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_DST', '0x33', [], [], None, ''],
        ['const cv.Subdiv2D.NEXT_AROUND_LEFT', '0x13', [], [], None, ''],
        ['const cv.Subdiv2D.NEXT_AROUND_RIGHT', '0x31', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_LEFT', '0x20', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_RIGHT', '0x02', [], [], None, '']],
    None,
    'Subdiv2D edge type navigation (see: getEdge())']
parse_name: const cv.Subdiv2D.NEXT_AROUND_ORG with ['cv'] -> fullname:cv::Subdiv2D::NEXT_AROUND_ORG namespace:cv classpath:Subdiv2D classname:Subdiv2D name:NEXT_AROUND_ORG
parse_name: const cv.Subdiv2D.NEXT_AROUND_DST with ['cv'] -> fullname:cv::Subdiv2D::NEXT_AROUND_DST namespace:cv classpath:Subdiv2D classname:Subdiv2D name:NEXT_AROUND_DST
parse_name: const cv.Subdiv2D.PREV_AROUND_ORG with ['cv'] -> fullname:cv::Subdiv2D::PREV_AROUND_ORG namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PREV_AROUND_ORG
parse_name: const cv.Subdiv2D.PREV_AROUND_DST with ['cv'] -> fullname:cv::Subdiv2D::PREV_AROUND_DST namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PREV_AROUND_DST
parse_name: const cv.Subdiv2D.NEXT_AROUND_LEFT with ['cv'] -> fullname:cv::Subdiv2D::NEXT_AROUND_LEFT namespace:cv classpath:Subdiv2D classname:Subdiv2D name:NEXT_AROUND_LEFT
parse_name: const cv.Subdiv2D.NEXT_AROUND_RIGHT with ['cv'] -> fullname:cv::Subdiv2D::NEXT_AROUND_RIGHT namespace:cv classpath:Subdiv2D classname:Subdiv2D name:NEXT_AROUND_RIGHT
parse_name: const cv.Subdiv2D.PREV_AROUND_LEFT with ['cv'] -> fullname:cv::Subdiv2D::PREV_AROUND_LEFT namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PREV_AROUND_LEFT
parse_name: const cv.Subdiv2D.PREV_AROUND_RIGHT with ['cv'] -> fullname:cv::Subdiv2D::PREV_AROUND_RIGHT namespace:cv classpath:Subdiv2D classname:Subdiv2D name:PREV_AROUND_RIGHT

--- Incoming ---
[   'cv.Subdiv2D.Subdiv2D',
    'S',
    [],
    [],
    None,
    'creates an empty Subdiv2D object.\n'
    'To create a new empty Delaunay subdivision you need to use the '
    '#initDelaunay function.']
parse_name: cv.Subdiv2D.Subdiv2D with ['cv'] -> fullname:cv::Subdiv2D::Subdiv2D namespace:cv classpath:Subdiv2D classname:Subdiv2D name:Subdiv2D
register (constructor) default in cv::Subdiv2D (cv_Subdiv2D_Subdiv2D)

--- Incoming ---
[   'cv.Subdiv2D.Subdiv2D',
    'S',
    [],
    [['Rect', 'rect', '', []]],
    None,
    '@overload\n'
    '\n'
    '@param rect Rectangle that includes all of the 2D points that are to be '
    'added to the subdivision.\n'
    '\n'
    'The function creates an empty Delaunay subdivision where 2D points can be '
    'added using the function\n'
    'insert() . All of the points to be added must be within the specified '
    'rectangle, otherwise a runtime\n'
    'error is raised.']
parse_name: cv.Subdiv2D.Subdiv2D with ['cv'] -> fullname:cv::Subdiv2D::Subdiv2D namespace:cv classpath:Subdiv2D classname:Subdiv2D name:Subdiv2D
register (constructor) new in cv::Subdiv2D (cv_Subdiv2D_Subdiv2D_Rect)

--- Incoming ---
[   'cv.Subdiv2D.initDelaunay',
    'void',
    [],
    [['Rect', 'rect', '', []]],
    None,
    '@brief Creates a new empty Delaunay subdivision\n'
    '\n'
    '@param rect Rectangle that includes all of the 2D points that are to be '
    'added to the subdivision.']
parse_name: cv.Subdiv2D.initDelaunay with ['cv'] -> fullname:cv::Subdiv2D::initDelaunay namespace:cv classpath:Subdiv2D classname:Subdiv2D name:initDelaunay
register (method) initDelaunay in cv::Subdiv2D (cv_Subdiv2D_initDelaunay_Rect)

--- Incoming ---
[   'cv.Subdiv2D.insert',
    'int',
    [],
    [['Point2f', 'pt', '', []]],
    None,
    '@brief Insert a single point into a Delaunay triangulation.\n'
    '\n'
    '@param pt Point to insert.\n'
    '\n'
    'The function inserts a single point into a subdivision and modifies the '
    'subdivision topology\n'
    'appropriately. If a point with the same coordinates exists already, no '
    'new point is added.\n'
    '@returns the ID of the point.\n'
    '\n'
    '@note If the point is outside of the triangulation specified rect a '
    'runtime error is raised.']
parse_name: cv.Subdiv2D.insert with ['cv'] -> fullname:cv::Subdiv2D::insert namespace:cv classpath:Subdiv2D classname:Subdiv2D name:insert
register (method) insert in cv::Subdiv2D (cv_Subdiv2D_insert_Point2f)

--- Incoming ---
[   'cv.Subdiv2D.insert',
    'void',
    [],
    [['const std::vector<Point2f>&', 'ptvec', '', []]],
    None,
    '@brief Insert multiple points into a Delaunay triangulation.\n'
    '\n'
    '@param ptvec Points to insert.\n'
    '\n'
    'The function inserts a vector of points into a subdivision and modifies '
    'the subdivision topology\n'
    'appropriately.']
parse_name: cv.Subdiv2D.insert with ['cv'] -> fullname:cv::Subdiv2D::insert namespace:cv classpath:Subdiv2D classname:Subdiv2D name:insert
register (method) insert in cv::Subdiv2D (cv_Subdiv2D_insert_VectorOfPoint2f)

--- Incoming ---
[   'cv.Subdiv2D.locate',
    'int',
    [],
    [   ['Point2f', 'pt', '', []],
        ['int&', 'edge', '', []],
        ['int&', 'vertex', '', []]],
    None,
    '@brief Returns the location of a point within a Delaunay triangulation.\n'
    '\n'
    '@param pt Point to locate.\n'
    '@param edge Output edge that the point belongs to or is located to the '
    'right of it.\n'
    '@param vertex Optional output vertex the input point coincides with.\n'
    '\n'
    'The function locates the input point within the subdivision and gives one '
    'of the triangle edges\n'
    'or vertices.\n'
    '\n'
    '@returns an integer which specify one of the following five cases for '
    'point location:\n'
    '-  The point falls into some facet. The function returns #PTLOC_INSIDE '
    'and edge will contain one of\n'
    'edges of the facet.\n'
    '-  The point falls onto the edge. The function returns #PTLOC_ON_EDGE and '
    'edge will contain this edge.\n'
    '-  The point coincides with one of the subdivision vertices. The function '
    'returns #PTLOC_VERTEX and\n'
    'vertex will contain a pointer to the vertex.\n'
    '-  The point is outside the subdivision reference rectangle. The function '
    'returns #PTLOC_OUTSIDE_RECT\n'
    'and no pointers are filled.\n'
    '-  One of input arguments is invalid. A runtime error is raised or, if '
    'silent or "parent" error\n'
    'processing mode is selected, #PTLOC_ERROR is returned.']
parse_name: cv.Subdiv2D.locate with ['cv'] -> fullname:cv::Subdiv2D::locate namespace:cv classpath:Subdiv2D classname:Subdiv2D name:locate
register (method) locate in cv::Subdiv2D (cv_Subdiv2D_locate_Point2f_int_int)

--- Incoming ---
[   'cv.Subdiv2D.findNearest',
    'int',
    [],
    [['Point2f', 'pt', '', []], ['Point2f*', 'nearestPt', '0', []]],
    None,
    '@brief Finds the subdivision vertex closest to the given point.\n'
    '\n'
    '@param pt Input point.\n'
    '@param nearestPt Output subdivision vertex point.\n'
    '\n'
    'The function is another function that locates the input point within the '
    'subdivision. It finds the\n'
    'subdivision vertex that is the closest to the input point. It is not '
    'necessarily one of vertices\n'
    'of the facet containing the input point, though the facet (located using '
    'locate() ) is used as a\n'
    'starting point.\n'
    '\n'
    '@returns vertex ID.']
parse_name: cv.Subdiv2D.findNearest with ['cv'] -> fullname:cv::Subdiv2D::findNearest namespace:cv classpath:Subdiv2D classname:Subdiv2D name:findNearest
register (method) findNearest in cv::Subdiv2D (cv_Subdiv2D_findNearest_Point2f_Point2f_X)

--- Incoming ---
[   'cv.Subdiv2D.getEdgeList',
    'void',
    ['/C'],
    [['std::vector<Vec4f>&', 'edgeList', '', []]],
    None,
    '@brief Returns a list of all edges.\n'
    '\n'
    '@param edgeList Output vector.\n'
    '\n'
    'The function gives each edge as a 4 numbers vector, where each two are '
    'one of the edge\n'
    'vertices. i.e. org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3].']
parse_name: cv.Subdiv2D.getEdgeList with ['cv'] -> fullname:cv::Subdiv2D::getEdgeList namespace:cv classpath:Subdiv2D classname:Subdiv2D name:getEdgeList
register (method) getEdgeList in cv::Subdiv2D (cv_Subdiv2D_getEdgeList_const_VectorOfVec4f)

--- Incoming ---
[   'cv.Subdiv2D.getLeadingEdgeList',
    'void',
    ['/C'],
    [['std::vector<int>&', 'leadingEdgeList', '', []]],
    None,
    '@brief Returns a list of the leading edge ID connected to each triangle.\n'
    '\n'
    '@param leadingEdgeList Output vector.\n'
    '\n'
    'The function gives one edge ID for each triangle.']
parse_name: cv.Subdiv2D.getLeadingEdgeList with ['cv'] -> fullname:cv::Subdiv2D::getLeadingEdgeList namespace:cv classpath:Subdiv2D classname:Subdiv2D name:getLeadingEdgeList
register (method) getLeadingEdgeList in cv::Subdiv2D (cv_Subdiv2D_getLeadingEdgeList_const_VectorOfint)

--- Incoming ---
[   'cv.Subdiv2D.getTriangleList',
    'void',
    ['/C'],
    [['std::vector<Vec6f>&', 'triangleList', '', []]],
    None,
    '@brief Returns a list of all triangles.\n'
    '\n'
    '@param triangleList Output vector.\n'
    '\n'
    'The function gives each triangle as a 6 numbers vector, where each two '
    'are one of the triangle\n'
    'vertices. i.e. p1_x = v[0], p1_y = v[1], p2_x = v[2], p2_y = v[3], p3_x = '
    'v[4], p3_y = v[5].']
parse_name: cv.Subdiv2D.getTriangleList with ['cv'] -> fullname:cv::Subdiv2D::getTriangleList namespace:cv classpath:Subdiv2D classname:Subdiv2D name:getTriangleList
register (method) getTriangleList in cv::Subdiv2D (cv_Subdiv2D_getTriangleList_const_VectorOfVec6f)

--- Incoming ---
[   'cv.Subdiv2D.getVoronoiFacetList',
    'void',
    [],
    [   ['const std::vector<int>&', 'idx', '', []],
        ['std::vector<std::vector<Point2f> >&', 'facetList', '', []],
        ['std::vector<Point2f>&', 'facetCenters', '', []]],
    None,
    '@brief Returns a list of all Voroni facets.\n'
    '\n'
    '@param idx Vector of vertices IDs to consider. For all vertices you can '
    'pass empty vector.\n'
    '@param facetList Output vector of the Voroni facets.\n'
    '@param facetCenters Output vector of the Voroni facets center points.']
parse_name: cv.Subdiv2D.getVoronoiFacetList with ['cv'] -> fullname:cv::Subdiv2D::getVoronoiFacetList namespace:cv classpath:Subdiv2D classname:Subdiv2D name:getVoronoiFacetList
register (method) getVoronoiFacetList in cv::Subdiv2D (cv_Subdiv2D_getVoronoiFacetList_VectorOfint_VectorOfVectorOfPoint2f_VectorOfPoint2f)

--- Incoming ---
[   'cv.Subdiv2D.getVertex',
    'Point2f',
    ['/C'],
    [['int', 'vertex', '', []], ['int*', 'firstEdge', '0', []]],
    None,
    '@brief Returns vertex location from vertex ID.\n'
    '\n'
    '@param vertex vertex ID.\n'
    '@param firstEdge Optional. The first edge ID which is connected to the '
    'vertex.\n'
    '@returns vertex (x,y)']
parse_name: cv.Subdiv2D.getVertex with ['cv'] -> fullname:cv::Subdiv2D::getVertex namespace:cv classpath:Subdiv2D classname:Subdiv2D name:getVertex
register (method) getVertex in cv::Subdiv2D (cv_Subdiv2D_getVertex_const_int_int_X)

--- Incoming ---
[   'cv.Subdiv2D.getEdge',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['int', 'nextEdgeType', '', []]],
    None,
    '@brief Returns one of the edges related to the given edge.\n'
    '\n'
    '@param edge Subdivision edge ID.\n'
    '@param nextEdgeType Parameter specifying which of the related edges to '
    'return.\n'
    'The following values are possible:\n'
    '-   NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture '
    'below if e is the input edge)\n'
    '-   NEXT_AROUND_DST next around the edge vertex ( eDnext )\n'
    '-   PREV_AROUND_ORG previous around the edge origin (reversed eRnext )\n'
    '-   PREV_AROUND_DST previous around the edge destination (reversed eLnext '
    ')\n'
    '-   NEXT_AROUND_LEFT next around the left facet ( eLnext )\n'
    '-   NEXT_AROUND_RIGHT next around the right facet ( eRnext )\n'
    '-   PREV_AROUND_LEFT previous around the left facet (reversed eOnext )\n'
    '-   PREV_AROUND_RIGHT previous around the right facet (reversed eDnext )\n'
    '\n'
    '![sample output](pics/quadedge.png)\n'
    '\n'
    '@returns edge ID related to the input edge.']
parse_name: cv.Subdiv2D.getEdge with ['cv'] -> fullname:cv::Subdiv2D::getEdge namespace:cv classpath:Subdiv2D classname:Subdiv2D name:getEdge
register (method) getEdge in cv::Subdiv2D (cv_Subdiv2D_getEdge_const_int_int)

--- Incoming ---
[   'cv.Subdiv2D.nextEdge',
    'int',
    ['/C'],
    [['int', 'edge', '', []]],
    None,
    '@brief Returns next edge around the edge origin.\n'
    '\n'
    '@param edge Subdivision edge ID.\n'
    '\n'
    '@returns an integer which is next edge ID around the edge origin: eOnext '
    'on the\n'
    'picture above if e is the input edge).']
parse_name: cv.Subdiv2D.nextEdge with ['cv'] -> fullname:cv::Subdiv2D::nextEdge namespace:cv classpath:Subdiv2D classname:Subdiv2D name:nextEdge
register (method) nextEdge in cv::Subdiv2D (cv_Subdiv2D_nextEdge_const_int)

--- Incoming ---
[   'cv.Subdiv2D.rotateEdge',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['int', 'rotate', '', []]],
    None,
    '@brief Returns another edge of the same quad-edge.\n'
    '\n'
    '@param edge Subdivision edge ID.\n'
    '@param rotate Parameter specifying which of the edges of the same '
    'quad-edge as the input\n'
    'one to return. The following values are possible:\n'
    '-   0 - the input edge ( e on the picture below if e is the input edge)\n'
    '-   1 - the rotated edge ( eRot )\n'
    '-   2 - the reversed edge (reversed e (in green))\n'
    '-   3 - the reversed rotated edge (reversed eRot (in green))\n'
    '\n'
    '@returns one of the edges ID of the same quad-edge as the input edge.']
parse_name: cv.Subdiv2D.rotateEdge with ['cv'] -> fullname:cv::Subdiv2D::rotateEdge namespace:cv classpath:Subdiv2D classname:Subdiv2D name:rotateEdge
register (method) rotateEdge in cv::Subdiv2D (cv_Subdiv2D_rotateEdge_const_int_int)

--- Incoming ---
['cv.Subdiv2D.symEdge', 'int', ['/C'], [['int', 'edge', '', []]], None, '']
parse_name: cv.Subdiv2D.symEdge with ['cv'] -> fullname:cv::Subdiv2D::symEdge namespace:cv classpath:Subdiv2D classname:Subdiv2D name:symEdge
register (method) symEdge in cv::Subdiv2D (cv_Subdiv2D_symEdge_const_int)

--- Incoming ---
[   'cv.Subdiv2D.edgeOrg',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['Point2f*', 'orgpt', '0', []]],
    None,
    '@brief Returns the edge origin.\n'
    '\n'
    '@param edge Subdivision edge ID.\n'
    '@param orgpt Output vertex location.\n'
    '\n'
    '@returns vertex ID.']
parse_name: cv.Subdiv2D.edgeOrg with ['cv'] -> fullname:cv::Subdiv2D::edgeOrg namespace:cv classpath:Subdiv2D classname:Subdiv2D name:edgeOrg
register (method) edgeOrg in cv::Subdiv2D (cv_Subdiv2D_edgeOrg_const_int_Point2f_X)

--- Incoming ---
[   'cv.Subdiv2D.edgeDst',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['Point2f*', 'dstpt', '0', []]],
    None,
    '@brief Returns the edge destination.\n'
    '\n'
    '@param edge Subdivision edge ID.\n'
    '@param dstpt Output vertex location.\n'
    '\n'
    '@returns vertex ID.']
parse_name: cv.Subdiv2D.edgeDst with ['cv'] -> fullname:cv::Subdiv2D::edgeDst namespace:cv classpath:Subdiv2D classname:Subdiv2D name:edgeDst
register (method) edgeDst in cv::Subdiv2D (cv_Subdiv2D_edgeDst_const_int_Point2f_X)

--- Incoming ---
['cv.Subdiv2D.newEdge', 'int', ['/H'], [], None, '']
parse_name: cv.Subdiv2D.newEdge with ['cv'] -> fullname:cv::Subdiv2D::newEdge namespace:cv classpath:Subdiv2D classname:Subdiv2D name:newEdge

--- Incoming ---
['cv.Subdiv2D.deleteEdge', 'void', ['/H'], [['int', 'edge', '', []]], None, '']
parse_name: cv.Subdiv2D.deleteEdge with ['cv'] -> fullname:cv::Subdiv2D::deleteEdge namespace:cv classpath:Subdiv2D classname:Subdiv2D name:deleteEdge

--- Incoming ---
[   'cv.Subdiv2D.newPoint',
    'int',
    ['/H'],
    [   ['Point2f', 'pt', '', []],
        ['bool', 'is', '', []],
        ['int', 'firstEdge', '0', []]],
    None,
    '']
parse_name: cv.Subdiv2D.newPoint with ['cv'] -> fullname:cv::Subdiv2D::newPoint namespace:cv classpath:Subdiv2D classname:Subdiv2D name:newPoint

--- Incoming ---
['cv.Subdiv2D.deletePoint', 'void', ['/H'], [['int', 'vtx', '', []]], None, '']
parse_name: cv.Subdiv2D.deletePoint with ['cv'] -> fullname:cv::Subdiv2D::deletePoint namespace:cv classpath:Subdiv2D classname:Subdiv2D name:deletePoint

--- Incoming ---
[   'cv.Subdiv2D.setEdgePoints',
    'void',
    ['/H'],
    [   ['int', 'edge', '', []],
        ['int', 'orgPt', '', []],
        ['int', 'dstPt', '', []]],
    None,
    '']
parse_name: cv.Subdiv2D.setEdgePoints with ['cv'] -> fullname:cv::Subdiv2D::setEdgePoints namespace:cv classpath:Subdiv2D classname:Subdiv2D name:setEdgePoints

--- Incoming ---
[   'cv.Subdiv2D.splice',
    'void',
    ['/H'],
    [['int', 'edgeA', '', []], ['int', 'edgeB', '', []]],
    None,
    '']
parse_name: cv.Subdiv2D.splice with ['cv'] -> fullname:cv::Subdiv2D::splice namespace:cv classpath:Subdiv2D classname:Subdiv2D name:splice

--- Incoming ---
[   'cv.Subdiv2D.connectEdges',
    'int',
    ['/H'],
    [['int', 'edgeA', '', []], ['int', 'edgeB', '', []]],
    None,
    '']
parse_name: cv.Subdiv2D.connectEdges with ['cv'] -> fullname:cv::Subdiv2D::connectEdges namespace:cv classpath:Subdiv2D classname:Subdiv2D name:connectEdges

--- Incoming ---
['cv.Subdiv2D.swapEdges', 'void', ['/H'], [['int', 'edge', '', []]], None, '']
parse_name: cv.Subdiv2D.swapEdges with ['cv'] -> fullname:cv::Subdiv2D::swapEdges namespace:cv classpath:Subdiv2D classname:Subdiv2D name:swapEdges

--- Incoming ---
[   'cv.Subdiv2D.isRightOf',
    'int',
    ['/C', '/H'],
    [['Point2f', 'pt', '', []], ['int', 'edge', '', []]],
    None,
    '']
parse_name: cv.Subdiv2D.isRightOf with ['cv'] -> fullname:cv::Subdiv2D::isRightOf namespace:cv classpath:Subdiv2D classname:Subdiv2D name:isRightOf

--- Incoming ---
['cv.Subdiv2D.calcVoronoi', 'void', ['/H'], [], None, '']
parse_name: cv.Subdiv2D.calcVoronoi with ['cv'] -> fullname:cv::Subdiv2D::calcVoronoi namespace:cv classpath:Subdiv2D classname:Subdiv2D name:calcVoronoi

--- Incoming ---
['cv.Subdiv2D.clearVoronoi', 'void', ['/H'], [], None, '']
parse_name: cv.Subdiv2D.clearVoronoi with ['cv'] -> fullname:cv::Subdiv2D::clearVoronoi namespace:cv classpath:Subdiv2D classname:Subdiv2D name:clearVoronoi

--- Incoming ---
['cv.Subdiv2D.checkSubdiv', 'void', ['/C', '/H'], [], None, '']
parse_name: cv.Subdiv2D.checkSubdiv with ['cv'] -> fullname:cv::Subdiv2D::checkSubdiv namespace:cv classpath:Subdiv2D classname:Subdiv2D name:checkSubdiv

--- Incoming ---
['struct cv.Subdiv2D.Vertex', '', ['/Hidden'], [], None, '']
parse_name: struct cv.Subdiv2D.Vertex with ['cv'] -> fullname:cv::Subdiv2D::Vertex namespace:cv classpath:Subdiv2D classname:Subdiv2D name:Vertex
register class cv::Subdiv2D::Vertex (['struct cv.Subdiv2D.Vertex', '', ['/Hidden'], [], None, '']) [ignored]

--- Incoming ---
['cv.Subdiv2D.Vertex.Vertex', 'V', [], [], None, '']
parse_name: cv.Subdiv2D.Vertex.Vertex with ['cv'] -> fullname:cv::Subdiv2D::Vertex::Vertex namespace:cv classpath:Subdiv2D::Vertex classname:Vertex name:Vertex
Registering an unknown type: Subdiv2D::Vertex
register (constructor) default in cv::Subdiv2D::Vertex (ignored) (cv_Subdiv2D_Vertex_Vertex)

--- Incoming ---
[   'cv.Subdiv2D.Vertex.Vertex',
    'V',
    [],
    [   ['Point2f', 'pt', '', []],
        ['bool', '_is', '', []],
        ['int', '_firstEdge', '0', []]],
    None,
    '']
parse_name: cv.Subdiv2D.Vertex.Vertex with ['cv'] -> fullname:cv::Subdiv2D::Vertex::Vertex namespace:cv classpath:Subdiv2D::Vertex classname:Vertex name:Vertex
register (constructor) new in cv::Subdiv2D::Vertex (ignored) (cv_Subdiv2D_Vertex_Vertex_Point2f_bool_int)

--- Incoming ---
['cv.Subdiv2D.Vertex.is', 'bool', ['/C'], [], None, '']
parse_name: cv.Subdiv2D.Vertex.is with ['cv'] -> fullname:cv::Subdiv2D::Vertex::is namespace:cv classpath:Subdiv2D::Vertex classname:Vertex name:is
register (method) is in cv::Subdiv2D::Vertex (ignored) (cv_Subdiv2D_Vertex_is_const)

--- Incoming ---
['cv.Subdiv2D.Vertex.isfree', 'bool', ['/C'], [], None, '']
parse_name: cv.Subdiv2D.Vertex.isfree with ['cv'] -> fullname:cv::Subdiv2D::Vertex::isfree namespace:cv classpath:Subdiv2D::Vertex classname:Vertex name:isfree
register (method) isfree in cv::Subdiv2D::Vertex (ignored) (cv_Subdiv2D_Vertex_isfree_const)

--- Incoming ---
['struct cv.Subdiv2D.QuadEdge', '', ['/Hidden'], [], None, '']
parse_name: struct cv.Subdiv2D.QuadEdge with ['cv'] -> fullname:cv::Subdiv2D::QuadEdge namespace:cv classpath:Subdiv2D classname:Subdiv2D name:QuadEdge
register class cv::Subdiv2D::QuadEdge (['struct cv.Subdiv2D.QuadEdge', '', ['/Hidden'], [], None, '']) [ignored]

--- Incoming ---
['cv.Subdiv2D.QuadEdge.QuadEdge', 'Q', [], [], None, '']
parse_name: cv.Subdiv2D.QuadEdge.QuadEdge with ['cv'] -> fullname:cv::Subdiv2D::QuadEdge::QuadEdge namespace:cv classpath:Subdiv2D::QuadEdge classname:QuadEdge name:QuadEdge
Registering an unknown type: Subdiv2D::QuadEdge
register (constructor) default in cv::Subdiv2D::QuadEdge (ignored) (cv_Subdiv2D_QuadEdge_QuadEdge)

--- Incoming ---
[   'cv.Subdiv2D.QuadEdge.QuadEdge',
    'Q',
    [],
    [['int', 'edgeidx', '', []]],
    None,
    '']
parse_name: cv.Subdiv2D.QuadEdge.QuadEdge with ['cv'] -> fullname:cv::Subdiv2D::QuadEdge::QuadEdge namespace:cv classpath:Subdiv2D::QuadEdge classname:QuadEdge name:QuadEdge
register (constructor) new in cv::Subdiv2D::QuadEdge (ignored) (cv_Subdiv2D_QuadEdge_QuadEdge_int)

--- Incoming ---
['cv.Subdiv2D.QuadEdge.isfree', 'bool', ['/C'], [], None, '']
parse_name: cv.Subdiv2D.QuadEdge.isfree with ['cv'] -> fullname:cv::Subdiv2D::QuadEdge::isfree namespace:cv classpath:Subdiv2D::QuadEdge classname:QuadEdge name:isfree
register (method) isfree in cv::Subdiv2D::QuadEdge (ignored) (cv_Subdiv2D_QuadEdge_isfree_const)

--- Incoming ---
[   'class cv.LineSegmentDetector',
    ': cv::Algorithm',
    [],
    [],
    None,
    '@brief Line segment detector class\n'
    '\n'
    'following the algorithm described at @cite Rafael12 .\n'
    '\n'
    '@note Implementation has been removed due original code license conflict']
parse_name: class cv.LineSegmentDetector with ['cv'] -> fullname:cv::LineSegmentDetector namespace:cv classpath: classname: name:LineSegmentDetector
register class cv::LineSegmentDetector (['class cv.LineSegmentDetector', ': cv::Algorithm', [], [], None, '@brief Line segment detector class\n\nfollowing the algorithm described at @cite Rafael12 .\n\n@note Implementation has been removed due original code license conflict']) impl:cv::Algorithm

--- Incoming ---
[   'cv.LineSegmentDetector.detect',
    'void',
    ['/A'],
    [   ['InputArray', '_image', '', []],
        ['OutputArray', '_lines', '', []],
        ['OutputArray', 'width', 'noArray()', []],
        ['OutputArray', 'prec', 'noArray()', []],
        ['OutputArray', 'nfa', 'noArray()', []]],
    None,
    '@brief Finds lines in the input image.\n'
    '\n'
    'This is the output of the default parameters of the algorithm on the '
    'above shown image.\n'
    '\n'
    '![image](pics/building_lsd.png)\n'
    '\n'
    '@param _image A grayscale (CV_8UC1) input image. If only a roi needs to '
    'be selected, use:\n'
    '`lsd_ptr-\\>detect(image(roi), lines, ...); lines += Scalar(roi.x, roi.y, '
    'roi.x, roi.y);`\n'
    '@param _lines A vector of Vec4i or Vec4f elements specifying the '
    'beginning and ending point of a line. Where\n'
    'Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. '
    'Returned lines are strictly\n'
    'oriented depending on the gradient.\n'
    '@param width Vector of widths of the regions, where the lines are found. '
    'E.g. Width of line.\n'
    '@param prec Vector of precisions with which the lines are found.\n'
    '@param nfa Vector containing number of false alarms in the line region, '
    'with precision of 10%. The\n'
    'bigger the value, logarithmically better the detection.\n'
    '- -1 corresponds to 10 mean false alarms\n'
    '- 0 corresponds to 1 mean false alarm\n'
    '- 1 corresponds to 0.1 mean false alarms\n'
    'This vector will be calculated only when the objects type is '
    '#LSD_REFINE_ADV.']
parse_name: cv.LineSegmentDetector.detect with ['cv'] -> fullname:cv::LineSegmentDetector::detect namespace:cv classpath:LineSegmentDetector classname:LineSegmentDetector name:detect
register (method) detect in cv::LineSegmentDetector (trait) (cv_LineSegmentDetector_detect__InputArray__OutputArray__OutputArray__OutputArray__OutputArray)

--- Incoming ---
[   'cv.LineSegmentDetector.drawSegments',
    'void',
    ['/A'],
    [['InputOutputArray', '_image', '', []], ['InputArray', 'lines', '', []]],
    None,
    '@brief Draws the line segments on a given image.\n'
    '@param _image The image, where the lines will be drawn. Should be bigger '
    'or equal to the image,\n'
    'where the lines were found.\n'
    '@param lines A vector of the lines that needed to be drawn.']
parse_name: cv.LineSegmentDetector.drawSegments with ['cv'] -> fullname:cv::LineSegmentDetector::drawSegments namespace:cv classpath:LineSegmentDetector classname:LineSegmentDetector name:drawSegments
register (method) drawSegments in cv::LineSegmentDetector (trait) (cv_LineSegmentDetector_drawSegments__InputOutputArray__InputArray)

--- Incoming ---
[   'cv.LineSegmentDetector.compareSegments',
    'int',
    ['/A'],
    [   ['const Size&', 'size', '', []],
        ['InputArray', 'lines1', '', []],
        ['InputArray', 'lines2', '', []],
        ['InputOutputArray', '_image', 'noArray()', []]],
    None,
    '@brief Draws two groups of lines in blue and red, counting the non '
    'overlapping (mismatching) pixels.\n'
    '\n'
    '@param size The size of the image, where lines1 and lines2 were found.\n'
    '@param lines1 The first group of lines that needs to be drawn. It is '
    'visualized in blue color.\n'
    '@param lines2 The second group of lines. They visualized in red color.\n'
    '@param _image Optional image, where the lines will be drawn. The image '
    'should be color(3-channel)\n'
    'in order for lines1 and lines2 to be drawn in the above mentioned colors.']
parse_name: cv.LineSegmentDetector.compareSegments with ['cv'] -> fullname:cv::LineSegmentDetector::compareSegments namespace:cv classpath:LineSegmentDetector classname:LineSegmentDetector name:compareSegments
register (method) compareSegments in cv::LineSegmentDetector (trait) (cv_LineSegmentDetector_compareSegments_Size__InputArray__InputArray__InputOutputArray)

--- Incoming ---
['cv.LineSegmentDetector.~LineSegmentDetector', '~', [], [], None, '']
parse_name: cv.LineSegmentDetector.~LineSegmentDetector with ['cv'] -> fullname:cv::LineSegmentDetector::~LineSegmentDetector namespace:cv classpath:LineSegmentDetector classname:LineSegmentDetector name:~LineSegmentDetector
Registering an unknown type: ~
ignore destructor (method) ~LineSegmentDetector in cv::LineSegmentDetector (trait)

--- Incoming ---
[   'cv.createLineSegmentDetector',
    'Ptr<LineSegmentDetector>',
    [],
    [   ['int', '_refine', 'LSD_REFINE_STD', []],
        ['double', '_scale', '0.8', []],
        ['double', '_sigma_scale', '0.6', []],
        ['double', '_quant', '2.0', []],
        ['double', '_ang_th', '22.5', []],
        ['double', '_log_eps', '0', []],
        ['double', '_density_th', '0.7', []],
        ['int', '_n_bins', '1024', []]],
    None,
    '@brief Creates a smart pointer to a LineSegmentDetector object and '
    'initializes it.\n'
    '\n'
    'The LineSegmentDetector algorithm is defined using the standard values. '
    'Only advanced users may want\n'
    'to edit those, as to tailor it for their own application.\n'
    '\n'
    '@param _refine The way found lines will be refined, see '
    '#LineSegmentDetectorModes\n'
    '@param _scale The scale of the image that will be used to find the lines. '
    'Range (0..1].\n'
    '@param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = '
    '_sigma_scale/_scale.\n'
    '@param _quant Bound to the quantization error on the gradient norm.\n'
    '@param _ang_th Gradient angle tolerance in degrees.\n'
    '@param _log_eps Detection threshold: -log10(NFA) \\> log_eps. Used only '
    'when advance refinement\n'
    'is chosen.\n'
    '@param _density_th Minimal density of aligned region points in the '
    'enclosing rectangle.\n'
    '@param _n_bins Number of bins in pseudo-ordering of gradient modulus.\n'
    '\n'
    '@note Implementation has been removed due original code license conflict']
parse_name: cv.createLineSegmentDetector with ['cv'] -> fullname:cv::createLineSegmentDetector namespace:cv classpath: classname: name:createLineSegmentDetector
register (function) createLineSegmentDetector (cv_createLineSegmentDetector_int_double_double_double_double_double_double_int)

--- Incoming ---
[   'cv.getGaussianKernel',
    'Mat',
    [],
    [   ['int', 'ksize', '', []],
        ['double', 'sigma', '', []],
        ['int', 'ktype', 'CV_64F', []]],
    None,
    '@brief Returns Gaussian filter coefficients.\n'
    '\n'
    'The function computes and returns the \\f$\\texttt{ksize} \\times 1\\f$ '
    'matrix of Gaussian filter\n'
    'coefficients:\n'
    '\n'
    '\\f[G_i= \\alpha *e^{-(i-( \\texttt{ksize} -1)/2)^2/(2* '
    '\\texttt{sigma}^2)},\\f]\n'
    '\n'
    'where \\f$i=0..\\texttt{ksize}-1\\f$ and \\f$\\alpha\\f$ is the scale '
    'factor chosen so that \\f$\\sum_i G_i=1\\f$.\n'
    '\n'
    'Two of such generated kernels can be passed to sepFilter2D. Those '
    'functions automatically recognize\n'
    'smoothing kernels (a symmetrical kernel with sum of weights equal to 1) '
    'and handle them accordingly.\n'
    'You may also use the higher-level GaussianBlur.\n'
    '@param ksize Aperture size. It should be odd ( \\f$\\texttt{ksize} \\mod '
    '2 = 1\\f$ ) and positive.\n'
    '@param sigma Gaussian standard deviation. If it is non-positive, it is '
    'computed from ksize as\n'
    '`sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.\n'
    '@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .\n'
    '@sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur']
parse_name: cv.getGaussianKernel with ['cv'] -> fullname:cv::getGaussianKernel namespace:cv classpath: classname: name:getGaussianKernel
register (function) getGaussianKernel (cv_getGaussianKernel_int_double_int)

--- Incoming ---
[   'cv.getDerivKernels',
    'void',
    [],
    [   ['OutputArray', 'kx', '', []],
        ['OutputArray', 'ky', '', []],
        ['int', 'dx', '', []],
        ['int', 'dy', '', []],
        ['int', 'ksize', '', []],
        ['bool', 'normalize', 'false', []],
        ['int', 'ktype', 'CV_32F', []]],
    None,
    '@brief Returns filter coefficients for computing spatial image '
    'derivatives.\n'
    '\n'
    'The function computes and returns the filter coefficients for spatial '
    'image derivatives. When\n'
    '`ksize=FILTER_SCHARR`, the Scharr \\f$3 \\times 3\\f$ kernels are '
    'generated (see #Scharr). Otherwise, Sobel\n'
    'kernels are generated (see #Sobel). The filters are normally passed to '
    '#sepFilter2D or to\n'
    '\n'
    '@param kx Output matrix of row filter coefficients. It has the type ktype '
    '.\n'
    '@param ky Output matrix of column filter coefficients. It has the type '
    'ktype .\n'
    '@param dx Derivative order in respect of x.\n'
    '@param dy Derivative order in respect of y.\n'
    '@param ksize Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.\n'
    '@param normalize Flag indicating whether to normalize (scale down) the '
    'filter coefficients or not.\n'
    'Theoretically, the coefficients should have the denominator '
    '\\f$=2^{ksize*2-dx-dy-2}\\f$. If you are\n'
    'going to filter floating-point images, you are likely to use the '
    'normalized kernels. But if you\n'
    'compute derivatives of an 8-bit image, store the results in a 16-bit '
    'image, and wish to preserve\n'
    'all the fractional bits, you may want to set normalize=false .\n'
    '@param ktype Type of filter coefficients. It can be CV_32f or CV_64F .']
parse_name: cv.getDerivKernels with ['cv'] -> fullname:cv::getDerivKernels namespace:cv classpath: classname: name:getDerivKernels
register (function) getDerivKernels (cv_getDerivKernels__OutputArray__OutputArray_int_int_int_bool_int)

--- Incoming ---
[   'cv.getGaborKernel',
    'Mat',
    [],
    [   ['Size', 'ksize', '', []],
        ['double', 'sigma', '', []],
        ['double', 'theta', '', []],
        ['double', 'lambd', '', []],
        ['double', 'gamma', '', []],
        ['double', 'psi', 'CV_PI*0.5', []],
        ['int', 'ktype', 'CV_64F', []]],
    None,
    '@brief Returns Gabor filter coefficients.\n'
    '\n'
    'For more details about gabor filter equations and parameters, see: '
    '[Gabor\n'
    'Filter](http://en.wikipedia.org/wiki/Gabor_filter).\n'
    '\n'
    '@param ksize Size of the filter returned.\n'
    '@param sigma Standard deviation of the gaussian envelope.\n'
    '@param theta Orientation of the normal to the parallel stripes of a Gabor '
    'function.\n'
    '@param lambd Wavelength of the sinusoidal factor.\n'
    '@param gamma Spatial aspect ratio.\n'
    '@param psi Phase offset.\n'
    '@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .']
parse_name: cv.getGaborKernel with ['cv'] -> fullname:cv::getGaborKernel namespace:cv classpath: classname: name:getGaborKernel
register (function) getGaborKernel (cv_getGaborKernel_Size_double_double_double_double_double_int)

--- Incoming ---
[   'cv.morphologyDefaultBorderValue',
    'Scalar',
    [],
    [],
    None,
    'returns "magic" border value for erosion and dilation. It is '
    'automatically transformed to Scalar::all(-DBL_MAX) for dilation.']
parse_name: cv.morphologyDefaultBorderValue with ['cv'] -> fullname:cv::morphologyDefaultBorderValue namespace:cv classpath: classname: name:morphologyDefaultBorderValue
register (function) morphologyDefaultBorderValue (cv_morphologyDefaultBorderValue)

--- Incoming ---
[   'cv.getStructuringElement',
    'Mat',
    [],
    [   ['int', 'shape', '', []],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []]],
    None,
    '@brief Returns a structuring element of the specified size and shape for '
    'morphological operations.\n'
    '\n'
    'The function constructs and returns the structuring element that can be '
    'further passed to #erode,\n'
    '#dilate or #morphologyEx. But you can also construct an arbitrary binary '
    'mask yourself and use it as\n'
    'the structuring element.\n'
    '\n'
    '@param shape Element shape that could be one of #MorphShapes\n'
    '@param ksize Size of the structuring element.\n'
    '@param anchor Anchor position within the element. The default value '
    '\\f$(-1, -1)\\f$ means that the\n'
    'anchor is at the center. Note that only the shape of a cross-shaped '
    'element depends on the anchor\n'
    'position. In other cases the anchor just regulates how much the result of '
    'the morphological\n'
    'operation is shifted.']
parse_name: cv.getStructuringElement with ['cv'] -> fullname:cv::getStructuringElement namespace:cv classpath: classname: name:getStructuringElement
register (function) getStructuringElement (cv_getStructuringElement_int_Size_Point)

--- Incoming ---
[   'cv.medianBlur',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ksize', '', []]],
    None,
    '@brief Blurs an image using the median filter.\n'
    '\n'
    'The function smoothes an image using the median filter with the '
    '\\f$\\texttt{ksize} \\times\n'
    '\\texttt{ksize}\\f$ aperture. Each channel of a multi-channel image is '
    'processed independently.\n'
    'In-place operation is supported.\n'
    '\n'
    '@note The median filter uses #BORDER_REPLICATE internally to cope with '
    'border pixels, see #BorderTypes\n'
    '\n'
    '@param src input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the '
    'image depth should be\n'
    'CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be '
    'CV_8U.\n'
    '@param dst destination array of the same size and type as src.\n'
    '@param ksize aperture linear size; it must be odd and greater than 1, for '
    'example: 3, 5, 7 ...\n'
    '@sa  bilateralFilter, blur, boxFilter, GaussianBlur']
parse_name: cv.medianBlur with ['cv'] -> fullname:cv::medianBlur namespace:cv classpath: classname: name:medianBlur
register (function) medianBlur (cv_medianBlur__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.GaussianBlur',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['Size', 'ksize', '', []],
        ['double', 'sigmaX', '', []],
        ['double', 'sigmaY', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Blurs an image using a Gaussian filter.\n'
    '\n'
    'The function convolves the source image with the specified Gaussian '
    'kernel. In-place filtering is\n'
    'supported.\n'
    '\n'
    '@param src input image; the image can have any number of channels, which '
    'are processed\n'
    'independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or '
    'CV_64F.\n'
    '@param dst output image of the same size and type as src.\n'
    '@param ksize Gaussian kernel size. ksize.width and ksize.height can '
    'differ but they both must be\n'
    "positive and odd. Or, they can be zero's and then they are computed from "
    'sigma.\n'
    '@param sigmaX Gaussian kernel standard deviation in X direction.\n'
    '@param sigmaY Gaussian kernel standard deviation in Y direction; if '
    'sigmaY is zero, it is set to be\n'
    'equal to sigmaX, if both sigmas are zeros, they are computed from '
    'ksize.width and ksize.height,\n'
    'respectively (see #getGaussianKernel for details); to fully control the '
    'result regardless of\n'
    'possible future modifications of all this semantics, it is recommended to '
    'specify all of ksize,\n'
    'sigmaX, and sigmaY.\n'
    '@param borderType pixel extrapolation method, see #BorderTypes\n'
    '\n'
    '@sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur']
parse_name: cv.GaussianBlur with ['cv'] -> fullname:cv::GaussianBlur namespace:cv classpath: classname: name:GaussianBlur
register (function) GaussianBlur (cv_GaussianBlur__InputArray__OutputArray_Size_double_double_int)

--- Incoming ---
[   'cv.bilateralFilter',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'd', '', []],
        ['double', 'sigmaColor', '', []],
        ['double', 'sigmaSpace', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Applies the bilateral filter to an image.\n'
    '\n'
    'The function applies bilateral filtering to the input image, as described '
    'in\n'
    'http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html\n'
    'bilateralFilter can reduce unwanted noise very well while keeping edges '
    'fairly sharp. However, it is\n'
    'very slow compared to most filters.\n'
    '\n'
    '_Sigma values_: For simplicity, you can set the 2 sigma values to be the '
    'same. If they are small (\\<\n'
    '10), the filter will not have much effect, whereas if they are large (\\> '
    '150), they will have a very\n'
    'strong effect, making the image look "cartoonish".\n'
    '\n'
    '_Filter size_: Large filters (d \\> 5) are very slow, so it is '
    'recommended to use d=5 for real-time\n'
    'applications, and perhaps d=9 for offline applications that need heavy '
    'noise filtering.\n'
    '\n'
    'This filter does not work inplace.\n'
    '@param src Source 8-bit or floating-point, 1-channel or 3-channel image.\n'
    '@param dst Destination image of the same size and type as src .\n'
    '@param d Diameter of each pixel neighborhood that is used during '
    'filtering. If it is non-positive,\n'
    'it is computed from sigmaSpace.\n'
    '@param sigmaColor Filter sigma in the color space. A larger value of the '
    'parameter means that\n'
    'farther colors within the pixel neighborhood (see sigmaSpace) will be '
    'mixed together, resulting\n'
    'in larger areas of semi-equal color.\n'
    '@param sigmaSpace Filter sigma in the coordinate space. A larger value of '
    'the parameter means that\n'
    'farther pixels will influence each other as long as their colors are '
    'close enough (see sigmaColor\n'
    '). When d\\>0, it specifies the neighborhood size regardless of '
    'sigmaSpace. Otherwise, d is\n'
    'proportional to sigmaSpace.\n'
    '@param borderType border mode used to extrapolate pixels outside of the '
    'image, see #BorderTypes']
parse_name: cv.bilateralFilter with ['cv'] -> fullname:cv::bilateralFilter namespace:cv classpath: classname: name:bilateralFilter
register (function) bilateralFilter (cv_bilateralFilter__InputArray__OutputArray_int_double_double_int)

--- Incoming ---
[   'cv.boxFilter',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ddepth', '', []],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['bool', 'normalize', 'true', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Blurs an image using the box filter.\n'
    '\n'
    'The function smooths an image using the kernel:\n'
    '\n'
    '\\f[\\texttt{K} =  \\alpha \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  '
    '\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ \\hdotsfor{6} \\\\ 1 & 1 & 1 &  '
    '\\cdots & 1 & 1 \\end{bmatrix}\\f]\n'
    '\n'
    'where\n'
    '\n'
    '\\f[\\alpha = \\fork{\\frac{1}{\\texttt{ksize.width*ksize.height}}}{when '
    '\\texttt{normalize=true}}{1}{otherwise}\\f]\n'
    '\n'
    'Unnormalized box filter is useful for computing various integral '
    'characteristics over each pixel\n'
    'neighborhood, such as covariance matrices of image derivatives (used in '
    'dense optical flow\n'
    'algorithms, and so on). If you need to compute pixel sums over '
    'variable-size windows, use #integral.\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image of the same size and type as src.\n'
    '@param ddepth the output image depth (-1 to use src.depth()).\n'
    '@param ksize blurring kernel size.\n'
    '@param anchor anchor point; default value Point(-1,-1) means that the '
    'anchor is at the kernel\n'
    'center.\n'
    '@param normalize flag, specifying whether the kernel is normalized by its '
    'area or not.\n'
    '@param borderType border mode used to extrapolate pixels outside of the '
    'image, see #BorderTypes\n'
    '@sa  blur, bilateralFilter, GaussianBlur, medianBlur, integral']
parse_name: cv.boxFilter with ['cv'] -> fullname:cv::boxFilter namespace:cv classpath: classname: name:boxFilter
register (function) boxFilter (cv_boxFilter__InputArray__OutputArray_int_Size_Point_bool_int)

--- Incoming ---
[   'cv.sqrBoxFilter',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ddepth', '', []],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1, -1)', []],
        ['bool', 'normalize', 'true', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates the normalized sum of squares of the pixel values '
    'overlapping the filter.\n'
    '\n'
    'For every pixel \\f$ (x, y) \\f$ in the source image, the function '
    'calculates the sum of squares of those neighboring\n'
    'pixel values which overlap the filter placed over the pixel \\f$ (x, y) '
    '\\f$.\n'
    '\n'
    'The unnormalized square box filter can be useful in computing local image '
    'statistics such as the the local\n'
    'variance and standard deviation around the neighborhood of a pixel.\n'
    '\n'
    '@param src input image\n'
    '@param dst output image of the same size and type as _src\n'
    '@param ddepth the output image depth (-1 to use src.depth())\n'
    '@param ksize kernel size\n'
    '@param anchor kernel anchor point. The default value of Point(-1, -1) '
    'denotes that the anchor is at the kernel\n'
    'center.\n'
    '@param normalize flag, specifying whether the kernel is to be normalized '
    "by it's area or not.\n"
    '@param borderType border mode used to extrapolate pixels outside of the '
    'image, see #BorderTypes\n'
    '@sa boxFilter']
parse_name: cv.sqrBoxFilter with ['cv'] -> fullname:cv::sqrBoxFilter namespace:cv classpath: classname: name:sqrBoxFilter
register (function) sqrBoxFilter (cv_sqrBoxFilter__InputArray__OutputArray_int_Size_Point_bool_int)

--- Incoming ---
[   'cv.blur',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Blurs an image using the normalized box filter.\n'
    '\n'
    'The function smooths an image using the kernel:\n'
    '\n'
    '\\f[\\texttt{K} =  \\frac{1}{\\texttt{ksize.width*ksize.height}} '
    '\\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ 1 & 1 & 1 &  \\cdots '
    '& 1 & 1  \\\\ \\hdotsfor{6} \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ '
    '\\end{bmatrix}\\f]\n'
    '\n'
    'The call `blur(src, dst, ksize, anchor, borderType)` is equivalent to '
    '`boxFilter(src, dst, src.type(),\n'
    'anchor, true, borderType)`.\n'
    '\n'
    '@param src input image; it can have any number of channels, which are '
    'processed independently, but\n'
    'the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n'
    '@param dst output image of the same size and type as src.\n'
    '@param ksize blurring kernel size.\n'
    '@param anchor anchor point; default value Point(-1,-1) means that the '
    'anchor is at the kernel\n'
    'center.\n'
    '@param borderType border mode used to extrapolate pixels outside of the '
    'image, see #BorderTypes\n'
    '@sa  boxFilter, bilateralFilter, GaussianBlur, medianBlur']
parse_name: cv.blur with ['cv'] -> fullname:cv::blur namespace:cv classpath: classname: name:blur
register (function) blur (cv_blur__InputArray__OutputArray_Size_Point_int)

--- Incoming ---
[   'cv.filter2D',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ddepth', '', []],
        ['InputArray', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Convolves an image with the kernel.\n'
    '\n'
    'The function applies an arbitrary linear filter to an image. In-place '
    'operation is supported. When\n'
    'the aperture is partially outside the image, the function interpolates '
    'outlier pixel values\n'
    'according to the specified border mode.\n'
    '\n'
    'The function does actually compute correlation, not the convolution:\n'
    '\n'
    "\\f[\\texttt{dst} (x,y) =  \\sum _{ \\stackrel{0\\leq x' < "
    "\\texttt{kernel.cols},}{0\\leq y' < \\texttt{kernel.rows}} }  "
    "\\texttt{kernel} (x',y')* \\texttt{src} (x+x'- \\texttt{anchor.x} ,y+y'- "
    '\\texttt{anchor.y} )\\f]\n'
    '\n'
    'That is, the kernel is not mirrored around the anchor point. If you need '
    'a real convolution, flip\n'
    'the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x '
    '- 1, kernel.rows -\n'
    'anchor.y - 1)`.\n'
    '\n'
    'The function uses the DFT-based algorithm in case of sufficiently large '
    'kernels (~`11 x 11` or\n'
    'larger) and the direct algorithm for small kernels.\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image of the same size and the same number of channels '
    'as src.\n'
    '@param ddepth desired depth of the destination image, see @ref '
    'filter_depths "combinations"\n'
    '@param kernel convolution kernel (or rather a correlation kernel), a '
    'single-channel floating point\n'
    'matrix; if you want to apply different kernels to different channels, '
    'split the image into\n'
    'separate color planes using split and process them individually.\n'
    '@param anchor anchor of the kernel that indicates the relative position '
    'of a filtered point within\n'
    'the kernel; the anchor should lie within the kernel; default value '
    '(-1,-1) means that the anchor\n'
    'is at the kernel center.\n'
    '@param delta optional value added to the filtered pixels before storing '
    'them in dst.\n'
    '@param borderType pixel extrapolation method, see #BorderTypes\n'
    '@sa  sepFilter2D, dft, matchTemplate']
parse_name: cv.filter2D with ['cv'] -> fullname:cv::filter2D namespace:cv classpath: classname: name:filter2D
register (function) filter2D (cv_filter2D__InputArray__OutputArray_int__InputArray_Point_double_int)

--- Incoming ---
[   'cv.sepFilter2D',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ddepth', '', []],
        ['InputArray', 'kernelX', '', []],
        ['InputArray', 'kernelY', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Applies a separable linear filter to an image.\n'
    '\n'
    'The function applies a separable linear filter to the image. That is, '
    'first, every row of src is\n'
    'filtered with the 1D kernel kernelX. Then, every column of the result is '
    'filtered with the 1D\n'
    'kernel kernelY. The final result shifted by delta is stored in dst .\n'
    '\n'
    '@param src Source image.\n'
    '@param dst Destination image of the same size and the same number of '
    'channels as src .\n'
    '@param ddepth Destination image depth, see @ref filter_depths '
    '"combinations"\n'
    '@param kernelX Coefficients for filtering each row.\n'
    '@param kernelY Coefficients for filtering each column.\n'
    '@param anchor Anchor position within the kernel. The default value '
    '\\f$(-1,-1)\\f$ means that the anchor\n'
    'is at the kernel center.\n'
    '@param delta Value added to the filtered results before storing them.\n'
    '@param borderType Pixel extrapolation method, see #BorderTypes\n'
    '@sa  filter2D, Sobel, GaussianBlur, boxFilter, blur']
parse_name: cv.sepFilter2D with ['cv'] -> fullname:cv::sepFilter2D namespace:cv classpath: classname: name:sepFilter2D
register (function) sepFilter2D (cv_sepFilter2D__InputArray__OutputArray_int__InputArray__InputArray_Point_double_int)

--- Incoming ---
[   'cv.Sobel',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ddepth', '', []],
        ['int', 'dx', '', []],
        ['int', 'dy', '', []],
        ['int', 'ksize', '3', []],
        ['double', 'scale', '1', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates the first, second, third, or mixed image derivatives '
    'using an extended Sobel operator.\n'
    '\n'
    'In all cases except one, the \\f$\\texttt{ksize} \\times '
    '\\texttt{ksize}\\f$ separable kernel is used to\n'
    'calculate the derivative. When \\f$\\texttt{ksize = 1}\\f$, the \\f$3 '
    '\\times 1\\f$ or \\f$1 \\times 3\\f$\n'
    'kernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can '
    'only be used for the first\n'
    'or the second x- or y- derivatives.\n'
    '\n'
    'There is also the special value `ksize = #FILTER_SCHARR (-1)` that '
    'corresponds to the \\f$3\\times3\\f$ Scharr\n'
    'filter that may give more accurate results than the \\f$3\\times3\\f$ '
    'Sobel. The Scharr aperture is\n'
    '\n'
    '\\f[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\f]\n'
    '\n'
    'for the x-derivative, or transposed for the y-derivative.\n'
    '\n'
    'The function calculates an image derivative by convolving the image with '
    'the appropriate kernel:\n'
    '\n'
    '\\f[\\texttt{dst} =  \\frac{\\partial^{xorder+yorder} '
    '\\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\f]\n'
    '\n'
    'The Sobel operators combine Gaussian smoothing and differentiation, so '
    'the result is more or less\n'
    'resistant to the noise. Most often, the function is called with ( xorder '
    '= 1, yorder = 0, ksize = 3)\n'
    'or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- '
    'image derivative. The first\n'
    'case corresponds to a kernel of:\n'
    '\n'
    '\\f[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\f]\n'
    '\n'
    'The second case corresponds to a kernel of:\n'
    '\n'
    '\\f[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\f]\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image of the same size and the same number of channels '
    'as src .\n'
    '@param ddepth output image depth, see @ref filter_depths "combinations"; '
    'in the case of\n'
    '8-bit input images it will result in truncated derivatives.\n'
    '@param dx order of the derivative x.\n'
    '@param dy order of the derivative y.\n'
    '@param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or '
    '7.\n'
    '@param scale optional scale factor for the computed derivative values; by '
    'default, no scaling is\n'
    'applied (see #getDerivKernels for details).\n'
    '@param delta optional delta value that is added to the results prior to '
    'storing them in dst.\n'
    '@param borderType pixel extrapolation method, see #BorderTypes\n'
    '@sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar']
parse_name: cv.Sobel with ['cv'] -> fullname:cv::Sobel namespace:cv classpath: classname: name:Sobel
register (function) Sobel (cv_Sobel__InputArray__OutputArray_int_int_int_int_double_double_int)

--- Incoming ---
[   'cv.spatialGradient',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dx', '', []],
        ['OutputArray', 'dy', '', []],
        ['int', 'ksize', '3', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates the first order image derivative in both x and y using '
    'a Sobel operator\n'
    '\n'
    'Equivalent to calling:\n'
    '\n'
    '@code\n'
    'Sobel( src, dx, CV_16SC1, 1, 0, 3 );\n'
    'Sobel( src, dy, CV_16SC1, 0, 1, 3 );\n'
    '@endcode\n'
    '\n'
    '@param src input image.\n'
    '@param dx output image with first-order derivative in x.\n'
    '@param dy output image with first-order derivative in y.\n'
    '@param ksize size of Sobel kernel. It must be 3.\n'
    '@param borderType pixel extrapolation method, see #BorderTypes\n'
    '\n'
    '@sa Sobel']
parse_name: cv.spatialGradient with ['cv'] -> fullname:cv::spatialGradient namespace:cv classpath: classname: name:spatialGradient
register (function) spatialGradient (cv_spatialGradient__InputArray__OutputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.Scharr',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ddepth', '', []],
        ['int', 'dx', '', []],
        ['int', 'dy', '', []],
        ['double', 'scale', '1', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates the first x- or y- image derivative using Scharr '
    'operator.\n'
    '\n'
    'The function computes the first x- or y- spatial image derivative using '
    'the Scharr operator. The\n'
    'call\n'
    '\n'
    '\\f[\\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, '
    'borderType)}\\f]\n'
    '\n'
    'is equivalent to\n'
    '\n'
    '\\f[\\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, '
    'borderType)} .\\f]\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image of the same size and the same number of channels '
    'as src.\n'
    '@param ddepth output image depth, see @ref filter_depths "combinations"\n'
    '@param dx order of the derivative x.\n'
    '@param dy order of the derivative y.\n'
    '@param scale optional scale factor for the computed derivative values; by '
    'default, no scaling is\n'
    'applied (see #getDerivKernels for details).\n'
    '@param delta optional delta value that is added to the results prior to '
    'storing them in dst.\n'
    '@param borderType pixel extrapolation method, see #BorderTypes\n'
    '@sa  cartToPolar']
parse_name: cv.Scharr with ['cv'] -> fullname:cv::Scharr namespace:cv classpath: classname: name:Scharr
register (function) Scharr (cv_Scharr__InputArray__OutputArray_int_int_int_double_double_int)

--- Incoming ---
[   'cv.Laplacian',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ddepth', '', []],
        ['int', 'ksize', '1', []],
        ['double', 'scale', '1', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates the Laplacian of an image.\n'
    '\n'
    'The function calculates the Laplacian of the source image by adding up '
    'the second x and y\n'
    'derivatives calculated using the Sobel operator:\n'
    '\n'
    '\\f[\\texttt{dst} =  \\Delta \\texttt{src} =  \\frac{\\partial^2 '
    '\\texttt{src}}{\\partial x^2} +  \\frac{\\partial^2 '
    '\\texttt{src}}{\\partial y^2}\\f]\n'
    '\n'
    'This is done when `ksize > 1`. When `ksize == 1`, the Laplacian is '
    'computed by filtering the image\n'
    'with the following \\f$3 \\times 3\\f$ aperture:\n'
    '\n'
    '\\f[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\f]\n'
    '\n'
    '@param src Source image.\n'
    '@param dst Destination image of the same size and the same number of '
    'channels as src .\n'
    '@param ddepth Desired depth of the destination image.\n'
    '@param ksize Aperture size used to compute the second-derivative filters. '
    'See #getDerivKernels for\n'
    'details. The size must be positive and odd.\n'
    '@param scale Optional scale factor for the computed Laplacian values. By '
    'default, no scaling is\n'
    'applied. See #getDerivKernels for details.\n'
    '@param delta Optional delta value that is added to the results prior to '
    'storing them in dst .\n'
    '@param borderType Pixel extrapolation method, see #BorderTypes\n'
    '@sa  Sobel, Scharr']
parse_name: cv.Laplacian with ['cv'] -> fullname:cv::Laplacian namespace:cv classpath: classname: name:Laplacian
register (function) Laplacian (cv_Laplacian__InputArray__OutputArray_int_int_double_double_int)

--- Incoming ---
[   'cv.Canny',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'edges', '', []],
        ['double', 'threshold1', '', []],
        ['double', 'threshold2', '', []],
        ['int', 'apertureSize', '3', []],
        ['bool', 'L2gradient', 'false', []]],
    None,
    '@brief Finds edges in an image using the Canny algorithm @cite Canny86 .\n'
    '\n'
    'The function finds edges in the input image and marks them in the output '
    'map edges using the\n'
    'Canny algorithm. The smallest value between threshold1 and threshold2 is '
    'used for edge linking. The\n'
    'largest value is used to find initial segments of strong edges. See\n'
    '<http://en.wikipedia.org/wiki/Canny_edge_detector>\n'
    '\n'
    '@param image 8-bit input image.\n'
    '@param edges output edge map; single channels 8-bit image, which has the '
    'same size as image .\n'
    '@param threshold1 first threshold for the hysteresis procedure.\n'
    '@param threshold2 second threshold for the hysteresis procedure.\n'
    '@param apertureSize aperture size for the Sobel operator.\n'
    '@param L2gradient a flag, indicating whether a more accurate \\f$L_2\\f$ '
    'norm\n'
    '\\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the '
    'image gradient magnitude (\n'
    'L2gradient=true ), or whether the default \\f$L_1\\f$ norm '
    '\\f$=|dI/dx|+|dI/dy|\\f$ is enough (\n'
    'L2gradient=false ).']
parse_name: cv.Canny with ['cv'] -> fullname:cv::Canny namespace:cv classpath: classname: name:Canny
register (function) Canny (cv_Canny__InputArray__OutputArray_double_double_int_bool)

--- Incoming ---
[   'cv.Canny',
    'void',
    [],
    [   ['InputArray', 'dx', '', []],
        ['InputArray', 'dy', '', []],
        ['OutputArray', 'edges', '', []],
        ['double', 'threshold1', '', []],
        ['double', 'threshold2', '', []],
        ['bool', 'L2gradient', 'false', []]],
    None,
    '\\overload\n'
    '\n'
    'Finds edges in an image using the Canny algorithm with custom image '
    'gradient.\n'
    '\n'
    '@param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).\n'
    '@param dy 16-bit y derivative of input image (same type as dx).\n'
    '@param edges output edge map; single channels 8-bit image, which has the '
    'same size as image .\n'
    '@param threshold1 first threshold for the hysteresis procedure.\n'
    '@param threshold2 second threshold for the hysteresis procedure.\n'
    '@param L2gradient a flag, indicating whether a more accurate \\f$L_2\\f$ '
    'norm\n'
    '\\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the '
    'image gradient magnitude (\n'
    'L2gradient=true ), or whether the default \\f$L_1\\f$ norm '
    '\\f$=|dI/dx|+|dI/dy|\\f$ is enough (\n'
    'L2gradient=false ).']
parse_name: cv.Canny with ['cv'] -> fullname:cv::Canny namespace:cv classpath: classname: name:Canny
register (function) Canny (cv_Canny__InputArray__InputArray__OutputArray_double_double_bool)

--- Incoming ---
[   'cv.cornerMinEigenVal',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'blockSize', '', []],
        ['int', 'ksize', '3', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates the minimal eigenvalue of gradient matrices for corner '
    'detection.\n'
    '\n'
    'The function is similar to cornerEigenValsAndVecs but it calculates and '
    'stores only the minimal\n'
    'eigenvalue of the covariance matrix of derivatives, that is, '
    '\\f$\\min(\\lambda_1, \\lambda_2)\\f$ in terms\n'
    'of the formulae in the cornerEigenValsAndVecs description.\n'
    '\n'
    '@param src Input single-channel 8-bit or floating-point image.\n'
    '@param dst Image to store the minimal eigenvalues. It has the type '
    'CV_32FC1 and the same size as\n'
    'src .\n'
    '@param blockSize Neighborhood size (see the details on '
    '#cornerEigenValsAndVecs ).\n'
    '@param ksize Aperture parameter for the Sobel operator.\n'
    '@param borderType Pixel extrapolation method. See #BorderTypes.']
parse_name: cv.cornerMinEigenVal with ['cv'] -> fullname:cv::cornerMinEigenVal namespace:cv classpath: classname: name:cornerMinEigenVal
register (function) cornerMinEigenVal (cv_cornerMinEigenVal__InputArray__OutputArray_int_int_int)

--- Incoming ---
[   'cv.cornerHarris',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'blockSize', '', []],
        ['int', 'ksize', '', []],
        ['double', 'k', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Harris corner detector.\n'
    '\n'
    'The function runs the Harris corner detector on the image. Similarly to '
    'cornerMinEigenVal and\n'
    'cornerEigenValsAndVecs , for each pixel \\f$(x, y)\\f$ it calculates a '
    '\\f$2\\times2\\f$ gradient covariance\n'
    'matrix \\f$M^{(x,y)}\\f$ over a \\f$\\texttt{blockSize} \\times '
    '\\texttt{blockSize}\\f$ neighborhood. Then, it\n'
    'computes the following characteristic:\n'
    '\n'
    '\\f[\\texttt{dst} (x,y) =  \\mathrm{det} M^{(x,y)} - k  \\cdot \\left ( '
    '\\mathrm{tr} M^{(x,y)} \\right )^2\\f]\n'
    '\n'
    'Corners in the image can be found as the local maxima of this response '
    'map.\n'
    '\n'
    '@param src Input single-channel 8-bit or floating-point image.\n'
    '@param dst Image to store the Harris detector responses. It has the type '
    'CV_32FC1 and the same\n'
    'size as src .\n'
    '@param blockSize Neighborhood size (see the details on '
    '#cornerEigenValsAndVecs ).\n'
    '@param ksize Aperture parameter for the Sobel operator.\n'
    '@param k Harris detector free parameter. See the formula above.\n'
    '@param borderType Pixel extrapolation method. See #BorderTypes.']
parse_name: cv.cornerHarris with ['cv'] -> fullname:cv::cornerHarris namespace:cv classpath: classname: name:cornerHarris
register (function) cornerHarris (cv_cornerHarris__InputArray__OutputArray_int_int_double_int)

--- Incoming ---
[   'cv.cornerEigenValsAndVecs',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'blockSize', '', []],
        ['int', 'ksize', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates eigenvalues and eigenvectors of image blocks for corner '
    'detection.\n'
    '\n'
    'For every pixel \\f$p\\f$ , the function cornerEigenValsAndVecs considers '
    'a blockSize \\f$\\times\\f$ blockSize\n'
    'neighborhood \\f$S(p)\\f$ . It calculates the covariation matrix of '
    'derivatives over the neighborhood as:\n'
    '\n'
    '\\f[M =  \\begin{bmatrix} \\sum _{S(p)}(dI/dx)^2 &  \\sum _{S(p)}dI/dx '
    'dI/dy  \\\\ \\sum _{S(p)}dI/dx dI/dy &  \\sum _{S(p)}(dI/dy)^2 '
    '\\end{bmatrix}\\f]\n'
    '\n'
    'where the derivatives are computed using the Sobel operator.\n'
    '\n'
    'After that, it finds eigenvectors and eigenvalues of \\f$M\\f$ and stores '
    'them in the destination image as\n'
    '\\f$(\\lambda_1, \\lambda_2, x_1, y_1, x_2, y_2)\\f$ where\n'
    '\n'
    '-   \\f$\\lambda_1, \\lambda_2\\f$ are the non-sorted eigenvalues of '
    '\\f$M\\f$\n'
    '-   \\f$x_1, y_1\\f$ are the eigenvectors corresponding to '
    '\\f$\\lambda_1\\f$\n'
    '-   \\f$x_2, y_2\\f$ are the eigenvectors corresponding to '
    '\\f$\\lambda_2\\f$\n'
    '\n'
    'The output of the function can be used for robust edge or corner '
    'detection.\n'
    '\n'
    '@param src Input single-channel 8-bit or floating-point image.\n'
    '@param dst Image to store the results. It has the same size as src and '
    'the type CV_32FC(6) .\n'
    '@param blockSize Neighborhood size (see details below).\n'
    '@param ksize Aperture parameter for the Sobel operator.\n'
    '@param borderType Pixel extrapolation method. See #BorderTypes.\n'
    '\n'
    '@sa  cornerMinEigenVal, cornerHarris, preCornerDetect']
parse_name: cv.cornerEigenValsAndVecs with ['cv'] -> fullname:cv::cornerEigenValsAndVecs namespace:cv classpath: classname: name:cornerEigenValsAndVecs
register (function) cornerEigenValsAndVecs (cv_cornerEigenValsAndVecs__InputArray__OutputArray_int_int_int)

--- Incoming ---
[   'cv.preCornerDetect',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'ksize', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Calculates a feature map for corner detection.\n'
    '\n'
    'The function calculates the complex spatial derivative-based function of '
    'the source image\n'
    '\n'
    '\\f[\\texttt{dst} = (D_x  \\texttt{src} )^2  \\cdot D_{yy}  \\texttt{src} '
    '+ (D_y  \\texttt{src} )^2  \\cdot D_{xx}  \\texttt{src} - 2 D_x  '
    '\\texttt{src} \\cdot D_y  \\texttt{src} \\cdot D_{xy}  \\texttt{src}\\f]\n'
    '\n'
    'where \\f$D_x\\f$,\\f$D_y\\f$ are the first image derivatives, '
    '\\f$D_{xx}\\f$,\\f$D_{yy}\\f$ are the second image\n'
    'derivatives, and \\f$D_{xy}\\f$ is the mixed derivative.\n'
    '\n'
    'The corners can be found as local maximums of the functions, as shown '
    'below:\n'
    '@code\n'
    'Mat corners, dilated_corners;\n'
    'preCornerDetect(image, corners, 3);\n'
    '// dilation with 3x3 rectangular structuring element\n'
    'dilate(corners, dilated_corners, Mat(), 1);\n'
    'Mat corner_mask = corners == dilated_corners;\n'
    '@endcode\n'
    '\n'
    '@param src Source single-channel 8-bit of floating-point image.\n'
    '@param dst Output image that has the type CV_32F and the same size as src '
    '.\n'
    '@param ksize %Aperture size of the Sobel .\n'
    '@param borderType Pixel extrapolation method. See #BorderTypes.']
parse_name: cv.preCornerDetect with ['cv'] -> fullname:cv::preCornerDetect namespace:cv classpath: classname: name:preCornerDetect
register (function) preCornerDetect (cv_preCornerDetect__InputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.cornerSubPix',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['InputOutputArray', 'corners', '', []],
        ['Size', 'winSize', '', []],
        ['Size', 'zeroZone', '', []],
        ['TermCriteria', 'criteria', '', []]],
    None,
    '@brief Refines the corner locations.\n'
    '\n'
    'The function iterates to find the sub-pixel accurate location of corners '
    'or radial saddle points, as\n'
    'shown on the figure below.\n'
    '\n'
    '![image](pics/cornersubpix.png)\n'
    '\n'
    'Sub-pixel accurate corner locator is based on the observation that every '
    'vector from the center \\f$q\\f$\n'
    'to a point \\f$p\\f$ located within a neighborhood of \\f$q\\f$ is '
    'orthogonal to the image gradient at \\f$p\\f$\n'
    'subject to image and measurement noise. Consider the expression:\n'
    '\n'
    '\\f[\\epsilon _i = {DI_{p_i}}^T  \\cdot (q - p_i)\\f]\n'
    '\n'
    'where \\f${DI_{p_i}}\\f$ is an image gradient at one of the points '
    '\\f$p_i\\f$ in a neighborhood of \\f$q\\f$ . The\n'
    'value of \\f$q\\f$ is to be found so that \\f$\\epsilon_i\\f$ is '
    'minimized. A system of equations may be set up\n'
    'with \\f$\\epsilon_i\\f$ set to zero:\n'
    '\n'
    '\\f[\\sum _i(DI_{p_i}  \\cdot {DI_{p_i}}^T) \\cdot q -  \\sum '
    '_i(DI_{p_i}  \\cdot {DI_{p_i}}^T  \\cdot p_i)\\f]\n'
    '\n'
    'where the gradients are summed within a neighborhood ("search window") of '
    '\\f$q\\f$ . Calling the first\n'
    'gradient term \\f$G\\f$ and the second gradient term \\f$b\\f$ gives:\n'
    '\n'
    '\\f[q = G^{-1}  \\cdot b\\f]\n'
    '\n'
    'The algorithm sets the center of the neighborhood window at this new '
    'center \\f$q\\f$ and then iterates\n'
    'until the center stays within a set threshold.\n'
    '\n'
    '@param image Input single-channel, 8-bit or float image.\n'
    '@param corners Initial coordinates of the input corners and refined '
    'coordinates provided for\n'
    'output.\n'
    '@param winSize Half of the side length of the search window. For example, '
    'if winSize=Size(5,5) ,\n'
    'then a \\f$(5*2+1) \\times (5*2+1) = 11 \\times 11\\f$ search window is '
    'used.\n'
    '@param zeroZone Half of the size of the dead region in the middle of the '
    'search zone over which\n'
    'the summation in the formula below is not done. It is used sometimes to '
    'avoid possible\n'
    'singularities of the autocorrelation matrix. The value of (-1,-1) '
    'indicates that there is no such\n'
    'a size.\n'
    '@param criteria Criteria for termination of the iterative process of '
    'corner refinement. That is,\n'
    'the process of corner position refinement stops either after '
    'criteria.maxCount iterations or when\n'
    'the corner position moves by less than criteria.epsilon on some '
    'iteration.']
parse_name: cv.cornerSubPix with ['cv'] -> fullname:cv::cornerSubPix namespace:cv classpath: classname: name:cornerSubPix
register (function) cornerSubPix (cv_cornerSubPix__InputArray__InputOutputArray_Size_Size_TermCriteria)

--- Incoming ---
[   'cv.goodFeaturesToTrack',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'corners', '', []],
        ['int', 'maxCorners', '', []],
        ['double', 'qualityLevel', '', []],
        ['double', 'minDistance', '', []],
        ['InputArray', 'mask', 'noArray()', []],
        ['int', 'blockSize', '3', []],
        ['bool', 'useHarrisDetector', 'false', []],
        ['double', 'k', '0.04', []]],
    None,
    '@brief Determines strong corners on an image.\n'
    '\n'
    'The function finds the most prominent corners in the image or in the '
    'specified image region, as\n'
    'described in @cite Shi94\n'
    '\n'
    '-   Function calculates the corner quality measure at every source image '
    'pixel using the\n'
    '#cornerMinEigenVal or #cornerHarris .\n'
    '-   Function performs a non-maximum suppression (the local maximums in *3 '
    'x 3* neighborhood are\n'
    'retained).\n'
    '-   The corners with the minimal eigenvalue less than\n'
    '\\f$\\texttt{qualityLevel} \\cdot \\max_{x,y} qualityMeasureMap(x,y)\\f$ '
    'are rejected.\n'
    '-   The remaining corners are sorted by the quality measure in the '
    'descending order.\n'
    '-   Function throws away each corner for which there is a stronger corner '
    'at a distance less than\n'
    'maxDistance.\n'
    '\n'
    'The function can be used to initialize a point-based tracker of an '
    'object.\n'
    '\n'
    '@note If the function is called with different values A and B of the '
    'parameter qualityLevel , and\n'
    'A \\> B, the vector of returned corners with qualityLevel=A will be the '
    'prefix of the output vector\n'
    'with qualityLevel=B .\n'
    '\n'
    '@param image Input 8-bit or floating-point 32-bit, single-channel image.\n'
    '@param corners Output vector of detected corners.\n'
    '@param maxCorners Maximum number of corners to return. If there are more '
    'corners than are found,\n'
    'the strongest of them is returned. `maxCorners <= 0` implies that no '
    'limit on the maximum is set\n'
    'and all detected corners are returned.\n'
    '@param qualityLevel Parameter characterizing the minimal accepted quality '
    'of image corners. The\n'
    'parameter value is multiplied by the best corner quality measure, which '
    'is the minimal eigenvalue\n'
    '(see #cornerMinEigenVal ) or the Harris function response (see '
    '#cornerHarris ). The corners with the\n'
    'quality measure less than the product are rejected. For example, if the '
    'best corner has the\n'
    'quality measure = 1500, and the qualityLevel=0.01 , then all the corners '
    'with the quality measure\n'
    'less than 15 are rejected.\n'
    '@param minDistance Minimum possible Euclidean distance between the '
    'returned corners.\n'
    '@param mask Optional region of interest. If the image is not empty (it '
    'needs to have the type\n'
    'CV_8UC1 and the same size as image ), it specifies the region in which '
    'the corners are detected.\n'
    '@param blockSize Size of an average block for computing a derivative '
    'covariation matrix over each\n'
    'pixel neighborhood. See cornerEigenValsAndVecs .\n'
    '@param useHarrisDetector Parameter indicating whether to use a Harris '
    'detector (see #cornerHarris)\n'
    'or #cornerMinEigenVal.\n'
    '@param k Free parameter of the Harris detector.\n'
    '\n'
    '@sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, '
    'estimateRigidTransform,']
parse_name: cv.goodFeaturesToTrack with ['cv'] -> fullname:cv::goodFeaturesToTrack namespace:cv classpath: classname: name:goodFeaturesToTrack
register (function) goodFeaturesToTrack (cv_goodFeaturesToTrack__InputArray__OutputArray_int_double_double__InputArray_int_bool_double)

--- Incoming ---
[   'cv.goodFeaturesToTrack',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'corners', '', []],
        ['int', 'maxCorners', '', []],
        ['double', 'qualityLevel', '', []],
        ['double', 'minDistance', '', []],
        ['InputArray', 'mask', '', []],
        ['int', 'blockSize', '', []],
        ['int', 'gradientSize', '', []],
        ['bool', 'useHarrisDetector', 'false', []],
        ['double', 'k', '0.04', []]],
    None,
    '']
parse_name: cv.goodFeaturesToTrack with ['cv'] -> fullname:cv::goodFeaturesToTrack namespace:cv classpath: classname: name:goodFeaturesToTrack
register (function) goodFeaturesToTrack (cv_goodFeaturesToTrack__InputArray__OutputArray_int_double_double__InputArray_int_int_bool_double)

--- Incoming ---
[   'cv.HoughLines',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'lines', '', []],
        ['double', 'rho', '', []],
        ['double', 'theta', '', []],
        ['int', 'threshold', '', []],
        ['double', 'srn', '0', []],
        ['double', 'stn', '0', []],
        ['double', 'min_theta', '0', []],
        ['double', 'max_theta', 'CV_PI', []]],
    None,
    '@brief Finds lines in a binary image using the standard Hough transform.\n'
    '\n'
    'The function implements the standard or standard multi-scale Hough '
    'transform algorithm for line\n'
    'detection. See <http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm> for a '
    'good explanation of Hough\n'
    'transform.\n'
    '\n'
    '@param image 8-bit, single-channel binary source image. The image may be '
    'modified by the function.\n'
    '@param lines Output vector of lines. Each line is represented by a 2 or 3 '
    'element vector\n'
    '\\f$(\\rho, \\theta)\\f$ or \\f$(\\rho, \\theta, \\textrm{votes})\\f$ . '
    '\\f$\\rho\\f$ is the distance from the coordinate origin \\f$(0,0)\\f$ '
    '(top-left corner of\n'
    'the image). \\f$\\theta\\f$ is the line rotation angle in radians (\n'
    '\\f$0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal '
    'line}\\f$ ).\n'
    '\\f$\\textrm{votes}\\f$ is the value of accumulator.\n'
    '@param rho Distance resolution of the accumulator in pixels.\n'
    '@param theta Angle resolution of the accumulator in radians.\n'
    '@param threshold Accumulator threshold parameter. Only those lines are '
    'returned that get enough\n'
    'votes ( \\f$>\\texttt{threshold}\\f$ ).\n'
    '@param srn For the multi-scale Hough transform, it is a divisor for the '
    'distance resolution rho .\n'
    'The coarse accumulator distance resolution is rho and the accurate '
    'accumulator resolution is\n'
    'rho/srn . If both srn=0 and stn=0 , the classical Hough transform is '
    'used. Otherwise, both these\n'
    'parameters should be positive.\n'
    '@param stn For the multi-scale Hough transform, it is a divisor for the '
    'distance resolution theta.\n'
    '@param min_theta For standard and multi-scale Hough transform, minimum '
    'angle to check for lines.\n'
    'Must fall between 0 and max_theta.\n'
    '@param max_theta For standard and multi-scale Hough transform, maximum '
    'angle to check for lines.\n'
    'Must fall between min_theta and CV_PI.']
parse_name: cv.HoughLines with ['cv'] -> fullname:cv::HoughLines namespace:cv classpath: classname: name:HoughLines
register (function) HoughLines (cv_HoughLines__InputArray__OutputArray_double_double_int_double_double_double_double)

--- Incoming ---
[   'cv.HoughLinesP',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'lines', '', []],
        ['double', 'rho', '', []],
        ['double', 'theta', '', []],
        ['int', 'threshold', '', []],
        ['double', 'minLineLength', '0', []],
        ['double', 'maxLineGap', '0', []]],
    None,
    '@brief Finds line segments in a binary image using the probabilistic '
    'Hough transform.\n'
    '\n'
    'The function implements the probabilistic Hough transform algorithm for '
    'line detection, described\n'
    'in @cite Matas00\n'
    '\n'
    'See the line detection example below:\n'
    '@include snippets/imgproc_HoughLinesP.cpp\n'
    'This is a sample picture the function parameters have been tuned for:\n'
    '\n'
    '![image](pics/building.jpg)\n'
    '\n'
    'And this is the output of the above program in case of the probabilistic '
    'Hough transform:\n'
    '\n'
    '![image](pics/houghp.png)\n'
    '\n'
    '@param image 8-bit, single-channel binary source image. The image may be '
    'modified by the function.\n'
    '@param lines Output vector of lines. Each line is represented by a '
    '4-element vector\n'
    '\\f$(x_1, y_1, x_2, y_2)\\f$ , where \\f$(x_1,y_1)\\f$ and \\f$(x_2, '
    'y_2)\\f$ are the ending points of each detected\n'
    'line segment.\n'
    '@param rho Distance resolution of the accumulator in pixels.\n'
    '@param theta Angle resolution of the accumulator in radians.\n'
    '@param threshold Accumulator threshold parameter. Only those lines are '
    'returned that get enough\n'
    'votes ( \\f$>\\texttt{threshold}\\f$ ).\n'
    '@param minLineLength Minimum line length. Line segments shorter than that '
    'are rejected.\n'
    '@param maxLineGap Maximum allowed gap between points on the same line to '
    'link them.\n'
    '\n'
    '@sa LineSegmentDetector']
parse_name: cv.HoughLinesP with ['cv'] -> fullname:cv::HoughLinesP namespace:cv classpath: classname: name:HoughLinesP
register (function) HoughLinesP (cv_HoughLinesP__InputArray__OutputArray_double_double_int_double_double)

--- Incoming ---
[   'cv.HoughLinesPointSet',
    'void',
    [],
    [   ['InputArray', '_point', '', []],
        ['OutputArray', '_lines', '', []],
        ['int', 'lines_max', '', []],
        ['int', 'threshold', '', []],
        ['double', 'min_rho', '', []],
        ['double', 'max_rho', '', []],
        ['double', 'rho_step', '', []],
        ['double', 'min_theta', '', []],
        ['double', 'max_theta', '', []],
        ['double', 'theta_step', '', []]],
    None,
    '@brief Finds lines in a set of points using the standard Hough '
    'transform.\n'
    '\n'
    'The function finds lines in a set of points using a modification of the '
    'Hough transform.\n'
    '@include snippets/imgproc_HoughLinesPointSet.cpp\n'
    '@param _point Input vector of points. Each vector must be encoded as a '
    'Point vector \\f$(x,y)\\f$. Type must be CV_32FC2 or CV_32SC2.\n'
    '@param _lines Output vector of found lines. Each vector is encoded as a '
    'vector<Vec3d> \\f$(votes, rho, theta)\\f$.\n'
    "The larger the value of 'votes', the higher the reliability of the Hough "
    'line.\n'
    '@param lines_max Max count of hough lines.\n'
    '@param threshold Accumulator threshold parameter. Only those lines are '
    'returned that get enough\n'
    'votes ( \\f$>\\texttt{threshold}\\f$ )\n'
    '@param min_rho Minimum Distance value of the accumulator in pixels.\n'
    '@param max_rho Maximum Distance value of the accumulator in pixels.\n'
    '@param rho_step Distance resolution of the accumulator in pixels.\n'
    '@param min_theta Minimum angle value of the accumulator in radians.\n'
    '@param max_theta Maximum angle value of the accumulator in radians.\n'
    '@param theta_step Angle resolution of the accumulator in radians.']
parse_name: cv.HoughLinesPointSet with ['cv'] -> fullname:cv::HoughLinesPointSet namespace:cv classpath: classname: name:HoughLinesPointSet
register (function) HoughLinesPointSet (cv_HoughLinesPointSet__InputArray__OutputArray_int_int_double_double_double_double_double_double)

--- Incoming ---
[   'cv.HoughCircles',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'circles', '', []],
        ['int', 'method', '', []],
        ['double', 'dp', '', []],
        ['double', 'minDist', '', []],
        ['double', 'param1', '100', []],
        ['double', 'param2', '100', []],
        ['int', 'minRadius', '0', []],
        ['int', 'maxRadius', '0', []]],
    None,
    '@brief Finds circles in a grayscale image using the Hough transform.\n'
    '\n'
    'The function finds circles in a grayscale image using a modification of '
    'the Hough transform.\n'
    '\n'
    'Example: :\n'
    '@include snippets/imgproc_HoughLinesCircles.cpp\n'
    '\n'
    '@note Usually the function detects the centers of circles well. However, '
    'it may fail to find correct\n'
    'radii. You can assist to the function by specifying the radius range ( '
    'minRadius and maxRadius ) if\n'
    'you know it. Or, you may set maxRadius to a negative number to return '
    'centers only without radius\n'
    'search, and find the correct radius using an additional procedure.\n'
    '\n'
    '@param image 8-bit, single-channel, grayscale input image.\n'
    '@param circles Output vector of found circles. Each vector is encoded as  '
    '3 or 4 element\n'
    'floating-point vector \\f$(x, y, radius)\\f$ or \\f$(x, y, radius, '
    'votes)\\f$ .\n'
    '@param method Detection method, see #HoughModes. Currently, the only '
    'implemented method is #HOUGH_GRADIENT\n'
    '@param dp Inverse ratio of the accumulator resolution to the image '
    'resolution. For example, if\n'
    'dp=1 , the accumulator has the same resolution as the input image. If '
    'dp=2 , the accumulator has\n'
    'half as big width and height.\n'
    '@param minDist Minimum distance between the centers of the detected '
    'circles. If the parameter is\n'
    'too small, multiple neighbor circles may be falsely detected in addition '
    'to a true one. If it is\n'
    'too large, some circles may be missed.\n'
    '@param param1 First method-specific parameter. In case of #HOUGH_GRADIENT '
    ', it is the higher\n'
    'threshold of the two passed to the Canny edge detector (the lower one is '
    'twice smaller).\n'
    '@param param2 Second method-specific parameter. In case of '
    '#HOUGH_GRADIENT , it is the\n'
    'accumulator threshold for the circle centers at the detection stage. The '
    'smaller it is, the more\n'
    'false circles may be detected. Circles, corresponding to the larger '
    'accumulator values, will be\n'
    'returned first.\n'
    '@param minRadius Minimum circle radius.\n'
    '@param maxRadius Maximum circle radius. If <= 0, uses the maximum image '
    'dimension. If < 0, returns\n'
    'centers without finding the radius.\n'
    '\n'
    '@sa fitEllipse, minEnclosingCircle']
parse_name: cv.HoughCircles with ['cv'] -> fullname:cv::HoughCircles namespace:cv classpath: classname: name:HoughCircles
register (function) HoughCircles (cv_HoughCircles__InputArray__OutputArray_int_double_double_double_double_int_int)

--- Incoming ---
[   'cv.erode',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'iterations', '1', []],
        ['int', 'borderType', 'BORDER_CONSTANT', []],
        ['const Scalar&', 'borderValue', 'morphologyDefaultBorderValue()', []]],
    None,
    '@brief Erodes an image by using a specific structuring element.\n'
    '\n'
    'The function erodes the source image using the specified structuring '
    'element that determines the\n'
    'shape of a pixel neighborhood over which the minimum is taken:\n'
    '\n'
    "\\f[\\texttt{dst} (x,y) =  \\min _{(x',y'):  \\, \\texttt{element} "
    "(x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]\n"
    '\n'
    'The function supports the in-place mode. Erosion can be applied several ( '
    'iterations ) times. In\n'
    'case of multi-channel images, each channel is processed independently.\n'
    '\n'
    '@param src input image; the number of channels can be arbitrary, but the '
    'depth should be one of\n'
    'CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n'
    '@param dst output image of the same size and type as src.\n'
    '@param kernel structuring element used for erosion; if `element=Mat()`, a '
    '`3 x 3` rectangular\n'
    'structuring element is used. Kernel can be created using '
    '#getStructuringElement.\n'
    '@param anchor position of the anchor within the element; default value '
    '(-1, -1) means that the\n'
    'anchor is at the element center.\n'
    '@param iterations number of times erosion is applied.\n'
    '@param borderType pixel extrapolation method, see #BorderTypes\n'
    '@param borderValue border value in case of a constant border\n'
    '@sa  dilate, morphologyEx, getStructuringElement']
parse_name: cv.erode with ['cv'] -> fullname:cv::erode namespace:cv classpath: classname: name:erode
register (function) erode (cv_erode__InputArray__OutputArray__InputArray_Point_int_int_Scalar)

--- Incoming ---
[   'cv.dilate',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'iterations', '1', []],
        ['int', 'borderType', 'BORDER_CONSTANT', []],
        ['const Scalar&', 'borderValue', 'morphologyDefaultBorderValue()', []]],
    None,
    '@brief Dilates an image by using a specific structuring element.\n'
    '\n'
    'The function dilates the source image using the specified structuring '
    'element that determines the\n'
    'shape of a pixel neighborhood over which the maximum is taken:\n'
    "\\f[\\texttt{dst} (x,y) =  \\max _{(x',y'):  \\, \\texttt{element} "
    "(x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]\n"
    '\n'
    'The function supports the in-place mode. Dilation can be applied several '
    '( iterations ) times. In\n'
    'case of multi-channel images, each channel is processed independently.\n'
    '\n'
    '@param src input image; the number of channels can be arbitrary, but the '
    'depth should be one of\n'
    'CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n'
    '@param dst output image of the same size and type as src.\n'
    '@param kernel structuring element used for dilation; if elemenat=Mat(), a '
    '3 x 3 rectangular\n'
    'structuring element is used. Kernel can be created using '
    '#getStructuringElement\n'
    '@param anchor position of the anchor within the element; default value '
    '(-1, -1) means that the\n'
    'anchor is at the element center.\n'
    '@param iterations number of times dilation is applied.\n'
    '@param borderType pixel extrapolation method, see #BorderTypes\n'
    '@param borderValue border value in case of a constant border\n'
    '@sa  erode, morphologyEx, getStructuringElement']
parse_name: cv.dilate with ['cv'] -> fullname:cv::dilate namespace:cv classpath: classname: name:dilate
register (function) dilate (cv_dilate__InputArray__OutputArray__InputArray_Point_int_int_Scalar)

--- Incoming ---
[   'cv.morphologyEx',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'op', '', []],
        ['InputArray', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'iterations', '1', []],
        ['int', 'borderType', 'BORDER_CONSTANT', []],
        ['const Scalar&', 'borderValue', 'morphologyDefaultBorderValue()', []]],
    None,
    '@brief Performs advanced morphological transformations.\n'
    '\n'
    'The function cv::morphologyEx can perform advanced morphological '
    'transformations using an erosion and dilation as\n'
    'basic operations.\n'
    '\n'
    'Any of the operations can be done in-place. In case of multi-channel '
    'images, each channel is\n'
    'processed independently.\n'
    '\n'
    '@param src Source image. The number of channels can be arbitrary. The '
    'depth should be one of\n'
    'CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n'
    '@param dst Destination image of the same size and type as source image.\n'
    '@param op Type of a morphological operation, see #MorphTypes\n'
    '@param kernel Structuring element. It can be created using '
    '#getStructuringElement.\n'
    '@param anchor Anchor position with the kernel. Negative values mean that '
    'the anchor is at the\n'
    'kernel center.\n'
    '@param iterations Number of times erosion and dilation are applied.\n'
    '@param borderType Pixel extrapolation method, see #BorderTypes\n'
    '@param borderValue Border value in case of a constant border. The default '
    'value has a special\n'
    'meaning.\n'
    '@sa  dilate, erode, getStructuringElement\n'
    '@note The number of iterations is the number of times erosion or '
    'dilatation operation will be applied.\n'
    'For instance, an opening operation (#MORPH_OPEN) with two iterations is '
    'equivalent to apply\n'
    'successively: erode -> erode -> dilate -> dilate (and not erode -> dilate '
    '-> erode -> dilate).']
parse_name: cv.morphologyEx with ['cv'] -> fullname:cv::morphologyEx namespace:cv classpath: classname: name:morphologyEx
register (function) morphologyEx (cv_morphologyEx__InputArray__OutputArray_int__InputArray_Point_int_int_Scalar)

--- Incoming ---
[   'cv.resize',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['Size', 'dsize', '', []],
        ['double', 'fx', '0', []],
        ['double', 'fy', '0', []],
        ['int', 'interpolation', 'INTER_LINEAR', []]],
    None,
    '@brief Resizes an image.\n'
    '\n'
    'The function resize resizes the image src down to or up to the specified '
    'size. Note that the\n'
    'initial dst type or size are not taken into account. Instead, the size '
    'and type are derived from\n'
    'the `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it '
    'fits the pre-created dst,\n'
    'you may call the function as follows:\n'
    '@code\n'
    '// explicitly specify dsize=dst.size(); fx and fy will be computed from '
    'that.\n'
    'resize(src, dst, dst.size(), 0, 0, interpolation);\n'
    '@endcode\n'
    'If you want to decimate the image by factor of 2 in each direction, you '
    'can call the function this\n'
    'way:\n'
    '@code\n'
    '// specify fx and fy and let the function compute the destination image '
    'size.\n'
    'resize(src, dst, Size(), 0.5, 0.5, interpolation);\n'
    '@endcode\n'
    'To shrink an image, it will generally look best with #INTER_AREA '
    'interpolation, whereas to\n'
    'enlarge an image, it will generally look best with c#INTER_CUBIC (slow) '
    'or #INTER_LINEAR\n'
    '(faster but still looks OK).\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image; it has the size dsize (when it is non-zero) or '
    'the size computed from\n'
    'src.size(), fx, and fy; the type of dst is the same as of src.\n'
    '@param dsize output image size; if it equals zero, it is computed as:\n'
    '\\f[\\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\\f]\n'
    'Either dsize or both fx and fy must be non-zero.\n'
    '@param fx scale factor along the horizontal axis; when it equals 0, it is '
    'computed as\n'
    '\\f[\\texttt{(double)dsize.width/src.cols}\\f]\n'
    '@param fy scale factor along the vertical axis; when it equals 0, it is '
    'computed as\n'
    '\\f[\\texttt{(double)dsize.height/src.rows}\\f]\n'
    '@param interpolation interpolation method, see #InterpolationFlags\n'
    '\n'
    '@sa  warpAffine, warpPerspective, remap']
parse_name: cv.resize with ['cv'] -> fullname:cv::resize namespace:cv classpath: classname: name:resize
register (function) resize (cv_resize__InputArray__OutputArray_Size_double_double_int)

--- Incoming ---
[   'cv.warpAffine',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'M', '', []],
        ['Size', 'dsize', '', []],
        ['int', 'flags', 'INTER_LINEAR', []],
        ['int', 'borderMode', 'BORDER_CONSTANT', []],
        ['const Scalar&', 'borderValue', 'Scalar()', []]],
    None,
    '@brief Applies an affine transformation to an image.\n'
    '\n'
    'The function warpAffine transforms the source image using the specified '
    'matrix:\n'
    '\n'
    '\\f[\\texttt{dst} (x,y) =  \\texttt{src} ( \\texttt{M} _{11} x +  '
    '\\texttt{M} _{12} y +  \\texttt{M} _{13}, \\texttt{M} _{21} x +  '
    '\\texttt{M} _{22} y +  \\texttt{M} _{23})\\f]\n'
    '\n'
    'when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is '
    'first inverted\n'
    'with #invertAffineTransform and then put in the formula above instead of '
    'M. The function cannot\n'
    'operate in-place.\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image that has the size dsize and the same type as src '
    '.\n'
    '@param M \\f$2\\times 3\\f$ transformation matrix.\n'
    '@param dsize size of the output image.\n'
    '@param flags combination of interpolation methods (see '
    '#InterpolationFlags) and the optional\n'
    'flag #WARP_INVERSE_MAP that means that M is the inverse transformation (\n'
    '\\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).\n'
    '@param borderMode pixel extrapolation method (see #BorderTypes); when\n'
    'borderMode=#BORDER_TRANSPARENT, it means that the pixels in the '
    'destination image corresponding to\n'
    'the "outliers" in the source image are not modified by the function.\n'
    '@param borderValue value used in case of a constant border; by default, '
    'it is 0.\n'
    '\n'
    '@sa  warpPerspective, resize, remap, getRectSubPix, transform']
parse_name: cv.warpAffine with ['cv'] -> fullname:cv::warpAffine namespace:cv classpath: classname: name:warpAffine
register (function) warpAffine (cv_warpAffine__InputArray__OutputArray__InputArray_Size_int_int_Scalar)

--- Incoming ---
[   'cv.warpPerspective',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'M', '', []],
        ['Size', 'dsize', '', []],
        ['int', 'flags', 'INTER_LINEAR', []],
        ['int', 'borderMode', 'BORDER_CONSTANT', []],
        ['const Scalar&', 'borderValue', 'Scalar()', []]],
    None,
    '@brief Applies a perspective transformation to an image.\n'
    '\n'
    'The function warpPerspective transforms the source image using the '
    'specified matrix:\n'
    '\n'
    '\\f[\\texttt{dst} (x,y) =  \\texttt{src} \\left ( \\frac{M_{11} x + '
    'M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,\n'
    '\\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} '
    '\\right )\\f]\n'
    '\n'
    'when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is '
    'first inverted with invert\n'
    'and then put in the formula above instead of M. The function cannot '
    'operate in-place.\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image that has the size dsize and the same type as src '
    '.\n'
    '@param M \\f$3\\times 3\\f$ transformation matrix.\n'
    '@param dsize size of the output image.\n'
    '@param flags combination of interpolation methods (#INTER_LINEAR or '
    '#INTER_NEAREST) and the\n'
    'optional flag #WARP_INVERSE_MAP, that sets M as the inverse '
    'transformation (\n'
    '\\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).\n'
    '@param borderMode pixel extrapolation method (#BORDER_CONSTANT or '
    '#BORDER_REPLICATE).\n'
    '@param borderValue value used in case of a constant border; by default, '
    'it equals 0.\n'
    '\n'
    '@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform']
parse_name: cv.warpPerspective with ['cv'] -> fullname:cv::warpPerspective namespace:cv classpath: classname: name:warpPerspective
register (function) warpPerspective (cv_warpPerspective__InputArray__OutputArray__InputArray_Size_int_int_Scalar)

--- Incoming ---
[   'cv.remap',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'map1', '', []],
        ['InputArray', 'map2', '', []],
        ['int', 'interpolation', '', []],
        ['int', 'borderMode', 'BORDER_CONSTANT', []],
        ['const Scalar&', 'borderValue', 'Scalar()', []]],
    None,
    '@brief Applies a generic geometrical transformation to an image.\n'
    '\n'
    'The function remap transforms the source image using the specified map:\n'
    '\n'
    '\\f[\\texttt{dst} (x,y) =  \\texttt{src} (map_x(x,y),map_y(x,y))\\f]\n'
    '\n'
    'where values of pixels with non-integer coordinates are computed using '
    'one of available\n'
    'interpolation methods. \\f$map_x\\f$ and \\f$map_y\\f$ can be encoded as '
    'separate floating-point maps\n'
    'in \\f$map_1\\f$ and \\f$map_2\\f$ respectively, or interleaved '
    'floating-point maps of \\f$(x,y)\\f$ in\n'
    '\\f$map_1\\f$, or fixed-point maps created by using convertMaps. The '
    'reason you might want to\n'
    'convert from floating to fixed-point representations of a map is that '
    'they can yield much faster\n'
    '(\\~2x) remapping operations. In the converted case, \\f$map_1\\f$ '
    'contains pairs (cvFloor(x),\n'
    'cvFloor(y)) and \\f$map_2\\f$ contains indices in a table of '
    'interpolation coefficients.\n'
    '\n'
    'This function cannot operate in-place.\n'
    '\n'
    '@param src Source image.\n'
    '@param dst Destination image. It has the same size as map1 and the same '
    'type as src .\n'
    '@param map1 The first map of either (x,y) points or just x values having '
    'the type CV_16SC2 ,\n'
    'CV_32FC1, or CV_32FC2. See convertMaps for details on converting a '
    'floating point\n'
    'representation to fixed-point for speed.\n'
    '@param map2 The second map of y values having the type CV_16UC1, '
    'CV_32FC1, or none (empty map\n'
    'if map1 is (x,y) points), respectively.\n'
    '@param interpolation Interpolation method (see #InterpolationFlags). The '
    'method #INTER_AREA is\n'
    'not supported by this function.\n'
    '@param borderMode Pixel extrapolation method (see #BorderTypes). When\n'
    'borderMode=#BORDER_TRANSPARENT, it means that the pixels in the '
    'destination image that\n'
    'corresponds to the "outliers" in the source image are not modified by the '
    'function.\n'
    '@param borderValue Value used in case of a constant border. By default, '
    'it is 0.\n'
    '@note\n'
    'Due to current implementation limitations the size of an input and output '
    'images should be less than 32767x32767.']
parse_name: cv.remap with ['cv'] -> fullname:cv::remap namespace:cv classpath: classname: name:remap
register (function) remap (cv_remap__InputArray__OutputArray__InputArray__InputArray_int_int_Scalar)

--- Incoming ---
[   'cv.convertMaps',
    'void',
    [],
    [   ['InputArray', 'map1', '', []],
        ['InputArray', 'map2', '', []],
        ['OutputArray', 'dstmap1', '', []],
        ['OutputArray', 'dstmap2', '', []],
        ['int', 'dstmap1type', '', []],
        ['bool', 'nninterpolation', 'false', []]],
    None,
    '@brief Converts image transformation maps from one representation to '
    'another.\n'
    '\n'
    'The function converts a pair of maps for remap from one representation to '
    'another. The following\n'
    'options ( (map1.type(), map2.type()) \\f$\\rightarrow\\f$ '
    '(dstmap1.type(), dstmap2.type()) ) are\n'
    'supported:\n'
    '\n'
    '- \\f$\\texttt{(CV_32FC1, CV_32FC1)} \\rightarrow \\texttt{(CV_16SC2, '
    'CV_16UC1)}\\f$. This is the\n'
    'most frequently used conversion operation, in which the original '
    'floating-point maps (see remap )\n'
    'are converted to a more compact and much faster fixed-point '
    'representation. The first output array\n'
    'contains the rounded coordinates and the second array (created only when '
    'nninterpolation=false )\n'
    'contains indices in the interpolation tables.\n'
    '\n'
    '- \\f$\\texttt{(CV_32FC2)} \\rightarrow \\texttt{(CV_16SC2, '
    'CV_16UC1)}\\f$. The same as above but\n'
    'the original maps are stored in one 2-channel matrix.\n'
    '\n'
    '- Reverse conversion. Obviously, the reconstructed floating-point maps '
    'will not be exactly the same\n'
    'as the originals.\n'
    '\n'
    '@param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 '
    '.\n'
    '@param map2 The second input map of type CV_16UC1, CV_32FC1, or none '
    '(empty matrix),\n'
    'respectively.\n'
    '@param dstmap1 The first output map that has the type dstmap1type and the '
    'same size as src .\n'
    '@param dstmap2 The second output map.\n'
    '@param dstmap1type Type of the first output map that should be CV_16SC2, '
    'CV_32FC1, or\n'
    'CV_32FC2 .\n'
    '@param nninterpolation Flag indicating whether the fixed-point maps are '
    'used for the\n'
    'nearest-neighbor or for a more complex interpolation.\n'
    '\n'
    '@sa  remap, undistort, initUndistortRectifyMap']
parse_name: cv.convertMaps with ['cv'] -> fullname:cv::convertMaps namespace:cv classpath: classname: name:convertMaps
register (function) convertMaps (cv_convertMaps__InputArray__InputArray__OutputArray__OutputArray_int_bool)

--- Incoming ---
[   'cv.getRotationMatrix2D',
    'Mat',
    [],
    [   ['Point2f', 'center', '', []],
        ['double', 'angle', '', []],
        ['double', 'scale', '', []]],
    None,
    '@brief Calculates an affine matrix of 2D rotation.\n'
    '\n'
    'The function calculates the following matrix:\n'
    '\n'
    '\\f[\\begin{bmatrix} \\alpha &  \\beta & (1- \\alpha )  \\cdot '
    '\\texttt{center.x} -  \\beta \\cdot \\texttt{center.y} \\\\ - \\beta &  '
    '\\alpha &  \\beta \\cdot \\texttt{center.x} + (1- \\alpha )  \\cdot '
    '\\texttt{center.y} \\end{bmatrix}\\f]\n'
    '\n'
    'where\n'
    '\n'
    '\\f[\\begin{array}{l} \\alpha =  \\texttt{scale} \\cdot \\cos '
    '\\texttt{angle} , \\\\ \\beta =  \\texttt{scale} \\cdot \\sin '
    '\\texttt{angle} \\end{array}\\f]\n'
    '\n'
    'The transformation maps the rotation center to itself. If this is not the '
    'target, adjust the shift.\n'
    '\n'
    '@param center Center of the rotation in the source image.\n'
    '@param angle Rotation angle in degrees. Positive values mean '
    'counter-clockwise rotation (the\n'
    'coordinate origin is assumed to be the top-left corner).\n'
    '@param scale Isotropic scale factor.\n'
    '\n'
    '@sa  getAffineTransform, warpAffine, transform']
parse_name: cv.getRotationMatrix2D with ['cv'] -> fullname:cv::getRotationMatrix2D namespace:cv classpath: classname: name:getRotationMatrix2D
register (function) getRotationMatrix2D (cv_getRotationMatrix2D_Point2f_double_double)

--- Incoming ---
[   'cv.getAffineTransform',
    'Mat',
    [],
    [['const Point2f[]', 'src', '', []], ['const Point2f[]', 'dst', '', []]],
    None,
    '@brief Calculates an affine transform from three pairs of the '
    'corresponding points.\n'
    '\n'
    'The function calculates the \\f$2 \\times 3\\f$ matrix of an affine '
    'transform so that:\n'
    '\n'
    "\\f[\\begin{bmatrix} x'_i \\\\ y'_i \\end{bmatrix} = \\texttt{map_matrix} "
    '\\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\f]\n'
    '\n'
    'where\n'
    '\n'
    "\\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2\\f]\n"
    '\n'
    '@param src Coordinates of triangle vertices in the source image.\n'
    '@param dst Coordinates of the corresponding triangle vertices in the '
    'destination image.\n'
    '\n'
    '@sa  warpAffine, transform']
parse_name: cv.getAffineTransform with ['cv'] -> fullname:cv::getAffineTransform namespace:cv classpath: classname: name:getAffineTransform
register (function) getAffineTransform (cv_getAffineTransform_const_Point2f_X_const_Point2f_X)

--- Incoming ---
[   'cv.invertAffineTransform',
    'void',
    [],
    [['InputArray', 'M', '', []], ['OutputArray', 'iM', '', []]],
    None,
    '@brief Inverts an affine transformation.\n'
    '\n'
    'The function computes an inverse affine transformation represented by '
    '\\f$2 \\times 3\\f$ matrix M:\n'
    '\n'
    '\\f[\\begin{bmatrix} a_{11} & a_{12} & b_1  \\\\ a_{21} & a_{22} & b_2 '
    '\\end{bmatrix}\\f]\n'
    '\n'
    'The result is also a \\f$2 \\times 3\\f$ matrix of the same type as M.\n'
    '\n'
    '@param M Original affine transformation.\n'
    '@param iM Output reverse affine transformation.']
parse_name: cv.invertAffineTransform with ['cv'] -> fullname:cv::invertAffineTransform namespace:cv classpath: classname: name:invertAffineTransform
register (function) invertAffineTransform (cv_invertAffineTransform__InputArray__OutputArray)

--- Incoming ---
[   'cv.getPerspectiveTransform',
    'Mat',
    [],
    [   ['InputArray', 'src', '', []],
        ['InputArray', 'dst', '', []],
        ['int', 'solveMethod', 'DECOMP_LU', []]],
    None,
    '@brief Calculates a perspective transform from four pairs of the '
    'corresponding points.\n'
    '\n'
    'The function calculates the \\f$3 \\times 3\\f$ matrix of a perspective '
    'transform so that:\n'
    '\n'
    "\\f[\\begin{bmatrix} t_i x'_i \\\\ t_i y'_i \\\\ t_i \\end{bmatrix} = "
    '\\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 '
    '\\end{bmatrix}\\f]\n'
    '\n'
    'where\n'
    '\n'
    "\\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\\f]\n"
    '\n'
    '@param src Coordinates of quadrangle vertices in the source image.\n'
    '@param dst Coordinates of the corresponding quadrangle vertices in the '
    'destination image.\n'
    '@param solveMethod method passed to cv::solve (#DecompTypes)\n'
    '\n'
    '@sa  findHomography, warpPerspective, perspectiveTransform']
parse_name: cv.getPerspectiveTransform with ['cv'] -> fullname:cv::getPerspectiveTransform namespace:cv classpath: classname: name:getPerspectiveTransform
register (function) getPerspectiveTransform (cv_getPerspectiveTransform__InputArray__InputArray_int)

--- Incoming ---
[   'cv.getPerspectiveTransform',
    'Mat',
    [],
    [   ['const Point2f[]', 'src', '', []],
        ['const Point2f[]', 'dst', '', []],
        ['int', 'solveMethod', 'DECOMP_LU', []]],
    None,
    '@overload']
parse_name: cv.getPerspectiveTransform with ['cv'] -> fullname:cv::getPerspectiveTransform namespace:cv classpath: classname: name:getPerspectiveTransform
register (function) getPerspectiveTransform (cv_getPerspectiveTransform_const_Point2f_X_const_Point2f_X_int)

--- Incoming ---
[   'cv.getAffineTransform',
    'Mat',
    [],
    [['InputArray', 'src', '', []], ['InputArray', 'dst', '', []]],
    None,
    '']
parse_name: cv.getAffineTransform with ['cv'] -> fullname:cv::getAffineTransform namespace:cv classpath: classname: name:getAffineTransform
register (function) getAffineTransform (cv_getAffineTransform__InputArray__InputArray)

--- Incoming ---
[   'cv.getRectSubPix',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['Size', 'patchSize', '', []],
        ['Point2f', 'center', '', []],
        ['OutputArray', 'patch', '', []],
        ['int', 'patchType', '-1', []]],
    None,
    '@brief Retrieves a pixel rectangle from an image with sub-pixel '
    'accuracy.\n'
    '\n'
    'The function getRectSubPix extracts pixels from src:\n'
    '\n'
    '\\f[patch(x, y) = src(x +  \\texttt{center.x} - ( \\texttt{dst.cols} '
    '-1)*0.5, y +  \\texttt{center.y} - ( \\texttt{dst.rows} -1)*0.5)\\f]\n'
    '\n'
    'where the values of the pixels at non-integer coordinates are retrieved '
    'using bilinear\n'
    'interpolation. Every channel of multi-channel images is processed '
    'independently. Also\n'
    'the image should be a single channel or three channel image. While the '
    'center of the\n'
    'rectangle must be inside the image, parts of the rectangle may be '
    'outside.\n'
    '\n'
    '@param image Source image.\n'
    '@param patchSize Size of the extracted patch.\n'
    '@param center Floating point coordinates of the center of the extracted '
    'rectangle within the\n'
    'source image. The center must be inside the image.\n'
    '@param patch Extracted patch that has the size patchSize and the same '
    'number of channels as src .\n'
    '@param patchType Depth of the extracted pixels. By default, they have the '
    'same depth as src .\n'
    '\n'
    '@sa  warpAffine, warpPerspective']
parse_name: cv.getRectSubPix with ['cv'] -> fullname:cv::getRectSubPix namespace:cv classpath: classname: name:getRectSubPix
register (function) getRectSubPix (cv_getRectSubPix__InputArray_Size_Point2f__OutputArray_int)

--- Incoming ---
[   'cv.logPolar',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['Point2f', 'center', '', []],
        ['double', 'M', '', []],
        ['int', 'flags', '', []]],
    None,
    '@brief Remaps an image to semilog-polar coordinates space.\n'
    '\n'
    '@deprecated This function produces same result as cv::warpPolar(src, dst, '
    'src.size(), center, maxRadius, flags+WARP_POLAR_LOG);\n'
    '\n'
    '@internal\n'
    'Transform the source image using the following transformation (See @ref '
    'polar_remaps_reference_image "Polar remaps reference image d)"):\n'
    '\\f[\\begin{array}{l}\n'
    'dst( \\rho , \\phi ) = src(x,y) \\\\\n'
    'dst.size() \\leftarrow src.size()\n'
    '\\end{array}\\f]\n'
    '\n'
    'where\n'
    '\\f[\\begin{array}{l}\n'
    'I = (dx,dy) = (x - center.x,y - center.y) \\\\\n'
    '\\rho = M \\cdot log_e(\\texttt{magnitude} (I)) ,\\\\\n'
    '\\phi = Kangle \\cdot \\texttt{angle} (I) \\\\\n'
    '\\end{array}\\f]\n'
    '\n'
    'and\n'
    '\\f[\\begin{array}{l}\n'
    'M = src.cols / log_e(maxRadius) \\\\\n'
    'Kangle = src.rows / 2\\Pi \\\\\n'
    '\\end{array}\\f]\n'
    '\n'
    'The function emulates the human "foveal" vision and can be used for fast '
    'scale and\n'
    'rotation-invariant template matching, for object tracking and so forth.\n'
    '@param src Source image\n'
    '@param dst Destination image. It will have same size and type as src.\n'
    '@param center The transformation center; where the output precision is '
    'maximal\n'
    '@param M Magnitude scale parameter. It determines the radius of the '
    'bounding circle to transform too.\n'
    '@param flags A combination of interpolation methods, see '
    '#InterpolationFlags\n'
    '\n'
    '@note\n'
    '-   The function can not operate in-place.\n'
    '-   To calculate magnitude and angle in degrees #cartToPolar is used '
    'internally thus angles are measured from 0 to 360 with accuracy about 0.3 '
    'degrees.\n'
    '\n'
    '@sa cv::linearPolar\n'
    '@endinternal']
parse_name: cv.logPolar with ['cv'] -> fullname:cv::logPolar namespace:cv classpath: classname: name:logPolar
register (function) logPolar (cv_logPolar__InputArray__OutputArray_Point2f_double_int)

--- Incoming ---
[   'cv.linearPolar',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['Point2f', 'center', '', []],
        ['double', 'maxRadius', '', []],
        ['int', 'flags', '', []]],
    None,
    '@brief Remaps an image to polar coordinates space.\n'
    '\n'
    '@deprecated This function produces same result as cv::warpPolar(src, dst, '
    'src.size(), center, maxRadius, flags)\n'
    '\n'
    '@internal\n'
    'Transform the source image using the following transformation (See @ref '
    'polar_remaps_reference_image "Polar remaps reference image c)"):\n'
    '\\f[\\begin{array}{l}\n'
    'dst( \\rho , \\phi ) = src(x,y) \\\\\n'
    'dst.size() \\leftarrow src.size()\n'
    '\\end{array}\\f]\n'
    '\n'
    'where\n'
    '\\f[\\begin{array}{l}\n'
    'I = (dx,dy) = (x - center.x,y - center.y) \\\\\n'
    '\\rho = Kmag \\cdot \\texttt{magnitude} (I) ,\\\\\n'
    '\\phi = angle \\cdot \\texttt{angle} (I)\n'
    '\\end{array}\\f]\n'
    '\n'
    'and\n'
    '\\f[\\begin{array}{l}\n'
    'Kx = src.cols / maxRadius \\\\\n'
    'Ky = src.rows / 2\\Pi\n'
    '\\end{array}\\f]\n'
    '\n'
    '\n'
    '@param src Source image\n'
    '@param dst Destination image. It will have same size and type as src.\n'
    '@param center The transformation center;\n'
    '@param maxRadius The radius of the bounding circle to transform. It '
    'determines the inverse magnitude scale parameter too.\n'
    '@param flags A combination of interpolation methods, see '
    '#InterpolationFlags\n'
    '\n'
    '@note\n'
    '-   The function can not operate in-place.\n'
    '-   To calculate magnitude and angle in degrees #cartToPolar is used '
    'internally thus angles are measured from 0 to 360 with accuracy about 0.3 '
    'degrees.\n'
    '\n'
    '@sa cv::logPolar\n'
    '@endinternal']
parse_name: cv.linearPolar with ['cv'] -> fullname:cv::linearPolar namespace:cv classpath: classname: name:linearPolar
register (function) linearPolar (cv_linearPolar__InputArray__OutputArray_Point2f_double_int)

--- Incoming ---
[   'cv.warpPolar',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['Size', 'dsize', '', []],
        ['Point2f', 'center', '', []],
        ['double', 'maxRadius', '', []],
        ['int', 'flags', '', []]],
    None,
    '\\brief Remaps an image to polar or semilog-polar coordinates space\n'
    '\n'
    '@anchor polar_remaps_reference_image\n'
    '![Polar remaps reference](pics/polar_remap_doc.png)\n'
    '\n'
    'Transform the source image using the following transformation:\n'
    '\\f[\n'
    'dst(\\rho , \\phi ) = src(x,y)\n'
    '\\f]\n'
    '\n'
    'where\n'
    '\\f[\n'
    '\\begin{array}{l}\n'
    '\\vec{I} = (x - center.x, \\;y - center.y) \\\\\n'
    '\\phi = Kangle \\cdot \\texttt{angle} (\\vec{I}) \\\\\n'
    '\\rho = \\left\\{\\begin{matrix}\n'
    'Klin \\cdot \\texttt{magnitude} (\\vec{I}) & default \\\\\n'
    'Klog \\cdot log_e(\\texttt{magnitude} (\\vec{I})) & if \\; semilog \\\\\n'
    '\\end{matrix}\\right.\n'
    '\\end{array}\n'
    '\\f]\n'
    '\n'
    'and\n'
    '\\f[\n'
    '\\begin{array}{l}\n'
    'Kangle = dsize.height / 2\\Pi \\\\\n'
    'Klin = dsize.width / maxRadius \\\\\n'
    'Klog = dsize.width / log_e(maxRadius) \\\\\n'
    '\\end{array}\n'
    '\\f]\n'
    '\n'
    '\n'
    '\\par Linear vs semilog mapping\n'
    '\n'
    'Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to '
    '`flags` to specify the polar mapping mode.\n'
    '\n'
    'Linear is the default mode.\n'
    '\n'
    'The semilog mapping emulates the human "foveal" vision that permit very '
    'high acuity on the line of sight (central vision)\n'
    'in contrast to peripheral vision where acuity is minor.\n'
    '\n'
    '\\par Option on `dsize`:\n'
    '\n'
    '- if both values in `dsize <=0 ` (default),\n'
    'the destination image will have (almost) same area of source bounding '
    'circle:\n'
    '\\f[\\begin{array}{l}\n'
    'dsize.area  \\leftarrow (maxRadius^2 \\cdot \\Pi) \\\\\n'
    'dsize.width = \\texttt{cvRound}(maxRadius) \\\\\n'
    'dsize.height = \\texttt{cvRound}(maxRadius \\cdot \\Pi) \\\\\n'
    '\\end{array}\\f]\n'
    '\n'
    '\n'
    '- if only `dsize.height <= 0`,\n'
    'the destination image area will be proportional to the bounding circle '
    'area but scaled by `Kx * Kx`:\n'
    '\\f[\\begin{array}{l}\n'
    'dsize.height = \\texttt{cvRound}(dsize.width \\cdot \\Pi) \\\\\n'
    '\\end{array}\n'
    '\\f]\n'
    '\n'
    '- if both values in `dsize > 0 `,\n'
    'the destination image will have the given size therefore the area of the '
    'bounding circle will be scaled to `dsize`.\n'
    '\n'
    '\n'
    '\\par Reverse mapping\n'
    '\n'
    'You can get reverse mapping adding #WARP_INVERSE_MAP to `flags`\n'
    '\\snippet polar_transforms.cpp InverseMap\n'
    '\n'
    'In addiction, to calculate the original coordinate from a polar mapped '
    'coordinate \\f$(rho, phi)->(x, y)\\f$:\n'
    '\\snippet polar_transforms.cpp InverseCoordinate\n'
    '\n'
    '@param src Source image.\n'
    '@param dst Destination image. It will have same type as src.\n'
    '@param dsize The destination image size (see description for valid '
    'options).\n'
    '@param center The transformation center.\n'
    '@param maxRadius The radius of the bounding circle to transform. It '
    'determines the inverse magnitude scale parameter too.\n'
    '@param flags A combination of interpolation methods, #InterpolationFlags '
    '+ #WarpPolarMode.\n'
    '- Add #WARP_POLAR_LINEAR to select linear polar mapping (default)\n'
    '- Add #WARP_POLAR_LOG to select semilog polar mapping\n'
    '- Add #WARP_INVERSE_MAP for reverse mapping.\n'
    '@note\n'
    '-  The function can not operate in-place.\n'
    '-  To calculate magnitude and angle in degrees #cartToPolar is used '
    'internally thus angles are measured from 0 to 360 with accuracy about 0.3 '
    'degrees.\n'
    '-  This function uses #remap. Due to current implementation limitations '
    'the size of an input and output images should be less than 32767x32767.\n'
    '\n'
    '@sa cv::remap']
parse_name: cv.warpPolar with ['cv'] -> fullname:cv::warpPolar namespace:cv classpath: classname: name:warpPolar
register (function) warpPolar (cv_warpPolar__InputArray__OutputArray_Size_Point2f_double_int)

--- Incoming ---
[   'cv.integral',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'sum', '', []],
        ['int', 'sdepth', '-1', []]],
    None,
    '@overload']
parse_name: cv.integral with ['cv'] -> fullname:cv::integral namespace:cv classpath: classname: name:integral
register (function) integral (cv_integral__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.integral',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'sum', '', []],
        ['OutputArray', 'sqsum', '', []],
        ['int', 'sdepth', '-1', []],
        ['int', 'sqdepth', '-1', []]],
    None,
    '@overload']
parse_name: cv.integral with ['cv'] -> fullname:cv::integral namespace:cv classpath: classname: name:integral
register (function) integral (cv_integral__InputArray__OutputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.integral',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'sum', '', []],
        ['OutputArray', 'sqsum', '', []],
        ['OutputArray', 'tilted', '', []],
        ['int', 'sdepth', '-1', []],
        ['int', 'sqdepth', '-1', []]],
    None,
    '@brief Calculates the integral of an image.\n'
    '\n'
    'The function calculates one or more integral images for the source image '
    'as follows:\n'
    '\n'
    '\\f[\\texttt{sum} (X,Y) =  \\sum _{x<X,y<Y}  \\texttt{image} (x,y)\\f]\n'
    '\n'
    '\\f[\\texttt{sqsum} (X,Y) =  \\sum _{x<X,y<Y}  \\texttt{image} '
    '(x,y)^2\\f]\n'
    '\n'
    '\\f[\\texttt{tilted} (X,Y) =  \\sum _{y<Y,abs(x-X+1) \\leq Y-y-1}  '
    '\\texttt{image} (x,y)\\f]\n'
    '\n'
    'Using these integral images, you can calculate sum, mean, and standard '
    'deviation over a specific\n'
    'up-right or rotated rectangular region of the image in a constant time, '
    'for example:\n'
    '\n'
    '\\f[\\sum _{x_1 \\leq x < x_2,  \\, y_1  \\leq y < y_2}  \\texttt{image} '
    '(x,y) =  \\texttt{sum} (x_2,y_2)- \\texttt{sum} (x_1,y_2)- \\texttt{sum} '
    '(x_2,y_1)+ \\texttt{sum} (x_1,y_1)\\f]\n'
    '\n'
    'It makes possible to do a fast blurring or fast block correlation with a '
    'variable window size, for\n'
    'example. In case of multi-channel images, sums for each channel are '
    'accumulated independently.\n'
    '\n'
    'As a practical example, the next figure shows the calculation of the '
    'integral of a straight\n'
    'rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The '
    'selected pixels in the\n'
    'original image are shown, as well as the relative pixels in the integral '
    'images sum and tilted .\n'
    '\n'
    '![integral calculation example](pics/integral.png)\n'
    '\n'
    '@param src input image as \\f$W \\times H\\f$, 8-bit or floating-point '
    '(32f or 64f).\n'
    '@param sum integral image as \\f$(W+1)\\times (H+1)\\f$ , 32-bit integer '
    'or floating-point (32f or 64f).\n'
    '@param sqsum integral image for squared pixel values; it is '
    '\\f$(W+1)\\times (H+1)\\f$, double-precision\n'
    'floating-point (64f) array.\n'
    '@param tilted integral for the image rotated by 45 degrees; it is '
    '\\f$(W+1)\\times (H+1)\\f$ array with\n'
    'the same data type as sum.\n'
    '@param sdepth desired depth of the integral and the tilted integral '
    'images, CV_32S, CV_32F, or\n'
    'CV_64F.\n'
    '@param sqdepth desired depth of the integral image of squared pixel '
    'values, CV_32F or CV_64F.']
parse_name: cv.integral with ['cv'] -> fullname:cv::integral namespace:cv classpath: classname: name:integral
register (function) integral (cv_integral__InputArray__OutputArray__OutputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.accumulate',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['InputOutputArray', 'dst', '', []],
        ['InputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Adds an image to the accumulator image.\n'
    '\n'
    'The function adds src or some of its elements to dst :\n'
    '\n'
    '\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} '
    '(x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n'
    '\n'
    'The function supports multi-channel images. Each channel is processed '
    'independently.\n'
    '\n'
    'The function cv::accumulate can be used, for example, to collect '
    'statistics of a scene background\n'
    'viewed by a still camera and for the further foreground-background '
    'segmentation.\n'
    '\n'
    '@param src Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or '
    'CV_64FC(n), where n is a positive integer.\n'
    '@param dst %Accumulator image with the same number of channels as input '
    'image, and a depth of CV_32F or CV_64F.\n'
    '@param mask Optional operation mask.\n'
    '\n'
    '@sa  accumulateSquare, accumulateProduct, accumulateWeighted']
parse_name: cv.accumulate with ['cv'] -> fullname:cv::accumulate namespace:cv classpath: classname: name:accumulate
register (function) accumulate (cv_accumulate__InputArray__InputOutputArray__InputArray)

--- Incoming ---
[   'cv.accumulateSquare',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['InputOutputArray', 'dst', '', []],
        ['InputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Adds the square of a source image to the accumulator image.\n'
    '\n'
    'The function adds the input image src or its selected region, raised to a '
    'power of 2, to the\n'
    'accumulator dst :\n'
    '\n'
    '\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} '
    '(x,y)^2  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n'
    '\n'
    'The function supports multi-channel images. Each channel is processed '
    'independently.\n'
    '\n'
    '@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating '
    'point.\n'
    '@param dst %Accumulator image with the same number of channels as input '
    'image, 32-bit or 64-bit\n'
    'floating-point.\n'
    '@param mask Optional operation mask.\n'
    '\n'
    '@sa  accumulateSquare, accumulateProduct, accumulateWeighted']
parse_name: cv.accumulateSquare with ['cv'] -> fullname:cv::accumulateSquare namespace:cv classpath: classname: name:accumulateSquare
register (function) accumulateSquare (cv_accumulateSquare__InputArray__InputOutputArray__InputArray)

--- Incoming ---
[   'cv.accumulateProduct',
    'void',
    [],
    [   ['InputArray', 'src1', '', []],
        ['InputArray', 'src2', '', []],
        ['InputOutputArray', 'dst', '', []],
        ['InputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Adds the per-element product of two input images to the '
    'accumulator image.\n'
    '\n'
    'The function adds the product of two images or their selected regions to '
    'the accumulator dst :\n'
    '\n'
    '\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  '
    '\\texttt{src1} (x,y)  \\cdot \\texttt{src2} (x,y)  \\quad \\text{if} '
    '\\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n'
    '\n'
    'The function supports multi-channel images. Each channel is processed '
    'independently.\n'
    '\n'
    '@param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating '
    'point.\n'
    '@param src2 Second input image of the same type and the same size as src1 '
    '.\n'
    '@param dst %Accumulator image with the same number of channels as input '
    'images, 32-bit or 64-bit\n'
    'floating-point.\n'
    '@param mask Optional operation mask.\n'
    '\n'
    '@sa  accumulate, accumulateSquare, accumulateWeighted']
parse_name: cv.accumulateProduct with ['cv'] -> fullname:cv::accumulateProduct namespace:cv classpath: classname: name:accumulateProduct
register (function) accumulateProduct (cv_accumulateProduct__InputArray__InputArray__InputOutputArray__InputArray)

--- Incoming ---
[   'cv.accumulateWeighted',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['InputOutputArray', 'dst', '', []],
        ['double', 'alpha', '', []],
        ['InputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Updates a running average.\n'
    '\n'
    'The function calculates the weighted sum of the input image src and the '
    'accumulator dst so that dst\n'
    'becomes a running average of a frame sequence:\n'
    '\n'
    '\\f[\\texttt{dst} (x,y)  \\leftarrow (1- \\texttt{alpha} )  \\cdot '
    '\\texttt{dst} (x,y) +  \\texttt{alpha} \\cdot \\texttt{src} (x,y)  \\quad '
    '\\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n'
    '\n'
    'That is, alpha regulates the update speed (how fast the accumulator '
    '"forgets" about earlier images).\n'
    'The function supports multi-channel images. Each channel is processed '
    'independently.\n'
    '\n'
    '@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating '
    'point.\n'
    '@param dst %Accumulator image with the same number of channels as input '
    'image, 32-bit or 64-bit\n'
    'floating-point.\n'
    '@param alpha Weight of the input image.\n'
    '@param mask Optional operation mask.\n'
    '\n'
    '@sa  accumulate, accumulateSquare, accumulateProduct']
parse_name: cv.accumulateWeighted with ['cv'] -> fullname:cv::accumulateWeighted namespace:cv classpath: classname: name:accumulateWeighted
register (function) accumulateWeighted (cv_accumulateWeighted__InputArray__InputOutputArray_double__InputArray)

--- Incoming ---
[   'cv.phaseCorrelate',
    'Point2d',
    [],
    [   ['InputArray', 'src1', '', []],
        ['InputArray', 'src2', '', []],
        ['InputArray', 'window', 'noArray()', []],
        ['double*', 'response', '0', []]],
    None,
    '@brief The function is used to detect translational shifts that occur '
    'between two images.\n'
    '\n'
    'The operation takes advantage of the Fourier shift theorem for detecting '
    'the translational shift in\n'
    'the frequency domain. It can be used for fast image registration as well '
    'as motion estimation. For\n'
    'more information please see '
    '<http://en.wikipedia.org/wiki/Phase_correlation>\n'
    '\n'
    'Calculates the cross-power spectrum of two supplied source arrays. The '
    'arrays are padded if needed\n'
    'with getOptimalDFTSize.\n'
    '\n'
    'The function performs the following equations:\n'
    '- First it applies a Hanning window (see '
    '<http://en.wikipedia.org/wiki/Hann_function>) to each\n'
    'image to remove possible edge effects. This window is cached until the '
    'array size changes to speed\n'
    'up processing time.\n'
    '- Next it computes the forward DFTs of each source array:\n'
    '\\f[\\mathbf{G}_a = \\mathcal{F}\\{src_1\\}, \\; \\mathbf{G}_b = '
    '\\mathcal{F}\\{src_2\\}\\f]\n'
    'where \\f$\\mathcal{F}\\f$ is the forward DFT.\n'
    '- It then computes the cross-power spectrum of each frequency domain '
    'array:\n'
    '\\f[R = \\frac{ \\mathbf{G}_a \\mathbf{G}_b^*}{|\\mathbf{G}_a '
    '\\mathbf{G}_b^*|}\\f]\n'
    '- Next the cross-correlation is converted back into the time domain via '
    'the inverse DFT:\n'
    '\\f[r = \\mathcal{F}^{-1}\\{R\\}\\f]\n'
    '- Finally, it computes the peak location and computes a 5x5 weighted '
    'centroid around the peak to\n'
    'achieve sub-pixel accuracy.\n'
    '\\f[(\\Delta x, \\Delta y) = \\texttt{weightedCentroid} \\{\\arg '
    '\\max_{(x, y)}\\{r\\}\\}\\f]\n'
    '- If non-zero, the response parameter is computed as the sum of the '
    'elements of r within the 5x5\n'
    'centroid around the peak location. It is normalized to a maximum of 1 '
    '(meaning there is a single\n'
    'peak) and will be smaller when there are multiple peaks.\n'
    '\n'
    '@param src1 Source floating point array (CV_32FC1 or CV_64FC1)\n'
    '@param src2 Source floating point array (CV_32FC1 or CV_64FC1)\n'
    '@param window Floating point array with windowing coefficients to reduce '
    'edge effects (optional).\n'
    '@param response Signal power within the 5x5 centroid around the peak, '
    'between 0 and 1 (optional).\n'
    '@returns detected phase shift (sub-pixel) between the two arrays.\n'
    '\n'
    '@sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow']
parse_name: cv.phaseCorrelate with ['cv'] -> fullname:cv::phaseCorrelate namespace:cv classpath: classname: name:phaseCorrelate
register (function) phaseCorrelate (cv_phaseCorrelate__InputArray__InputArray__InputArray_double_X)

--- Incoming ---
[   'cv.createHanningWindow',
    'void',
    [],
    [   ['OutputArray', 'dst', '', []],
        ['Size', 'winSize', '', []],
        ['int', 'type', '', []]],
    None,
    '@brief This function computes a Hanning window coefficients in two '
    'dimensions.\n'
    '\n'
    'See (http://en.wikipedia.org/wiki/Hann_function) and '
    '(http://en.wikipedia.org/wiki/Window_function)\n'
    'for more information.\n'
    '\n'
    'An example is shown below:\n'
    '@code\n'
    '// create hanning window of size 100x100 and type CV_32F\n'
    'Mat hann;\n'
    'createHanningWindow(hann, Size(100, 100), CV_32F);\n'
    '@endcode\n'
    '@param dst Destination array to place Hann coefficients in\n'
    '@param winSize The window size specifications (both width and height must '
    'be > 1)\n'
    '@param type Created array type']
parse_name: cv.createHanningWindow with ['cv'] -> fullname:cv::createHanningWindow namespace:cv classpath: classname: name:createHanningWindow
register (function) createHanningWindow (cv_createHanningWindow__OutputArray_Size_int)

--- Incoming ---
[   'cv.threshold',
    'double',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['double', 'thresh', '', []],
        ['double', 'maxval', '', []],
        ['int', 'type', '', []]],
    None,
    '@brief Applies a fixed-level threshold to each array element.\n'
    '\n'
    'The function applies fixed-level thresholding to a multiple-channel '
    'array. The function is typically\n'
    'used to get a bi-level (binary) image out of a grayscale image ( #compare '
    'could be also used for\n'
    'this purpose) or for removing a noise, that is, filtering out pixels with '
    'too small or too large\n'
    'values. There are several types of thresholding supported by the '
    'function. They are determined by\n'
    'type parameter.\n'
    '\n'
    'Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined '
    'with one of the\n'
    'above values. In these cases, the function determines the optimal '
    "threshold value using the Otsu's\n"
    'or Triangle algorithm and uses it instead of the specified thresh.\n'
    '\n'
    "@note Currently, the Otsu's and Triangle methods are implemented only for "
    '8-bit single-channel images.\n'
    '\n'
    '@param src input array (multiple-channel, 8-bit or 32-bit floating '
    'point).\n'
    '@param dst output array of the same size  and type and the same number of '
    'channels as src.\n'
    '@param thresh threshold value.\n'
    '@param maxval maximum value to use with the #THRESH_BINARY and '
    '#THRESH_BINARY_INV thresholding\n'
    'types.\n'
    '@param type thresholding type (see #ThresholdTypes).\n'
    "@return the computed threshold value if Otsu's or Triangle methods used.\n"
    '\n'
    '@sa  adaptiveThreshold, findContours, compare, min, max']
parse_name: cv.threshold with ['cv'] -> fullname:cv::threshold namespace:cv classpath: classname: name:threshold
register (function) threshold (cv_threshold__InputArray__OutputArray_double_double_int)

--- Incoming ---
[   'cv.adaptiveThreshold',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['double', 'maxValue', '', []],
        ['int', 'adaptiveMethod', '', []],
        ['int', 'thresholdType', '', []],
        ['int', 'blockSize', '', []],
        ['double', 'C', '', []]],
    None,
    '@brief Applies an adaptive threshold to an array.\n'
    '\n'
    'The function transforms a grayscale image to a binary image according to '
    'the formulae:\n'
    '-   **THRESH_BINARY**\n'
    '\\f[dst(x,y) =  \\fork{\\texttt{maxValue}}{if \\(src(x,y) > '
    'T(x,y)\\)}{0}{otherwise}\\f]\n'
    '-   **THRESH_BINARY_INV**\n'
    '\\f[dst(x,y) =  \\fork{0}{if \\(src(x,y) > '
    'T(x,y)\\)}{\\texttt{maxValue}}{otherwise}\\f]\n'
    'where \\f$T(x,y)\\f$ is a threshold calculated individually for each '
    'pixel (see adaptiveMethod parameter).\n'
    '\n'
    'The function can process the image in-place.\n'
    '\n'
    '@param src Source 8-bit single-channel image.\n'
    '@param dst Destination image of the same size and the same type as src.\n'
    '@param maxValue Non-zero value assigned to the pixels for which the '
    'condition is satisfied\n'
    '@param adaptiveMethod Adaptive thresholding algorithm to use, see '
    '#AdaptiveThresholdTypes.\n'
    'The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.\n'
    '@param thresholdType Thresholding type that must be either #THRESH_BINARY '
    'or #THRESH_BINARY_INV,\n'
    'see #ThresholdTypes.\n'
    '@param blockSize Size of a pixel neighborhood that is used to calculate a '
    'threshold value for the\n'
    'pixel: 3, 5, 7, and so on.\n'
    '@param C Constant subtracted from the mean or weighted mean (see the '
    'details below). Normally, it\n'
    'is positive but may be zero or negative as well.\n'
    '\n'
    '@sa  threshold, blur, GaussianBlur']
parse_name: cv.adaptiveThreshold with ['cv'] -> fullname:cv::adaptiveThreshold namespace:cv classpath: classname: name:adaptiveThreshold
register (function) adaptiveThreshold (cv_adaptiveThreshold__InputArray__OutputArray_double_int_int_int_double)

--- Incoming ---
[   'cv.pyrDown',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['const Size&', 'dstsize', 'Size()', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Blurs an image and downsamples it.\n'
    '\n'
    'By default, size of the output image is computed as `Size((src.cols+1)/2, '
    '(src.rows+1)/2)`, but in\n'
    'any case, the following conditions should be satisfied:\n'
    '\n'
    '\\f[\\begin{array}{l} | \\texttt{dstsize.width} *2-src.cols| \\leq 2 \\\\ '
    '| \\texttt{dstsize.height} *2-src.rows| \\leq 2 \\end{array}\\f]\n'
    '\n'
    'The function performs the downsampling step of the Gaussian pyramid '
    'construction. First, it\n'
    'convolves the source image with the kernel:\n'
    '\n'
    '\\f[\\frac{1}{256} \\begin{bmatrix} 1 & 4 & 6 & 4 & 1  \\\\ 4 & 16 & 24 & '
    '16 & 4  \\\\ 6 & 24 & 36 & 24 & 6  \\\\ 4 & 16 & 24 & 16 & 4  \\\\ 1 & 4 '
    '& 6 & 4 & 1 \\end{bmatrix}\\f]\n'
    '\n'
    'Then, it downsamples the image by rejecting even rows and columns.\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image; it has the specified size and the same type as '
    'src.\n'
    '@param dstsize size of the output image.\n'
    '@param borderType Pixel extrapolation method, see #BorderTypes '
    "(#BORDER_CONSTANT isn't supported)"]
parse_name: cv.pyrDown with ['cv'] -> fullname:cv::pyrDown namespace:cv classpath: classname: name:pyrDown
register (function) pyrDown (cv_pyrDown__InputArray__OutputArray_Size_int)

--- Incoming ---
[   'cv.pyrUp',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['const Size&', 'dstsize', 'Size()', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Upsamples an image and then blurs it.\n'
    '\n'
    'By default, size of the output image is computed as `Size(src.cols\\*2, '
    '(src.rows\\*2)`, but in any\n'
    'case, the following conditions should be satisfied:\n'
    '\n'
    '\\f[\\begin{array}{l} | \\texttt{dstsize.width} -src.cols*2| \\leq  ( '
    '\\texttt{dstsize.width}   \\mod  2)  \\\\ | \\texttt{dstsize.height} '
    '-src.rows*2| \\leq  ( \\texttt{dstsize.height}   \\mod  2) '
    '\\end{array}\\f]\n'
    '\n'
    'The function performs the upsampling step of the Gaussian pyramid '
    'construction, though it can\n'
    'actually be used to construct the Laplacian pyramid. First, it upsamples '
    'the source image by\n'
    'injecting even zero rows and columns and then convolves the result with '
    'the same kernel as in\n'
    'pyrDown multiplied by 4.\n'
    '\n'
    '@param src input image.\n'
    '@param dst output image. It has the specified size and the same type as '
    'src .\n'
    '@param dstsize size of the output image.\n'
    '@param borderType Pixel extrapolation method, see #BorderTypes (only '
    '#BORDER_DEFAULT is supported)']
parse_name: cv.pyrUp with ['cv'] -> fullname:cv::pyrUp namespace:cv classpath: classname: name:pyrUp
register (function) pyrUp (cv_pyrUp__InputArray__OutputArray_Size_int)

--- Incoming ---
[   'cv.buildPyramid',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArrayOfArrays', 'dst', '', []],
        ['int', 'maxlevel', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    None,
    '@brief Constructs the Gaussian pyramid for an image.\n'
    '\n'
    'The function constructs a vector of images and builds the Gaussian '
    'pyramid by recursively applying\n'
    'pyrDown to the previously built pyramid layers, starting from '
    '`dst[0]==src`.\n'
    '\n'
    '@param src Source image. Check pyrDown for the list of supported types.\n'
    '@param dst Destination vector of maxlevel+1 images of the same type as '
    'src. dst[0] will be the\n'
    'same as src. dst[1] is the next pyramid layer, a smoothed and down-sized '
    'src, and so on.\n'
    '@param maxlevel 0-based index of the last (the smallest) pyramid layer. '
    'It must be non-negative.\n'
    '@param borderType Pixel extrapolation method, see #BorderTypes '
    "(#BORDER_CONSTANT isn't supported)"]
parse_name: cv.buildPyramid with ['cv'] -> fullname:cv::buildPyramid namespace:cv classpath: classname: name:buildPyramid
register (function) buildPyramid (cv_buildPyramid__InputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.calcHist',
    'void',
    [],
    [   ['const Mat*', 'images', '', []],
        ['int', 'nimages', '', []],
        ['const int*', 'channels', '', []],
        ['InputArray', 'mask', '', []],
        ['OutputArray', 'hist', '', []],
        ['int', 'dims', '', []],
        ['const int*', 'histSize', '', []],
        ['const float**', 'ranges', '', []],
        ['bool', 'uniform', 'true', []],
        ['bool', 'accumulate', 'false', []]],
    None,
    '@brief Calculates a histogram of a set of arrays.\n'
    '\n'
    'The function cv::calcHist calculates the histogram of one or more arrays. '
    'The elements of a tuple used\n'
    'to increment a histogram bin are taken from the corresponding input '
    'arrays at the same location. The\n'
    'sample below shows how to compute a 2D Hue-Saturation histogram for a '
    'color image. :\n'
    '@include snippets/imgproc_calcHist.cpp\n'
    '\n'
    '@param images Source arrays. They all should have the same depth, CV_8U, '
    'CV_16U or CV_32F , and the same\n'
    'size. Each of them can have an arbitrary number of channels.\n'
    '@param nimages Number of source images.\n'
    '@param channels List of the dims channels used to compute the histogram. '
    'The first array channels\n'
    'are numerated from 0 to images[0].channels()-1 , the second array '
    'channels are counted from\n'
    'images[0].channels() to images[0].channels() + images[1].channels()-1, '
    'and so on.\n'
    '@param mask Optional mask. If the matrix is not empty, it must be an '
    '8-bit array of the same size\n'
    'as images[i] . The non-zero mask elements mark the array elements counted '
    'in the histogram.\n'
    '@param hist Output histogram, which is a dense or sparse dims '
    '-dimensional array.\n'
    '@param dims Histogram dimensionality that must be positive and not '
    'greater than CV_MAX_DIMS\n'
    '(equal to 32 in the current OpenCV version).\n'
    '@param histSize Array of histogram sizes in each dimension.\n'
    '@param ranges Array of the dims arrays of the histogram bin boundaries in '
    'each dimension. When the\n'
    'histogram is uniform ( uniform =true), then for each dimension i it is '
    'enough to specify the lower\n'
    '(inclusive) boundary \\f$L_0\\f$ of the 0-th histogram bin and the upper '
    '(exclusive) boundary\n'
    '\\f$U_{\\texttt{histSize}[i]-1}\\f$ for the last histogram bin '
    'histSize[i]-1 . That is, in case of a\n'
    'uniform histogram each of ranges[i] is an array of 2 elements. When the '
    'histogram is not uniform (\n'
    'uniform=false ), then each of ranges[i] contains histSize[i]+1 elements:\n'
    '\\f$L_0, U_0=L_1, U_1=L_2, ..., '
    'U_{\\texttt{histSize[i]}-2}=L_{\\texttt{histSize[i]}-1}, '
    'U_{\\texttt{histSize[i]}-1}\\f$\n'
    '. The array elements, that are not between \\f$L_0\\f$ and '
    '\\f$U_{\\texttt{histSize[i]}-1}\\f$ , are not\n'
    'counted in the histogram.\n'
    '@param uniform Flag indicating whether the histogram is uniform or not '
    '(see above).\n'
    '@param accumulate Accumulation flag. If it is set, the histogram is not '
    'cleared in the beginning\n'
    'when it is allocated. This feature enables you to compute a single '
    'histogram from several sets of\n'
    'arrays, or to update the histogram in time.']
parse_name: cv.calcHist with ['cv'] -> fullname:cv::calcHist namespace:cv classpath: classname: name:calcHist
register (function) calcHist (cv_calcHist_const_Mat_int_const_int_X__InputArray__OutputArray_int_const_int_X_float**_bool_bool)

--- Incoming ---
[   'cv.calcHist',
    'void',
    [],
    [   ['const Mat*', 'images', '', []],
        ['int', 'nimages', '', []],
        ['const int*', 'channels', '', []],
        ['InputArray', 'mask', '', []],
        ['SparseMat&', 'hist', '', []],
        ['int', 'dims', '', []],
        ['const int*', 'histSize', '', []],
        ['const float**', 'ranges', '', []],
        ['bool', 'uniform', 'true', []],
        ['bool', 'accumulate', 'false', []]],
    None,
    '@overload\n\nthis variant uses %SparseMat for output']
parse_name: cv.calcHist with ['cv'] -> fullname:cv::calcHist namespace:cv classpath: classname: name:calcHist
Registering an unknown type: SparseMat
register (function) calcHist (cv_calcHist_const_Mat_int_const_int_X__InputArray_SparseMat_int_const_int_X_float**_bool_bool)

--- Incoming ---
[   'cv.calcHist',
    'void',
    [],
    [   ['InputArrayOfArrays', 'images', '', []],
        ['const std::vector<int>&', 'channels', '', []],
        ['InputArray', 'mask', '', []],
        ['OutputArray', 'hist', '', []],
        ['const std::vector<int>&', 'histSize', '', []],
        ['const std::vector<float>&', 'ranges', '', []],
        ['bool', 'accumulate', 'false', []]],
    None,
    '@overload']
parse_name: cv.calcHist with ['cv'] -> fullname:cv::calcHist namespace:cv classpath: classname: name:calcHist
register (function) calcHist (cv_calcHist__InputArray_VectorOfint__InputArray__OutputArray_VectorOfint_VectorOffloat_bool)

--- Incoming ---
[   'cv.calcBackProject',
    'void',
    [],
    [   ['const Mat*', 'images', '', []],
        ['int', 'nimages', '', []],
        ['const int*', 'channels', '', []],
        ['InputArray', 'hist', '', []],
        ['OutputArray', 'backProject', '', []],
        ['const float**', 'ranges', '', []],
        ['double', 'scale', '1', []],
        ['bool', 'uniform', 'true', []]],
    None,
    '@brief Calculates the back projection of a histogram.\n'
    '\n'
    'The function cv::calcBackProject calculates the back project of the '
    'histogram. That is, similarly to\n'
    '#calcHist , at each location (x, y) the function collects the values from '
    'the selected channels\n'
    'in the input images and finds the corresponding histogram bin. But '
    'instead of incrementing it, the\n'
    'function reads the bin value, scales it by scale , and stores in '
    'backProject(x,y) . In terms of\n'
    'statistics, the function computes probability of each element value in '
    'respect with the empirical\n'
    'probability distribution represented by the histogram. See how, for '
    'example, you can find and track\n'
    'a bright-colored object in a scene:\n'
    '\n'
    '- Before tracking, show the object to the camera so that it covers almost '
    'the whole frame.\n'
    'Calculate a hue histogram. The histogram may have strong maximums, '
    'corresponding to the dominant\n'
    'colors in the object.\n'
    '\n'
    '- When tracking, calculate a back projection of a hue plane of each input '
    'video frame using that\n'
    'pre-computed histogram. Threshold the back projection to suppress weak '
    'colors. It may also make\n'
    'sense to suppress pixels with non-sufficient color saturation and too '
    'dark or too bright pixels.\n'
    '\n'
    '- Find connected components in the resulting picture and choose, for '
    'example, the largest\n'
    'component.\n'
    '\n'
    'This is an approximate algorithm of the CamShift color object tracker.\n'
    '\n'
    '@param images Source arrays. They all should have the same depth, CV_8U, '
    'CV_16U or CV_32F , and the same\n'
    'size. Each of them can have an arbitrary number of channels.\n'
    '@param nimages Number of source images.\n'
    '@param channels The list of channels used to compute the back projection. '
    'The number of channels\n'
    'must match the histogram dimensionality. The first array channels are '
    'numerated from 0 to\n'
    'images[0].channels()-1 , the second array channels are counted from '
    'images[0].channels() to\n'
    'images[0].channels() + images[1].channels()-1, and so on.\n'
    '@param hist Input histogram that can be dense or sparse.\n'
    '@param backProject Destination back projection array that is a '
    'single-channel array of the same\n'
    'size and depth as images[0] .\n'
    '@param ranges Array of arrays of the histogram bin boundaries in each '
    'dimension. See #calcHist .\n'
    '@param scale Optional scale factor for the output back projection.\n'
    '@param uniform Flag indicating whether the histogram is uniform or not '
    '(see above).\n'
    '\n'
    '@sa calcHist, compareHist']
parse_name: cv.calcBackProject with ['cv'] -> fullname:cv::calcBackProject namespace:cv classpath: classname: name:calcBackProject
register (function) calcBackProject (cv_calcBackProject_const_Mat_int_const_int_X__InputArray__OutputArray_float**_double_bool)

--- Incoming ---
[   'cv.calcBackProject',
    'void',
    [],
    [   ['const Mat*', 'images', '', []],
        ['int', 'nimages', '', []],
        ['const int*', 'channels', '', []],
        ['const SparseMat&', 'hist', '', []],
        ['OutputArray', 'backProject', '', []],
        ['const float**', 'ranges', '', []],
        ['double', 'scale', '1', []],
        ['bool', 'uniform', 'true', []]],
    None,
    '@overload']
parse_name: cv.calcBackProject with ['cv'] -> fullname:cv::calcBackProject namespace:cv classpath: classname: name:calcBackProject
Registering an unknown type: SparseMat
register (function) calcBackProject (cv_calcBackProject_const_Mat_int_const_int_X_SparseMat__OutputArray_float**_double_bool)

--- Incoming ---
[   'cv.calcBackProject',
    'void',
    [],
    [   ['InputArrayOfArrays', 'images', '', []],
        ['const std::vector<int>&', 'channels', '', []],
        ['InputArray', 'hist', '', []],
        ['OutputArray', 'dst', '', []],
        ['const std::vector<float>&', 'ranges', '', []],
        ['double', 'scale', '', []]],
    None,
    '@overload']
parse_name: cv.calcBackProject with ['cv'] -> fullname:cv::calcBackProject namespace:cv classpath: classname: name:calcBackProject
register (function) calcBackProject (cv_calcBackProject__InputArray_VectorOfint__InputArray__OutputArray_VectorOffloat_double)

--- Incoming ---
[   'cv.compareHist',
    'double',
    [],
    [   ['InputArray', 'H1', '', []],
        ['InputArray', 'H2', '', []],
        ['int', 'method', '', []]],
    None,
    '@brief Compares two histograms.\n'
    '\n'
    'The function cv::compareHist compares two dense or two sparse histograms '
    'using the specified method.\n'
    '\n'
    'The function returns \\f$d(H_1, H_2)\\f$ .\n'
    '\n'
    'While the function works well with 1-, 2-, 3-dimensional dense '
    'histograms, it may not be suitable\n'
    'for high-dimensional sparse histograms. In such histograms, because of '
    'aliasing and sampling\n'
    'problems, the coordinates of non-zero histogram bins can slightly shift. '
    'To compare such histograms\n'
    'or more general sparse configurations of weighted points, consider using '
    'the #EMD function.\n'
    '\n'
    '@param H1 First compared histogram.\n'
    '@param H2 Second compared histogram of the same size as H1 .\n'
    '@param method Comparison method, see #HistCompMethods']
parse_name: cv.compareHist with ['cv'] -> fullname:cv::compareHist namespace:cv classpath: classname: name:compareHist
register (function) compareHist (cv_compareHist__InputArray__InputArray_int)

--- Incoming ---
[   'cv.compareHist',
    'double',
    [],
    [   ['const SparseMat&', 'H1', '', []],
        ['const SparseMat&', 'H2', '', []],
        ['int', 'method', '', []]],
    None,
    '@overload']
parse_name: cv.compareHist with ['cv'] -> fullname:cv::compareHist namespace:cv classpath: classname: name:compareHist
register (function) compareHist (cv_compareHist_SparseMat_SparseMat_int)

--- Incoming ---
[   'cv.equalizeHist',
    'void',
    [],
    [['InputArray', 'src', '', []], ['OutputArray', 'dst', '', []]],
    None,
    '@brief Equalizes the histogram of a grayscale image.\n'
    '\n'
    'The function equalizes the histogram of the input image using the '
    'following algorithm:\n'
    '\n'
    '- Calculate the histogram \\f$H\\f$ for src .\n'
    '- Normalize the histogram so that the sum of histogram bins is 255.\n'
    '- Compute the integral of the histogram:\n'
    "\\f[H'_i =  \\sum _{0  \\le j < i} H(j)\\f]\n"
    "- Transform the image using \\f$H'\\f$ as a look-up table: "
    "\\f$\\texttt{dst}(x,y) = H'(\\texttt{src}(x,y))\\f$\n"
    '\n'
    'The algorithm normalizes the brightness and increases the contrast of the '
    'image.\n'
    '\n'
    '@param src Source 8-bit single channel image.\n'
    '@param dst Destination image of the same size and type as src .']
parse_name: cv.equalizeHist with ['cv'] -> fullname:cv::equalizeHist namespace:cv classpath: classname: name:equalizeHist
register (function) equalizeHist (cv_equalizeHist__InputArray__OutputArray)

--- Incoming ---
[   'cv.createCLAHE',
    'Ptr<CLAHE>',
    [],
    [   ['double', 'clipLimit', '40.0', []],
        ['Size', 'tileGridSize', 'Size(8, 8)', []]],
    None,
    '@brief Creates a smart pointer to a cv::CLAHE class and initializes it.\n'
    '\n'
    '@param clipLimit Threshold for contrast limiting.\n'
    '@param tileGridSize Size of grid for histogram equalization. Input image '
    'will be divided into\n'
    'equally sized rectangular tiles. tileGridSize defines the number of tiles '
    'in row and column.']
parse_name: cv.createCLAHE with ['cv'] -> fullname:cv::createCLAHE namespace:cv classpath: classname: name:createCLAHE
register (function) createCLAHE (cv_createCLAHE_double_Size)

--- Incoming ---
[   'cv.EMD',
    'float',
    [],
    [   ['InputArray', 'signature1', '', []],
        ['InputArray', 'signature2', '', []],
        ['int', 'distType', '', []],
        ['InputArray', 'cost', 'noArray()', []],
        ['float*', 'lowerBound', '0', []],
        ['OutputArray', 'flow', 'noArray()', []]],
    None,
    '@brief Computes the "minimal work" distance between two weighted point '
    'configurations.\n'
    '\n'
    'The function computes the earth mover distance and/or a lower boundary of '
    'the distance between the\n'
    'two weighted point configurations. One of the applications described in '
    '@cite RubnerSept98,\n'
    '@cite Rubner2000 is multi-dimensional histogram comparison for image '
    'retrieval. EMD is a transportation\n'
    'problem that is solved using some modification of a simplex algorithm, '
    'thus the complexity is\n'
    'exponential in the worst case, though, on average it is much faster. In '
    'the case of a real metric\n'
    'the lower boundary can be calculated even faster (using linear-time '
    'algorithm) and it can be used\n'
    'to determine roughly whether the two signatures are far enough so that '
    'they cannot relate to the\n'
    'same object.\n'
    '\n'
    '@param signature1 First signature, a \\f$\\texttt{size1}\\times '
    '\\texttt{dims}+1\\f$ floating-point matrix.\n'
    'Each row stores the point weight followed by the point coordinates. The '
    'matrix is allowed to have\n'
    'a single column (weights only) if the user-defined cost matrix is used. '
    'The weights must be\n'
    'non-negative and have at least one non-zero value.\n'
    '@param signature2 Second signature of the same format as signature1 , '
    'though the number of rows\n'
    'may be different. The total weights may be different. In this case an '
    'extra "dummy" point is added\n'
    'to either signature1 or signature2. The weights must be non-negative and '
    'have at least one non-zero\n'
    'value.\n'
    '@param distType Used metric. See #DistanceTypes.\n'
    '@param cost User-defined \\f$\\texttt{size1}\\times \\texttt{size2}\\f$ '
    'cost matrix. Also, if a cost matrix\n'
    'is used, lower boundary lowerBound cannot be calculated because it needs '
    'a metric function.\n'
    '@param lowerBound Optional input/output parameter: lower boundary of a '
    'distance between the two\n'
    'signatures that is a distance between mass centers. The lower boundary '
    'may not be calculated if\n'
    'the user-defined cost matrix is used, the total weights of point '
    'configurations are not equal, or\n'
    'if the signatures consist of weights only (the signature matrices have a '
    'single column). You\n'
    '**must** initialize \\*lowerBound . If the calculated distance between '
    'mass centers is greater or\n'
    'equal to \\*lowerBound (it means that the signatures are far enough), the '
    'function does not\n'
    'calculate EMD. In any case \\*lowerBound is set to the calculated '
    'distance between mass centers on\n'
    'return. Thus, if you want to calculate both distance between mass centers '
    'and EMD, \\*lowerBound\n'
    'should be set to 0.\n'
    '@param flow Resultant \\f$\\texttt{size1} \\times \\texttt{size2}\\f$ '
    'flow matrix: \\f$\\texttt{flow}_{i,j}\\f$ is\n'
    'a flow from \\f$i\\f$ -th point of signature1 to \\f$j\\f$ -th point of '
    'signature2 .']
parse_name: cv.EMD with ['cv'] -> fullname:cv::EMD namespace:cv classpath: classname: name:EMD
register (function) EMD (cv_EMD__InputArray__InputArray_int__InputArray_float_X__OutputArray)

--- Incoming ---
[   'cv.wrapperEMD',
    'float',
    [],
    [   ['InputArray', 'signature1', '', []],
        ['InputArray', 'signature2', '', []],
        ['int', 'distType', '', []],
        ['InputArray', 'cost', 'noArray()', []],
        ['Ptr<float>', 'lowerBound', 'Ptr<float>()', []],
        ['OutputArray', 'flow', 'noArray()', []]],
    None,
    '']
parse_name: cv.wrapperEMD with ['cv'] -> fullname:cv::wrapperEMD namespace:cv classpath: classname: name:wrapperEMD
register (function) wrapperEMD (cv_wrapperEMD__InputArray__InputArray_int__InputArray_PtrOffloat__OutputArray)

--- Incoming ---
[   'cv.watershed',
    'void',
    [],
    [['InputArray', 'image', '', []], ['InputOutputArray', 'markers', '', []]],
    None,
    '@brief Performs a marker-based image segmentation using the watershed '
    'algorithm.\n'
    '\n'
    'The function implements one of the variants of watershed, non-parametric '
    'marker-based segmentation\n'
    'algorithm, described in @cite Meyer92 .\n'
    '\n'
    'Before passing the image to the function, you have to roughly outline the '
    'desired regions in the\n'
    'image markers with positive (\\>0) indices. So, every region is '
    'represented as one or more connected\n'
    'components with the pixel values 1, 2, 3, and so on. Such markers can be '
    'retrieved from a binary\n'
    'mask using #findContours and #drawContours (see the watershed.cpp demo). '
    'The markers are "seeds" of\n'
    'the future image regions. All the other pixels in markers , whose '
    'relation to the outlined regions\n'
    'is not known and should be defined by the algorithm, should be set to '
    "0's. In the function output,\n"
    'each pixel in markers is set to a value of the "seed" components or to -1 '
    'at boundaries between the\n'
    'regions.\n'
    '\n'
    '@note Any two neighbor connected components are not necessarily separated '
    'by a watershed boundary\n'
    "(-1's pixels); for example, they can touch each other in the initial "
    'marker image passed to the\n'
    'function.\n'
    '\n'
    '@param image Input 8-bit 3-channel image.\n'
    '@param markers Input/output 32-bit single-channel image (map) of markers. '
    'It should have the same\n'
    'size as image .\n'
    '\n'
    '@sa findContours\n'
    '\n'
    '@ingroup imgproc_misc']
parse_name: cv.watershed with ['cv'] -> fullname:cv::watershed namespace:cv classpath: classname: name:watershed
register (function) watershed (cv_watershed__InputArray__InputOutputArray)

--- Incoming ---
[   'cv.pyrMeanShiftFiltering',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['double', 'sp', '', []],
        ['double', 'sr', '', []],
        ['int', 'maxLevel', '1', []],
        [   'TermCriteria',
            'termcrit',
            'TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)',
            []]],
    None,
    '@brief Performs initial step of meanshift segmentation of an image.\n'
    '\n'
    'The function implements the filtering stage of meanshift segmentation, '
    'that is, the output of the\n'
    'function is the filtered "posterized" image with color gradients and '
    'fine-grain texture flattened.\n'
    'At every pixel (X,Y) of the input image (or down-sized input image, see '
    'below) the function executes\n'
    'meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint '
    'space-color hyperspace is\n'
    'considered:\n'
    '\n'
    '\\f[(x,y): X- \\texttt{sp} \\le x  \\le X+ \\texttt{sp} , Y- \\texttt{sp} '
    '\\le y  \\le Y+ \\texttt{sp} , ||(R,G,B)-(r,g,b)||   \\le '
    '\\texttt{sr}\\f]\n'
    '\n'
    'where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) '
    'and (x,y), respectively\n'
    '(though, the algorithm does not depend on the color space used, so any '
    '3-component color space can\n'
    "be used instead). Over the neighborhood the average spatial value (X',Y') "
    'and average color vector\n'
    "(R',G',B') are found and they act as the neighborhood center on the next "
    'iteration:\n'
    '\n'
    "\\f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\\f]\n"
    '\n'
    'After the iterations over, the color components of the initial pixel '
    '(that is, the pixel from where\n'
    'the iterations started) are set to the final value (average color at the '
    'last iteration):\n'
    '\n'
    '\\f[I(X,Y) <- (R*,G*,B*)\\f]\n'
    '\n'
    'When maxLevel \\> 0, the gaussian pyramid of maxLevel+1 levels is built, '
    'and the above procedure is\n'
    'run on the smallest layer first. After that, the results are propagated '
    'to the larger layer and the\n'
    'iterations are run again only on those pixels where the layer colors '
    'differ by more than sr from the\n'
    'lower-resolution layer of the pyramid. That makes boundaries of color '
    'regions sharper. Note that the\n'
    'results will be actually different from the ones obtained by running the '
    'meanshift procedure on the\n'
    'whole original image (i.e. when maxLevel==0).\n'
    '\n'
    '@param src The source 8-bit, 3-channel image.\n'
    '@param dst The destination image of the same format and the same size as '
    'the source.\n'
    '@param sp The spatial window radius.\n'
    '@param sr The color window radius.\n'
    '@param maxLevel Maximum level of the pyramid for the segmentation.\n'
    '@param termcrit Termination criteria: when to stop meanshift iterations.']
parse_name: cv.pyrMeanShiftFiltering with ['cv'] -> fullname:cv::pyrMeanShiftFiltering namespace:cv classpath: classname: name:pyrMeanShiftFiltering
register (function) pyrMeanShiftFiltering (cv_pyrMeanShiftFiltering__InputArray__OutputArray_double_double_int_TermCriteria)

--- Incoming ---
[   'cv.grabCut',
    'void',
    [],
    [   ['InputArray', 'img', '', []],
        ['InputOutputArray', 'mask', '', []],
        ['Rect', 'rect', '', []],
        ['InputOutputArray', 'bgdModel', '', []],
        ['InputOutputArray', 'fgdModel', '', []],
        ['int', 'iterCount', '', []],
        ['int', 'mode', 'GC_EVAL', []]],
    None,
    '@brief Runs the GrabCut algorithm.\n'
    '\n'
    'The function implements the [GrabCut image segmentation '
    'algorithm](http://en.wikipedia.org/wiki/GrabCut).\n'
    '\n'
    '@param img Input 8-bit 3-channel image.\n'
    '@param mask Input/output 8-bit single-channel mask. The mask is '
    'initialized by the function when\n'
    'mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the '
    '#GrabCutClasses.\n'
    '@param rect ROI containing a segmented object. The pixels outside of the '
    'ROI are marked as\n'
    '"obvious background". The parameter is only used when '
    'mode==#GC_INIT_WITH_RECT .\n'
    '@param bgdModel Temporary array for the background model. Do not modify '
    'it while you are\n'
    'processing the same image.\n'
    '@param fgdModel Temporary arrays for the foreground model. Do not modify '
    'it while you are\n'
    'processing the same image.\n'
    '@param iterCount Number of iterations the algorithm should make before '
    'returning the result. Note\n'
    'that the result can be refined with further calls with '
    'mode==#GC_INIT_WITH_MASK or\n'
    'mode==GC_EVAL .\n'
    '@param mode Operation mode that could be one of the #GrabCutModes']
parse_name: cv.grabCut with ['cv'] -> fullname:cv::grabCut namespace:cv classpath: classname: name:grabCut
register (function) grabCut (cv_grabCut__InputArray__InputOutputArray_Rect__InputOutputArray__InputOutputArray_int_int)

--- Incoming ---
[   'cv.distanceTransform',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['OutputArray', 'labels', '', []],
        ['int', 'distanceType', '', []],
        ['int', 'maskSize', '', []],
        ['int', 'labelType', 'DIST_LABEL_CCOMP', []]],
    None,
    '@brief Calculates the distance to the closest zero pixel for each pixel '
    'of the source image.\n'
    '\n'
    'The function cv::distanceTransform calculates the approximate or precise '
    'distance from every binary\n'
    'image pixel to the nearest zero pixel. For zero image pixels, the '
    'distance will obviously be zero.\n'
    '\n'
    'When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the '
    'function runs the\n'
    'algorithm described in @cite Felzenszwalb04 . This algorithm is '
    'parallelized with the TBB library.\n'
    '\n'
    'In other cases, the algorithm @cite Borgefors86 is used. This means that '
    'for a pixel the function\n'
    'finds the shortest path to the nearest zero pixel consisting of basic '
    'shifts: horizontal, vertical,\n'
    "diagonal, or knight's move (the latest is available for a \\f$5\\times "
    '5\\f$ mask). The overall\n'
    'distance is calculated as a sum of these basic distances. Since the '
    'distance function should be\n'
    'symmetric, all of the horizontal and vertical shifts must have the same '
    'cost (denoted as a ), all\n'
    'the diagonal shifts must have the same cost (denoted as `b`), and all '
    "knight's moves must have the\n"
    'same cost (denoted as `c`). For the #DIST_C and #DIST_L1 types, the '
    'distance is calculated\n'
    'precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be '
    'calculated only with a\n'
    'relative error (a \\f$5\\times 5\\f$ mask gives more accurate results). '
    'For `a`,`b`, and `c`, OpenCV\n'
    'uses the values suggested in the original paper:\n'
    '- DIST_L1: `a = 1, b = 2`\n'
    '- DIST_L2:\n'
    '- `3 x 3`: `a=0.955, b=1.3693`\n'
    '- `5 x 5`: `a=1, b=1.4, c=2.1969`\n'
    '- DIST_C: `a = 1, b = 1`\n'
    '\n'
    'Typically, for a fast, coarse distance estimation #DIST_L2, a '
    '\\f$3\\times 3\\f$ mask is used. For a\n'
    'more accurate distance estimation #DIST_L2, a \\f$5\\times 5\\f$ mask or '
    'the precise algorithm is used.\n'
    'Note that both the precise and the approximate algorithms are linear on '
    'the number of pixels.\n'
    '\n'
    'This variant of the function does not only compute the minimum distance '
    'for each pixel \\f$(x, y)\\f$\n'
    'but also identifies the nearest connected component consisting of zero '
    'pixels\n'
    '(labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel '
    '(labelType==#DIST_LABEL_PIXEL). Index of the\n'
    'component/pixel is stored in `labels(x, y)`. When '
    'labelType==#DIST_LABEL_CCOMP, the function\n'
    'automatically finds connected components of zero pixels in the input '
    'image and marks them with\n'
    'distinct labels. When labelType==#DIST_LABEL_CCOMP, the function scans '
    'through the input image and\n'
    'marks all the zero pixels with distinct labels.\n'
    '\n'
    'In this mode, the complexity is still linear. That is, the function '
    'provides a very fast way to\n'
    'compute the Voronoi diagram for a binary image. Currently, the second '
    'variant can use only the\n'
    'approximate distance transform algorithm, i.e. '
    'maskSize=#DIST_MASK_PRECISE is not supported\n'
    'yet.\n'
    '\n'
    '@param src 8-bit, single-channel (binary) source image.\n'
    '@param dst Output image with calculated distances. It is a 8-bit or '
    '32-bit floating-point,\n'
    'single-channel image of the same size as src.\n'
    '@param labels Output 2D array of labels (the discrete Voronoi diagram). '
    'It has the type\n'
    'CV_32SC1 and the same size as src.\n'
    '@param distanceType Type of distance, see #DistanceTypes\n'
    '@param maskSize Size of the distance transform mask, see '
    '#DistanceTransformMasks.\n'
    '#DIST_MASK_PRECISE is not supported by this variant. In case of the '
    '#DIST_L1 or #DIST_C distance type,\n'
    'the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the '
    'same result as \\f$5\\times\n'
    '5\\f$ or any larger aperture.\n'
    '@param labelType Type of the label array to build, see '
    '#DistanceTransformLabelTypes.']
parse_name: cv.distanceTransform with ['cv'] -> fullname:cv::distanceTransform namespace:cv classpath: classname: name:distanceTransform
register (function) distanceTransform (cv_distanceTransform__InputArray__OutputArray__OutputArray_int_int_int)

--- Incoming ---
[   'cv.distanceTransform',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'distanceType', '', []],
        ['int', 'maskSize', '', []],
        ['int', 'dstType', 'CV_32F', []]],
    None,
    '@overload\n'
    '@param src 8-bit, single-channel (binary) source image.\n'
    '@param dst Output image with calculated distances. It is a 8-bit or '
    '32-bit floating-point,\n'
    'single-channel image of the same size as src .\n'
    '@param distanceType Type of distance, see #DistanceTypes\n'
    '@param maskSize Size of the distance transform mask, see '
    '#DistanceTransformMasks. In case of the\n'
    '#DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a '
    '\\f$3\\times 3\\f$ mask gives\n'
    'the same result as \\f$5\\times 5\\f$ or any larger aperture.\n'
    '@param dstType Type of output image. It can be CV_8U or CV_32F. Type '
    'CV_8U can be used only for\n'
    'the first variant of the function and distanceType == #DIST_L1.']
parse_name: cv.distanceTransform with ['cv'] -> fullname:cv::distanceTransform namespace:cv classpath: classname: name:distanceTransform
register (function) distanceTransform (cv_distanceTransform__InputArray__OutputArray_int_int_int)

--- Incoming ---
[   'cv.floodFill',
    'int',
    [],
    [   ['InputOutputArray', 'image', '', []],
        ['Point', 'seedPoint', '', []],
        ['Scalar', 'newVal', '', []],
        ['Rect*', 'rect', '0', []],
        ['Scalar', 'loDiff', 'Scalar()', []],
        ['Scalar', 'upDiff', 'Scalar()', []],
        ['int', 'flags', '4', []]],
    None,
    '@overload\n\nvariant without `mask` parameter']
parse_name: cv.floodFill with ['cv'] -> fullname:cv::floodFill namespace:cv classpath: classname: name:floodFill
register (function) floodFill (cv_floodFill__InputOutputArray_Point_Scalar_Rect_X_Scalar_Scalar_int)

--- Incoming ---
[   'cv.floodFill',
    'int',
    [],
    [   ['InputOutputArray', 'image', '', []],
        ['InputOutputArray', 'mask', '', []],
        ['Point', 'seedPoint', '', []],
        ['Scalar', 'newVal', '', []],
        ['Rect*', 'rect', '0', []],
        ['Scalar', 'loDiff', 'Scalar()', []],
        ['Scalar', 'upDiff', 'Scalar()', []],
        ['int', 'flags', '4', []]],
    None,
    '@brief Fills a connected component with the given color.\n'
    '\n'
    'The function cv::floodFill fills a connected component starting from the '
    'seed point with the specified\n'
    'color. The connectivity is determined by the color/brightness closeness '
    'of the neighbor pixels. The\n'
    'pixel at \\f$(x,y)\\f$ is considered to belong to the repainted domain '
    'if:\n'
    '\n'
    '- in case of a grayscale image and floating range\n'
    "\\f[\\texttt{src} (x',y')- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  "
    "\\leq \\texttt{src} (x',y')+ \\texttt{upDiff}\\f]\n"
    '\n'
    '\n'
    '- in case of a grayscale image and fixed range\n'
    '\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)- '
    '\\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} ( '
    '\\texttt{seedPoint} .x, \\texttt{seedPoint} .y)+ \\texttt{upDiff}\\f]\n'
    '\n'
    '\n'
    '- in case of a color image and floating range\n'
    "\\f[\\texttt{src} (x',y')_r- \\texttt{loDiff} _r \\leq \\texttt{src} "
    "(x,y)_r \\leq \\texttt{src} (x',y')_r+ \\texttt{upDiff} _r,\\f]\n"
    "\\f[\\texttt{src} (x',y')_g- \\texttt{loDiff} _g \\leq \\texttt{src} "
    "(x,y)_g \\leq \\texttt{src} (x',y')_g+ \\texttt{upDiff} _g\\f]\n"
    'and\n'
    "\\f[\\texttt{src} (x',y')_b- \\texttt{loDiff} _b \\leq \\texttt{src} "
    "(x,y)_b \\leq \\texttt{src} (x',y')_b+ \\texttt{upDiff} _b\\f]\n"
    '\n'
    '\n'
    '- in case of a color image and fixed range\n'
    '\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r- '
    '\\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} ( '
    '\\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r+ \\texttt{upDiff} '
    '_r,\\f]\n'
    '\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g- '
    '\\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} ( '
    '\\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g+ \\texttt{upDiff} '
    '_g\\f]\n'
    'and\n'
    '\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b- '
    '\\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} ( '
    '\\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b+ \\texttt{upDiff} '
    '_b\\f]\n'
    '\n'
    '\n'
    "where \\f$src(x',y')\\f$ is the value of one of pixel neighbors that is "
    'already known to belong to the\n'
    'component. That is, to be added to the connected component, a '
    'color/brightness of the pixel should\n'
    'be close enough to:\n'
    '- Color/brightness of one of its neighbors that already belong to the '
    'connected component in case\n'
    'of a floating range.\n'
    '- Color/brightness of the seed point in case of a fixed range.\n'
    '\n'
    'Use these functions to either mark a connected component with the '
    'specified color in-place, or build\n'
    'a mask and then extract the contour, or copy the region to another image, '
    'and so on.\n'
    '\n'
    '@param image Input/output 1- or 3-channel, 8-bit, or floating-point '
    'image. It is modified by the\n'
    'function unless the #FLOODFILL_MASK_ONLY flag is set in the second '
    'variant of the function. See\n'
    'the details below.\n'
    '@param mask Operation mask that should be a single-channel 8-bit image, 2 '
    'pixels wider and 2 pixels\n'
    'taller than image. Since this is both an input and output parameter, you '
    'must take responsibility\n'
    'of initializing it. Flood-filling cannot go across non-zero pixels in the '
    'input mask. For example,\n'
    'an edge detector output can be used as a mask to stop filling at edges. '
    'On output, pixels in the\n'
    'mask corresponding to filled pixels in the image are set to 1 or to the a '
    'value specified in flags\n'
    'as described below. Additionally, the function fills the border of the '
    'mask with ones to simplify\n'
    'internal processing. It is therefore possible to use the same mask in '
    'multiple calls to the function\n'
    'to make sure the filled areas do not overlap.\n'
    '@param seedPoint Starting point.\n'
    '@param newVal New value of the repainted domain pixels.\n'
    '@param loDiff Maximal lower brightness/color difference between the '
    'currently observed pixel and\n'
    'one of its neighbors belonging to the component, or a seed pixel being '
    'added to the component.\n'
    '@param upDiff Maximal upper brightness/color difference between the '
    'currently observed pixel and\n'
    'one of its neighbors belonging to the component, or a seed pixel being '
    'added to the component.\n'
    '@param rect Optional output parameter set by the function to the minimum '
    'bounding rectangle of the\n'
    'repainted domain.\n'
    '@param flags Operation flags. The first 8 bits contain a connectivity '
    'value. The default value of\n'
    '4 means that only the four nearest neighbor pixels (those that share an '
    'edge) are considered. A\n'
    'connectivity value of 8 means that the eight nearest neighbor pixels '
    '(those that share a corner)\n'
    'will be considered. The next 8 bits (8-16) contain a value between 1 and '
    '255 with which to fill\n'
    'the mask (the default value is 1). For example, 4 | ( 255 \\<\\< 8 ) will '
    'consider 4 nearest\n'
    'neighbours and fill the mask with a value of 255. The following '
    'additional options occupy higher\n'
    'bits and therefore may be further combined with the connectivity and mask '
    'fill values using\n'
    'bit-wise or (|), see #FloodFillFlags.\n'
    '\n'
    '@note Since the mask is larger than the filled image, a pixel \\f$(x, '
    'y)\\f$ in image corresponds to the\n'
    'pixel \\f$(x+1, y+1)\\f$ in the mask .\n'
    '\n'
    '@sa findContours']
parse_name: cv.floodFill with ['cv'] -> fullname:cv::floodFill namespace:cv classpath: classname: name:floodFill
register (function) floodFill (cv_floodFill__InputOutputArray__InputOutputArray_Point_Scalar_Rect_X_Scalar_Scalar_int)

--- Incoming ---
[   'cv.blendLinear',
    'void',
    [],
    [   ['InputArray', 'src1', '', []],
        ['InputArray', 'src2', '', []],
        ['InputArray', 'weights1', '', []],
        ['InputArray', 'weights2', '', []],
        ['OutputArray', 'dst', '', []]],
    None,
    'Performs linear blending of two images:\n'
    '\\f[ \\texttt{dst}(i,j) = \\texttt{weights1}(i,j)*\\texttt{src1}(i,j) + '
    '\\texttt{weights2}(i,j)*\\texttt{src2}(i,j) \\f]\n'
    '@param src1 It has a type of CV_8UC(n) or CV_32FC(n), where n is a '
    'positive integer.\n'
    '@param src2 It has the same type and size as src1.\n'
    '@param weights1 It has a type of CV_32FC1 and the same size with src1.\n'
    '@param weights2 It has a type of CV_32FC1 and the same size with src1.\n'
    '@param dst It is created if it does not have the same size and type with '
    'src1.']
parse_name: cv.blendLinear with ['cv'] -> fullname:cv::blendLinear namespace:cv classpath: classname: name:blendLinear
register (function) blendLinear (cv_blendLinear__InputArray__InputArray__InputArray__InputArray__OutputArray)

--- Incoming ---
[   'cv.cvtColor',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'code', '', []],
        ['int', 'dstCn', '0', []]],
    None,
    '@brief Converts an image from one color space to another.\n'
    '\n'
    'The function converts an input image from one color space to another. In '
    'case of a transformation\n'
    'to-from RGB color space, the order of the channels should be specified '
    'explicitly (RGB or BGR). Note\n'
    'that the default color format in OpenCV is often referred to as RGB but '
    'it is actually BGR (the\n'
    'bytes are reversed). So the first byte in a standard (24-bit) color image '
    'will be an 8-bit Blue\n'
    'component, the second byte will be Green, and the third byte will be Red. '
    'The fourth, fifth, and\n'
    'sixth bytes would then be the second pixel (Blue, then Green, then Red), '
    'and so on.\n'
    '\n'
    'The conventional ranges for R, G, and B channel values are:\n'
    '-   0 to 255 for CV_8U images\n'
    '-   0 to 65535 for CV_16U images\n'
    '-   0 to 1 for CV_32F images\n'
    '\n'
    'In case of linear transformations, the range does not matter. But in case '
    'of a non-linear\n'
    'transformation, an input RGB image should be normalized to the proper '
    'value range to get the correct\n'
    'results, for example, for RGB \\f$\\rightarrow\\f$ L\\*u\\*v\\* '
    'transformation. For example, if you have a\n'
    '32-bit floating-point image directly converted from an 8-bit image '
    'without any scaling, then it will\n'
    'have the 0..255 value range instead of 0..1 assumed by the function. So, '
    'before calling #cvtColor ,\n'
    'you need first to scale the image down:\n'
    '@code\n'
    'img *= 1./255;\n'
    'cvtColor(img, img, COLOR_BGR2Luv);\n'
    '@endcode\n'
    'If you use #cvtColor with 8-bit images, the conversion will have some '
    'information lost. For many\n'
    'applications, this will not be noticeable but it is recommended to use '
    '32-bit images in applications\n'
    'that need the full range of colors or that convert an image before an '
    'operation and then convert\n'
    'back.\n'
    '\n'
    'If conversion adds the alpha channel, its value will set to the maximum '
    'of corresponding channel\n'
    'range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.\n'
    '\n'
    '@param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), '
    'or single-precision\n'
    'floating-point.\n'
    '@param dst output image of the same size and depth as src.\n'
    '@param code color space conversion code (see #ColorConversionCodes).\n'
    '@param dstCn number of channels in the destination image; if the '
    'parameter is 0, the number of the\n'
    'channels is derived automatically from src and code.\n'
    '\n'
    '@see @ref imgproc_color_conversions']
parse_name: cv.cvtColor with ['cv'] -> fullname:cv::cvtColor namespace:cv classpath: classname: name:cvtColor
register (function) cvtColor (cv_cvtColor__InputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.cvtColorTwoPlane',
    'void',
    [],
    [   ['InputArray', 'src1', '', []],
        ['InputArray', 'src2', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'code', '', []]],
    None,
    '@brief Converts an image from one color space to another where the source '
    'image is\n'
    'stored in two planes.\n'
    '\n'
    'This function only supports YUV420 to RGB conversion as of now.\n'
    '\n'
    '@param src1: 8-bit image (#CV_8U) of the Y plane.\n'
    '@param src2: image containing interleaved U/V plane.\n'
    '@param dst: output image.\n'
    '@param code: Specifies the type of conversion. It can take any of the '
    'following values:\n'
    '- #COLOR_YUV2BGR_NV12\n'
    '- #COLOR_YUV2RGB_NV12\n'
    '- #COLOR_YUV2BGRA_NV12\n'
    '- #COLOR_YUV2RGBA_NV12\n'
    '- #COLOR_YUV2BGR_NV21\n'
    '- #COLOR_YUV2RGB_NV21\n'
    '- #COLOR_YUV2BGRA_NV21\n'
    '- #COLOR_YUV2RGBA_NV21']
parse_name: cv.cvtColorTwoPlane with ['cv'] -> fullname:cv::cvtColorTwoPlane namespace:cv classpath: classname: name:cvtColorTwoPlane
register (function) cvtColorTwoPlane (cv_cvtColorTwoPlane__InputArray__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.demosaicing',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'code', '', []],
        ['int', 'dstCn', '0', []]],
    None,
    '@brief main function for all demosaicing processes\n'
    '\n'
    '@param src input image: 8-bit unsigned or 16-bit unsigned.\n'
    '@param dst output image of the same size and depth as src.\n'
    '@param code Color space conversion code (see the description below).\n'
    '@param dstCn number of channels in the destination image; if the '
    'parameter is 0, the number of the\n'
    'channels is derived automatically from src and code.\n'
    '\n'
    'The function can do the following transformations:\n'
    '\n'
    '-   Demosaicing using bilinear interpolation\n'
    '\n'
    '#COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , '
    '#COLOR_BayerGR2BGR\n'
    '\n'
    '#COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , '
    '#COLOR_BayerGR2GRAY\n'
    '\n'
    '-   Demosaicing using Variable Number of Gradients.\n'
    '\n'
    '#COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG '
    ', #COLOR_BayerGR2BGR_VNG\n'
    '\n'
    '-   Edge-Aware Demosaicing.\n'
    '\n'
    '#COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , '
    '#COLOR_BayerGR2BGR_EA\n'
    '\n'
    '-   Demosaicing with alpha channel\n'
    '\n'
    '#COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , '
    '#COLOR_BayerGR2BGRA\n'
    '\n'
    '@sa cvtColor']
parse_name: cv.demosaicing with ['cv'] -> fullname:cv::demosaicing namespace:cv classpath: classname: name:demosaicing
register (function) demosaicing (cv_demosaicing__InputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.moments',
    'Moments',
    [],
    [['InputArray', 'array', '', []], ['bool', 'binaryImage', 'false', []]],
    None,
    '@brief Calculates all of the moments up to the third order of a polygon '
    'or rasterized shape.\n'
    '\n'
    'The function computes moments, up to the 3rd order, of a vector shape or '
    'a rasterized shape. The\n'
    'results are returned in the structure cv::Moments.\n'
    '\n'
    '@param array Raster image (single-channel, 8-bit or floating-point 2D '
    'array) or an array (\n'
    '\\f$1 \\times N\\f$ or \\f$N \\times 1\\f$ ) of 2D points (Point or '
    'Point2f ).\n'
    '@param binaryImage If it is true, all non-zero image pixels are treated '
    "as 1's. The parameter is\n"
    'used for images only.\n'
    '@returns moments.\n'
    '\n'
    '@note Only applicable to contour moments calculations from Python '
    'bindings: Note that the numpy\n'
    'type for the input array should be either np.int32 or np.float32.\n'
    '\n'
    '@sa  contourArea, arcLength']
parse_name: cv.moments with ['cv'] -> fullname:cv::moments namespace:cv classpath: classname: name:moments
Registering an unknown type: Moments
register (function) moments (cv_moments__InputArray_bool)

--- Incoming ---
[   'cv.HuMoments',
    'void',
    [],
    [['const Moments&', 'moments', '', []], ['double[7]', 'hu', '', []]],
    None,
    '@brief Calculates seven Hu invariants.\n'
    '\n'
    'The function calculates seven Hu invariants (introduced in @cite Hu62; '
    'see also\n'
    '<http://en.wikipedia.org/wiki/Image_moment>) defined as:\n'
    '\n'
    '\\f[\\begin{array}{l} hu[0]= \\eta _{20}+ \\eta _{02} \\\\ hu[1]=( \\eta '
    '_{20}- \\eta _{02})^{2}+4 \\eta _{11}^{2} \\\\ hu[2]=( \\eta _{30}-3 '
    '\\eta _{12})^{2}+ (3 \\eta _{21}- \\eta _{03})^{2} \\\\ hu[3]=( \\eta '
    '_{30}+ \\eta _{12})^{2}+ ( \\eta _{21}+ \\eta _{03})^{2} \\\\ hu[4]=( '
    '\\eta _{30}-3 \\eta _{12})( \\eta _{30}+ \\eta _{12})[( \\eta _{30}+ '
    '\\eta _{12})^{2}-3( \\eta _{21}+ \\eta _{03})^{2}]+(3 \\eta _{21}- \\eta '
    '_{03})( \\eta _{21}+ \\eta _{03})[3( \\eta _{30}+ \\eta _{12})^{2}-( '
    '\\eta _{21}+ \\eta _{03})^{2}] \\\\ hu[5]=( \\eta _{20}- \\eta _{02})[( '
    '\\eta _{30}+ \\eta _{12})^{2}- ( \\eta _{21}+ \\eta _{03})^{2}]+4 \\eta '
    '_{11}( \\eta _{30}+ \\eta _{12})( \\eta _{21}+ \\eta _{03}) \\\\ hu[6]=(3 '
    '\\eta _{21}- \\eta _{03})( \\eta _{21}+ \\eta _{03})[3( \\eta _{30}+ '
    '\\eta _{12})^{2}-( \\eta _{21}+ \\eta _{03})^{2}]-( \\eta _{30}-3 \\eta '
    '_{12})( \\eta _{21}+ \\eta _{03})[3( \\eta _{30}+ \\eta _{12})^{2}-( '
    '\\eta _{21}+ \\eta _{03})^{2}] \\\\ \\end{array}\\f]\n'
    '\n'
    'where \\f$\\eta_{ji}\\f$ stands for \\f$\\texttt{Moments::nu}_{ji}\\f$ .\n'
    '\n'
    'These values are proved to be invariants to the image scale, rotation, '
    'and reflection except the\n'
    'seventh one, whose sign is changed by reflection. This invariance is '
    'proved with the assumption of\n'
    'infinite image resolution. In case of raster images, the computed Hu '
    'invariants for the original and\n'
    'transformed images are a bit different.\n'
    '\n'
    '@param moments Input moments computed with moments .\n'
    '@param hu Output Hu invariants.\n'
    '\n'
    '@sa matchShapes']
parse_name: cv.HuMoments with ['cv'] -> fullname:cv::HuMoments namespace:cv classpath: classname: name:HuMoments
Registering an unknown type: Moments
Registering an unknown type: double[7]
register (function) HuMoments (cv_HuMoments_Moments_double[7])

--- Incoming ---
[   'cv.HuMoments',
    'void',
    [],
    [['const Moments&', 'm', '', []], ['OutputArray', 'hu', '', []]],
    None,
    '@overload']
parse_name: cv.HuMoments with ['cv'] -> fullname:cv::HuMoments namespace:cv classpath: classname: name:HuMoments
register (function) HuMoments (cv_HuMoments_Moments__OutputArray)

--- Incoming ---
[   'enum cv.TemplateMatchModes',
    '',
    [],
    [   [   'const cv.TM_SQDIFF',
            '0',
            [],
            [],
            None,
            "\\f[R(x,y)= \\sum _{x',y'} (T(x',y')-I(x+x',y+y'))^2\\f]\n"],
        [   'const cv.TM_SQDIFF_NORMED',
            '1',
            [],
            [],
            None,
            "\\f[R(x,y)= \\frac{\\sum_{x',y'} "
            "(T(x',y')-I(x+x',y+y'))^2}{\\sqrt{\\sum_{x',y'}T(x',y')^2 \\cdot "
            "\\sum_{x',y'} I(x+x',y+y')^2}}\\f]\n"],
        [   'const cv.TM_CCORR',
            '2',
            [],
            [],
            None,
            "\\f[R(x,y)= \\sum _{x',y'} (T(x',y')  \\cdot I(x+x',y+y'))\\f]\n"],
        [   'const cv.TM_CCORR_NORMED',
            '3',
            [],
            [],
            None,
            "\\f[R(x,y)= \\frac{\\sum_{x',y'} (T(x',y') \\cdot "
            "I(x+x',y+y'))}{\\sqrt{\\sum_{x',y'}T(x',y')^2 \\cdot "
            "\\sum_{x',y'} I(x+x',y+y')^2}}\\f]\n"],
        [   'const cv.TM_CCOEFF',
            '4',
            [],
            [],
            None,
            "\\f[R(x,y)= \\sum _{x',y'} (T'(x',y')  \\cdot "
            "I'(x+x',y+y'))\\f]\n"],
        [   'const cv.TM_CCOEFF_NORMED',
            '5',
            [],
            [],
            None,
            "\\f[R(x,y)= \\frac{ \\sum_{x',y'} (T'(x',y') \\cdot "
            "I'(x+x',y+y')) }{ \\sqrt{\\sum_{x',y'}T'(x',y')^2 \\cdot "
            "\\sum_{x',y'} I'(x+x',y+y')^2} }\\f]\n"]],
    None,
    '@} imgproc_shape\n'
    '@addtogroup imgproc_object\n'
    '@{\n'
    'type of the template matching operation']
parse_name: const cv.TM_SQDIFF with ['cv'] -> fullname:cv::TM_SQDIFF namespace:cv classpath: classname: name:TM_SQDIFF
parse_name: const cv.TM_SQDIFF_NORMED with ['cv'] -> fullname:cv::TM_SQDIFF_NORMED namespace:cv classpath: classname: name:TM_SQDIFF_NORMED
parse_name: const cv.TM_CCORR with ['cv'] -> fullname:cv::TM_CCORR namespace:cv classpath: classname: name:TM_CCORR
parse_name: const cv.TM_CCORR_NORMED with ['cv'] -> fullname:cv::TM_CCORR_NORMED namespace:cv classpath: classname: name:TM_CCORR_NORMED
parse_name: const cv.TM_CCOEFF with ['cv'] -> fullname:cv::TM_CCOEFF namespace:cv classpath: classname: name:TM_CCOEFF
parse_name: const cv.TM_CCOEFF_NORMED with ['cv'] -> fullname:cv::TM_CCOEFF_NORMED namespace:cv classpath: classname: name:TM_CCOEFF_NORMED
parse_name: enum cv.TemplateMatchModes with ['cv'] -> fullname:cv::TemplateMatchModes namespace:cv classpath: classname: name:TemplateMatchModes
parse_name: const cv.TM_SQDIFF with ['cv'] -> fullname:cv::TM_SQDIFF namespace:cv classpath: classname: name:TM_SQDIFF
parse_name: const cv.TM_SQDIFF_NORMED with ['cv'] -> fullname:cv::TM_SQDIFF_NORMED namespace:cv classpath: classname: name:TM_SQDIFF_NORMED
parse_name: const cv.TM_CCORR with ['cv'] -> fullname:cv::TM_CCORR namespace:cv classpath: classname: name:TM_CCORR
parse_name: const cv.TM_CCORR_NORMED with ['cv'] -> fullname:cv::TM_CCORR_NORMED namespace:cv classpath: classname: name:TM_CCORR_NORMED
parse_name: const cv.TM_CCOEFF with ['cv'] -> fullname:cv::TM_CCOEFF namespace:cv classpath: classname: name:TM_CCOEFF
parse_name: const cv.TM_CCOEFF_NORMED with ['cv'] -> fullname:cv::TM_CCOEFF_NORMED namespace:cv classpath: classname: name:TM_CCOEFF_NORMED

--- Incoming ---
[   'cv.matchTemplate',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['InputArray', 'templ', '', []],
        ['OutputArray', 'result', '', []],
        ['int', 'method', '', []],
        ['InputArray', 'mask', 'noArray()', []]],
    None,
    '@brief Compares a template against overlapped image regions.\n'
    '\n'
    'The function slides through image , compares the overlapped patches of '
    'size \\f$w \\times h\\f$ against\n'
    'templ using the specified method and stores the comparison results in '
    'result . Here are the formulae\n'
    'for the available comparison methods ( \\f$I\\f$ denotes image, \\f$T\\f$ '
    'template, \\f$R\\f$ result ). The summation\n'
    "is done over template and/or the image patch: \\f$x' = 0...w-1, y' = "
    '0...h-1\\f$\n'
    '\n'
    'After the function finishes the comparison, the best matches can be found '
    'as global minimums (when\n'
    '#TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) '
    'using the\n'
    '#minMaxLoc function. In case of a color image, template summation in the '
    'numerator and each sum in\n'
    'the denominator is done over all of the channels and separate mean values '
    'are used for each channel.\n'
    'That is, the function can take a color template and a color image. The '
    'result will still be a\n'
    'single-channel image, which is easier to analyze.\n'
    '\n'
    '@param image Image where the search is running. It must be 8-bit or '
    '32-bit floating-point.\n'
    '@param templ Searched template. It must be not greater than the source '
    'image and have the same\n'
    'data type.\n'
    '@param result Map of comparison results. It must be single-channel 32-bit '
    'floating-point. If image\n'
    'is \\f$W \\times H\\f$ and templ is \\f$w \\times h\\f$ , then result is '
    '\\f$(W-w+1) \\times (H-h+1)\\f$ .\n'
    '@param method Parameter specifying the comparison method, see '
    '#TemplateMatchModes\n'
    '@param mask Mask of searched template. It must have the same datatype and '
    'size with templ. It is\n'
    'not set by default. Currently, only the #TM_SQDIFF and #TM_CCORR_NORMED '
    'methods are supported.']
parse_name: cv.matchTemplate with ['cv'] -> fullname:cv::matchTemplate namespace:cv classpath: classname: name:matchTemplate
register (function) matchTemplate (cv_matchTemplate__InputArray__InputArray__OutputArray_int__InputArray)

--- Incoming ---
[   'cv.connectedComponents',
    'int',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'labels', '', []],
        ['int', 'connectivity', '', []],
        ['int', 'ltype', '', []],
        ['int', 'ccltype', '', []]],
    None,
    '@brief computes the connected components labeled image of boolean image\n'
    '\n'
    'image with 4 or 8 way connectivity - returns N, the total number of '
    'labels [0, N-1] where 0\n'
    'represents the background label. ltype specifies the output label image '
    'type, an important\n'
    'consideration based on the total number of labels or alternatively the '
    'total number of pixels in\n'
    'the source image. ccltype specifies the connected components labeling '
    'algorithm to use, currently\n'
    "Grana (BBDT) and Wu's (SAUF) algorithms are supported, see the "
    '#ConnectedComponentsAlgorithmsTypes\n'
    'for details. Note that SAUF algorithm forces a row major ordering of '
    'labels while BBDT does not.\n'
    "This function uses parallel version of both Grana and Wu's algorithms if "
    'at least one allowed\n'
    'parallel framework is enabled and if the rows of the image are at least '
    'twice the number returned by #getNumberOfCPUs.\n'
    '\n'
    '@param image the 8-bit single-channel image to be labeled\n'
    '@param labels destination labeled image\n'
    '@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n'
    '@param ltype output image label type. Currently CV_32S and CV_16U are '
    'supported.\n'
    '@param ccltype connected components algorithm type (see the '
    '#ConnectedComponentsAlgorithmsTypes).']
parse_name: cv.connectedComponents with ['cv'] -> fullname:cv::connectedComponents namespace:cv classpath: classname: name:connectedComponents
register (function) connectedComponents (cv_connectedComponents__InputArray__OutputArray_int_int_int)

--- Incoming ---
[   'cv.connectedComponents',
    'int',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'labels', '', []],
        ['int', 'connectivity', '8', []],
        ['int', 'ltype', 'CV_32S', []]],
    None,
    '@overload\n'
    '\n'
    '@param image the 8-bit single-channel image to be labeled\n'
    '@param labels destination labeled image\n'
    '@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n'
    '@param ltype output image label type. Currently CV_32S and CV_16U are '
    'supported.']
parse_name: cv.connectedComponents with ['cv'] -> fullname:cv::connectedComponents namespace:cv classpath: classname: name:connectedComponents
register (function) connectedComponents (cv_connectedComponents__InputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.connectedComponentsWithStats',
    'int',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'labels', '', []],
        ['OutputArray', 'stats', '', []],
        ['OutputArray', 'centroids', '', []],
        ['int', 'connectivity', '', []],
        ['int', 'ltype', '', []],
        ['int', 'ccltype', '', []]],
    None,
    '@brief computes the connected components labeled image of boolean image '
    'and also produces a statistics output for each label\n'
    '\n'
    'image with 4 or 8 way connectivity - returns N, the total number of '
    'labels [0, N-1] where 0\n'
    'represents the background label. ltype specifies the output label image '
    'type, an important\n'
    'consideration based on the total number of labels or alternatively the '
    'total number of pixels in\n'
    'the source image. ccltype specifies the connected components labeling '
    'algorithm to use, currently\n'
    "Grana's (BBDT) and Wu's (SAUF) algorithms are supported, see the "
    '#ConnectedComponentsAlgorithmsTypes\n'
    'for details. Note that SAUF algorithm forces a row major ordering of '
    'labels while BBDT does not.\n'
    "This function uses parallel version of both Grana and Wu's algorithms "
    '(statistics included) if at least one allowed\n'
    'parallel framework is enabled and if the rows of the image are at least '
    'twice the number returned by #getNumberOfCPUs.\n'
    '\n'
    '@param image the 8-bit single-channel image to be labeled\n'
    '@param labels destination labeled image\n'
    '@param stats statistics output for each label, including the background '
    'label, see below for\n'
    'available statistics. Statistics are accessed via stats(label, COLUMN) '
    'where COLUMN is one of\n'
    '#ConnectedComponentsTypes. The data type is CV_32S.\n'
    '@param centroids centroid output for each label, including the background '
    'label. Centroids are\n'
    'accessed via centroids(label, 0) for x and centroids(label, 1) for y. The '
    'data type CV_64F.\n'
    '@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n'
    '@param ltype output image label type. Currently CV_32S and CV_16U are '
    'supported.\n'
    '@param ccltype connected components algorithm type (see '
    '#ConnectedComponentsAlgorithmsTypes).']
parse_name: cv.connectedComponentsWithStats with ['cv'] -> fullname:cv::connectedComponentsWithStats namespace:cv classpath: classname: name:connectedComponentsWithStats
register (function) connectedComponentsWithStats (cv_connectedComponentsWithStats__InputArray__OutputArray__OutputArray__OutputArray_int_int_int)

--- Incoming ---
[   'cv.connectedComponentsWithStats',
    'int',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArray', 'labels', '', []],
        ['OutputArray', 'stats', '', []],
        ['OutputArray', 'centroids', '', []],
        ['int', 'connectivity', '8', []],
        ['int', 'ltype', 'CV_32S', []]],
    None,
    '@overload\n'
    '@param image the 8-bit single-channel image to be labeled\n'
    '@param labels destination labeled image\n'
    '@param stats statistics output for each label, including the background '
    'label, see below for\n'
    'available statistics. Statistics are accessed via stats(label, COLUMN) '
    'where COLUMN is one of\n'
    '#ConnectedComponentsTypes. The data type is CV_32S.\n'
    '@param centroids centroid output for each label, including the background '
    'label. Centroids are\n'
    'accessed via centroids(label, 0) for x and centroids(label, 1) for y. The '
    'data type CV_64F.\n'
    '@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n'
    '@param ltype output image label type. Currently CV_32S and CV_16U are '
    'supported.']
parse_name: cv.connectedComponentsWithStats with ['cv'] -> fullname:cv::connectedComponentsWithStats namespace:cv classpath: classname: name:connectedComponentsWithStats
register (function) connectedComponentsWithStats (cv_connectedComponentsWithStats__InputArray__OutputArray__OutputArray__OutputArray_int_int)

--- Incoming ---
[   'cv.findContours',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArrayOfArrays', 'contours', '', []],
        ['OutputArray', 'hierarchy', '', []],
        ['int', 'mode', '', []],
        ['int', 'method', '', []],
        ['Point', 'offset', 'Point()', []]],
    None,
    '@brief Finds contours in a binary image.\n'
    '\n'
    'The function retrieves contours from the binary image using the algorithm '
    '@cite Suzuki85 . The contours\n'
    'are a useful tool for shape analysis and object detection and '
    'recognition. See squares.cpp in the\n'
    'OpenCV sample directory.\n'
    '@note Since opencv 3.2 source image is not modified by this function.\n'
    '\n'
    '@param image Source, an 8-bit single-channel image. Non-zero pixels are '
    "treated as 1's. Zero\n"
    "pixels remain 0's, so the image is treated as binary . You can use "
    '#compare, #inRange, #threshold ,\n'
    '#adaptiveThreshold, #Canny, and others to create a binary image out of a '
    'grayscale or color one.\n'
    'If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a '
    '32-bit integer image of labels (CV_32SC1).\n'
    '@param contours Detected contours. Each contour is stored as a vector of '
    'points (e.g.\n'
    'std::vector<std::vector<cv::Point> >).\n'
    '@param hierarchy Optional output vector (e.g. std::vector<cv::Vec4i>), '
    'containing information about the image topology. It has\n'
    'as many elements as the number of contours. For each i-th contour '
    'contours[i], the elements\n'
    'hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] '
    'are set to 0-based indices\n'
    'in contours of the next and previous contours at the same hierarchical '
    'level, the first child\n'
    'contour and the parent contour, respectively. If for the contour i there '
    'are no next, previous,\n'
    'parent, or nested contours, the corresponding elements of hierarchy[i] '
    'will be negative.\n'
    '@param mode Contour retrieval mode, see #RetrievalModes\n'
    '@param method Contour approximation method, see '
    '#ContourApproximationModes\n'
    '@param offset Optional offset by which every contour point is shifted. '
    'This is useful if the\n'
    'contours are extracted from the image ROI and then they should be '
    'analyzed in the whole image\n'
    'context.']
parse_name: cv.findContours with ['cv'] -> fullname:cv::findContours namespace:cv classpath: classname: name:findContours
register (function) findContours (cv_findContours__InputArray__OutputArray__OutputArray_int_int_Point)

--- Incoming ---
[   'cv.findContours',
    'void',
    [],
    [   ['InputArray', 'image', '', []],
        ['OutputArrayOfArrays', 'contours', '', []],
        ['int', 'mode', '', []],
        ['int', 'method', '', []],
        ['Point', 'offset', 'Point()', []]],
    None,
    '@overload']
parse_name: cv.findContours with ['cv'] -> fullname:cv::findContours namespace:cv classpath: classname: name:findContours
register (function) findContours (cv_findContours__InputArray__OutputArray_int_int_Point)

--- Incoming ---
[   'cv.approxPolyDP',
    'void',
    [],
    [   ['InputArray', 'curve', '', []],
        ['OutputArray', 'approxCurve', '', []],
        ['double', 'epsilon', '', []],
        ['bool', 'closed', '', []]],
    None,
    '@brief Approximates a polygonal curve(s) with the specified precision.\n'
    '\n'
    'The function cv::approxPolyDP approximates a curve or a polygon with '
    'another curve/polygon with less\n'
    'vertices so that the distance between them is less or equal to the '
    'specified precision. It uses the\n'
    'Douglas-Peucker algorithm '
    '<http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm>\n'
    '\n'
    '@param curve Input vector of a 2D point stored in std::vector or Mat\n'
    '@param approxCurve Result of the approximation. The type should match the '
    'type of the input curve.\n'
    '@param epsilon Parameter specifying the approximation accuracy. This is '
    'the maximum distance\n'
    'between the original curve and its approximation.\n'
    '@param closed If true, the approximated curve is closed (its first and '
    'last vertices are\n'
    'connected). Otherwise, it is not closed.']
parse_name: cv.approxPolyDP with ['cv'] -> fullname:cv::approxPolyDP namespace:cv classpath: classname: name:approxPolyDP
register (function) approxPolyDP (cv_approxPolyDP__InputArray__OutputArray_double_bool)

--- Incoming ---
[   'cv.arcLength',
    'double',
    [],
    [['InputArray', 'curve', '', []], ['bool', 'closed', '', []]],
    None,
    '@brief Calculates a contour perimeter or a curve length.\n'
    '\n'
    'The function computes a curve length or a closed contour perimeter.\n'
    '\n'
    '@param curve Input vector of 2D points, stored in std::vector or Mat.\n'
    '@param closed Flag indicating whether the curve is closed or not.']
parse_name: cv.arcLength with ['cv'] -> fullname:cv::arcLength namespace:cv classpath: classname: name:arcLength
register (function) arcLength (cv_arcLength__InputArray_bool)

--- Incoming ---
[   'cv.boundingRect',
    'Rect',
    [],
    [['InputArray', 'array', '', []]],
    None,
    '@brief Calculates the up-right bounding rectangle of a point set or '
    'non-zero pixels of gray-scale image.\n'
    '\n'
    'The function calculates and returns the minimal up-right bounding '
    'rectangle for the specified point set or\n'
    'non-zero pixels of gray-scale image.\n'
    '\n'
    '@param array Input gray-scale image or 2D point set, stored in '
    'std::vector or Mat.']
parse_name: cv.boundingRect with ['cv'] -> fullname:cv::boundingRect namespace:cv classpath: classname: name:boundingRect
register (function) boundingRect (cv_boundingRect__InputArray)

--- Incoming ---
[   'cv.contourArea',
    'double',
    [],
    [['InputArray', 'contour', '', []], ['bool', 'oriented', 'false', []]],
    None,
    '@brief Calculates a contour area.\n'
    '\n'
    'The function computes a contour area. Similarly to moments , the area is '
    'computed using the Green\n'
    'formula. Thus, the returned area and the number of non-zero pixels, if '
    'you draw the contour using\n'
    '#drawContours or #fillPoly , can be different. Also, the function will '
    'most certainly give a wrong\n'
    'results for contours with self-intersections.\n'
    '\n'
    'Example:\n'
    '@code\n'
    'vector<Point> contour;\n'
    'contour.push_back(Point2f(0, 0));\n'
    'contour.push_back(Point2f(10, 0));\n'
    'contour.push_back(Point2f(10, 10));\n'
    'contour.push_back(Point2f(5, 4));\n'
    '\n'
    'double area0 = contourArea(contour);\n'
    'vector<Point> approx;\n'
    'approxPolyDP(contour, approx, 5, true);\n'
    'double area1 = contourArea(approx);\n'
    '\n'
    'cout << "area0 =" << area0 << endl <<\n'
    '"area1 =" << area1 << endl <<\n'
    '"approx poly vertices" << approx.size() << endl;\n'
    '@endcode\n'
    '@param contour Input vector of 2D points (contour vertices), stored in '
    'std::vector or Mat.\n'
    '@param oriented Oriented area flag. If it is true, the function returns a '
    'signed area value,\n'
    'depending on the contour orientation (clockwise or counter-clockwise). '
    'Using this feature you can\n'
    'determine orientation of a contour by taking the sign of an area. By '
    'default, the parameter is\n'
    'false, which means that the absolute value is returned.']
parse_name: cv.contourArea with ['cv'] -> fullname:cv::contourArea namespace:cv classpath: classname: name:contourArea
register (function) contourArea (cv_contourArea__InputArray_bool)

--- Incoming ---
[   'cv.minAreaRect',
    'RotatedRect',
    [],
    [['InputArray', 'points', '', []]],
    None,
    '@brief Finds a rotated rectangle of the minimum area enclosing the input '
    '2D point set.\n'
    '\n'
    'The function calculates and returns the minimum-area bounding rectangle '
    '(possibly rotated) for a\n'
    'specified point set. Developer should keep in mind that the returned '
    'RotatedRect can contain negative\n'
    'indices when data is close to the containing Mat element boundary.\n'
    '\n'
    '@param points Input vector of 2D points, stored in std::vector\\<\\> or '
    'Mat']
parse_name: cv.minAreaRect with ['cv'] -> fullname:cv::minAreaRect namespace:cv classpath: classname: name:minAreaRect
register (function) minAreaRect (cv_minAreaRect__InputArray)

--- Incoming ---
[   'cv.boxPoints',
    'void',
    [],
    [['RotatedRect', 'box', '', []], ['OutputArray', 'points', '', []]],
    None,
    '@brief Finds the four vertices of a rotated rect. Useful to draw the '
    'rotated rectangle.\n'
    '\n'
    'The function finds the four vertices of a rotated rectangle. This '
    'function is useful to draw the\n'
    'rectangle. In C++, instead of using this function, you can directly use '
    'RotatedRect::points method. Please\n'
    'visit the @ref tutorial_bounding_rotated_ellipses "tutorial on Creating '
    'Bounding rotated boxes and ellipses for contours" for more information.\n'
    '\n'
    '@param box The input rotated rectangle. It may be the output of\n'
    '@param points The output array of four vertices of rectangles.']
parse_name: cv.boxPoints with ['cv'] -> fullname:cv::boxPoints namespace:cv classpath: classname: name:boxPoints
register (function) boxPoints (cv_boxPoints_RotatedRect__OutputArray)

--- Incoming ---
[   'cv.minEnclosingCircle',
    'void',
    [],
    [   ['InputArray', 'points', '', []],
        ['Point2f&', 'center', '', []],
        ['float&', 'radius', '', []]],
    None,
    '@brief Finds a circle of the minimum area enclosing a 2D point set.\n'
    '\n'
    'The function finds the minimal enclosing circle of a 2D point set using '
    'an iterative algorithm.\n'
    '\n'
    '@param points Input vector of 2D points, stored in std::vector\\<\\> or '
    'Mat\n'
    '@param center Output center of the circle.\n'
    '@param radius Output radius of the circle.']
parse_name: cv.minEnclosingCircle with ['cv'] -> fullname:cv::minEnclosingCircle namespace:cv classpath: classname: name:minEnclosingCircle
register (function) minEnclosingCircle (cv_minEnclosingCircle__InputArray_Point2f_float)

--- Incoming ---
[   'cv.minEnclosingTriangle',
    'double',
    [],
    [['InputArray', 'points', '', []], ['OutputArray', 'triangle', '', []]],
    None,
    '@brief Finds a triangle of minimum area enclosing a 2D point set and '
    'returns its area.\n'
    '\n'
    'The function finds a triangle of minimum area enclosing the given set of '
    '2D points and returns its\n'
    'area. The output for a given 2D point set is shown in the image below. 2D '
    'points are depicted in\n'
    '*red* and the enclosing triangle in *yellow*.\n'
    '\n'
    '![Sample output of the minimum enclosing triangle '
    'function](pics/minenclosingtriangle.png)\n'
    '\n'
    "The implementation of the algorithm is based on O'Rourke's @cite "
    "ORourke86 and Klee and Laskowski's\n"
    "@cite KleeLaskowski85 papers. O'Rourke provides a \\f$\\theta(n)\\f$ "
    'algorithm for finding the minimal\n'
    'enclosing triangle of a 2D convex polygon with n vertices. Since the '
    '#minEnclosingTriangle function\n'
    'takes a 2D point set as input an additional preprocessing step of '
    'computing the convex hull of the\n'
    '2D point set is required. The complexity of the #convexHull function is '
    '\\f$O(n log(n))\\f$ which is higher\n'
    'than \\f$\\theta(n)\\f$. Thus the overall complexity of the function is '
    '\\f$O(n log(n))\\f$.\n'
    '\n'
    '@param points Input vector of 2D points with depth CV_32S or CV_32F, '
    'stored in std::vector\\<\\> or Mat\n'
    '@param triangle Output vector of three 2D points defining the vertices of '
    'the triangle. The depth\n'
    'of the OutputArray must be CV_32F.']
parse_name: cv.minEnclosingTriangle with ['cv'] -> fullname:cv::minEnclosingTriangle namespace:cv classpath: classname: name:minEnclosingTriangle
register (function) minEnclosingTriangle (cv_minEnclosingTriangle__InputArray__OutputArray)

--- Incoming ---
[   'cv.matchShapes',
    'double',
    [],
    [   ['InputArray', 'contour1', '', []],
        ['InputArray', 'contour2', '', []],
        ['int', 'method', '', []],
        ['double', 'parameter', '', []]],
    None,
    '@brief Compares two shapes.\n'
    '\n'
    'The function compares two shapes. All three implemented methods use the '
    'Hu invariants (see #HuMoments)\n'
    '\n'
    '@param contour1 First contour or grayscale image.\n'
    '@param contour2 Second contour or grayscale image.\n'
    '@param method Comparison method, see #ShapeMatchModes\n'
    '@param parameter Method-specific parameter (not supported now).']
parse_name: cv.matchShapes with ['cv'] -> fullname:cv::matchShapes namespace:cv classpath: classname: name:matchShapes
register (function) matchShapes (cv_matchShapes__InputArray__InputArray_int_double)

--- Incoming ---
[   'cv.convexHull',
    'void',
    [],
    [   ['InputArray', 'points', '', []],
        ['OutputArray', 'hull', '', []],
        ['bool', 'clockwise', 'false', []],
        ['bool', 'returnPoints', 'true', []]],
    None,
    '@brief Finds the convex hull of a point set.\n'
    '\n'
    'The function cv::convexHull finds the convex hull of a 2D point set using '
    "the Sklansky's algorithm @cite Sklansky82\n"
    'that has *O(N logN)* complexity in the current implementation.\n'
    '\n'
    '@param points Input 2D point set, stored in std::vector or Mat.\n'
    '@param hull Output convex hull. It is either an integer vector of indices '
    'or vector of points. In\n'
    'the first case, the hull elements are 0-based indices of the convex hull '
    'points in the original\n'
    'array (since the set of convex hull points is a subset of the original '
    'point set). In the second\n'
    'case, hull elements are the convex hull points themselves.\n'
    '@param clockwise Orientation flag. If it is true, the output convex hull '
    'is oriented clockwise.\n'
    'Otherwise, it is oriented counter-clockwise. The assumed coordinate '
    'system has its X axis pointing\n'
    'to the right, and its Y axis pointing upwards.\n'
    '@param returnPoints Operation flag. In case of a matrix, when the flag is '
    'true, the function\n'
    'returns convex hull points. Otherwise, it returns indices of the convex '
    'hull points. When the\n'
    'output array is std::vector, the flag is ignored, and the output depends '
    'on the type of the\n'
    'vector: std::vector\\<int\\> implies returnPoints=false, '
    'std::vector\\<Point\\> implies\n'
    'returnPoints=true.\n'
    '\n'
    '@note `points` and `hull` should be different arrays, inplace processing '
    "isn't supported.\n"
    '\n'
    'Check @ref tutorial_hull "the corresponding tutorial" for more details.\n'
    '\n'
    'useful links:\n'
    '\n'
    'https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/']
parse_name: cv.convexHull with ['cv'] -> fullname:cv::convexHull namespace:cv classpath: classname: name:convexHull
register (function) convexHull (cv_convexHull__InputArray__OutputArray_bool_bool)

--- Incoming ---
[   'cv.convexityDefects',
    'void',
    [],
    [   ['InputArray', 'contour', '', []],
        ['InputArray', 'convexhull', '', []],
        ['OutputArray', 'convexityDefects', '', []]],
    None,
    '@brief Finds the convexity defects of a contour.\n'
    '\n'
    'The figure below displays convexity defects of a hand contour:\n'
    '\n'
    '![image](pics/defects.png)\n'
    '\n'
    '@param contour Input contour.\n'
    '@param convexhull Convex hull obtained using convexHull that should '
    'contain indices of the contour\n'
    'points that make the hull.\n'
    '@param convexityDefects The output vector of convexity defects. In C++ '
    'and the new Python/Java\n'
    'interface each convexity defect is represented as 4-element integer '
    'vector (a.k.a. #Vec4i):\n'
    '(start_index, end_index, farthest_pt_index, fixpt_depth), where indices '
    'are 0-based indices\n'
    'in the original contour of the convexity defect beginning, end and the '
    'farthest point, and\n'
    'fixpt_depth is fixed-point approximation (with 8 fractional bits) of the '
    'distance between the\n'
    'farthest contour point and the hull. That is, to get the floating-point '
    'value of the depth will be\n'
    'fixpt_depth/256.0.']
parse_name: cv.convexityDefects with ['cv'] -> fullname:cv::convexityDefects namespace:cv classpath: classname: name:convexityDefects
register (function) convexityDefects (cv_convexityDefects__InputArray__InputArray__OutputArray)

--- Incoming ---
[   'cv.isContourConvex',
    'bool',
    [],
    [['InputArray', 'contour', '', []]],
    None,
    '@brief Tests a contour convexity.\n'
    '\n'
    'The function tests whether the input contour is convex or not. The '
    'contour must be simple, that is,\n'
    'without self-intersections. Otherwise, the function output is undefined.\n'
    '\n'
    '@param contour Input vector of 2D points, stored in std::vector\\<\\> or '
    'Mat']
parse_name: cv.isContourConvex with ['cv'] -> fullname:cv::isContourConvex namespace:cv classpath: classname: name:isContourConvex
register (function) isContourConvex (cv_isContourConvex__InputArray)

--- Incoming ---
[   'cv.intersectConvexConvex',
    'float',
    [],
    [   ['InputArray', '_p1', '', []],
        ['InputArray', '_p2', '', []],
        ['OutputArray', '_p12', '', []],
        ['bool', 'handleNested', 'true', []]],
    None,
    'finds intersection of two convex polygons']
parse_name: cv.intersectConvexConvex with ['cv'] -> fullname:cv::intersectConvexConvex namespace:cv classpath: classname: name:intersectConvexConvex
register (function) intersectConvexConvex (cv_intersectConvexConvex__InputArray__InputArray__OutputArray_bool)

--- Incoming ---
[   'cv.fitEllipse',
    'RotatedRect',
    [],
    [['InputArray', 'points', '', []]],
    None,
    '@brief Fits an ellipse around a set of 2D points.\n'
    '\n'
    'The function calculates the ellipse that fits (in a least-squares sense) '
    'a set of 2D points best of\n'
    'all. It returns the rotated rectangle in which the ellipse is inscribed. '
    'The first algorithm described by @cite Fitzgibbon95\n'
    'is used. Developer should keep in mind that it is possible that the '
    'returned\n'
    'ellipse/rotatedRect data contains negative indices, due to the data '
    'points being close to the\n'
    'border of the containing Mat element.\n'
    '\n'
    '@param points Input 2D point set, stored in std::vector\\<\\> or Mat']
parse_name: cv.fitEllipse with ['cv'] -> fullname:cv::fitEllipse namespace:cv classpath: classname: name:fitEllipse
register (function) fitEllipse (cv_fitEllipse__InputArray)

--- Incoming ---
[   'cv.fitEllipseAMS',
    'RotatedRect',
    [],
    [['InputArray', 'points', '', []]],
    None,
    '@brief Fits an ellipse around a set of 2D points.\n'
    '\n'
    'The function calculates the ellipse that fits a set of 2D points.\n'
    'It returns the rotated rectangle in which the ellipse is inscribed.\n'
    'The Approximate Mean Square (AMS) proposed by @cite Taubin1991 is used.\n'
    '\n'
    'For an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, '
    '1\\right) \\f$,\n'
    'which is a set of six free coefficients \\f$ '
    'A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} '
    '\\f$.\n'
    'However, to specify an ellipse, all that is needed is five numbers; the '
    'major and minor axes lengths \\f$ (a,b) \\f$,\n'
    'the position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. '
    'This is because the basis set includes lines,\n'
    'quadratics, parabolic and hyperbolic functions as well as elliptical '
    'functions as possible fits.\n'
    'If the fit is found to be a parabolic or hyperbolic function then the '
    'standard #fitEllipse method is used.\n'
    'The AMS method restricts the fit to parabolic, hyperbolic and elliptical '
    'curves\n'
    'by imposing the condition that \\f$ A^T ( D_x^T D_x  +   D_y^T D_y) A = 1 '
    '\\f$ where\n'
    'the matrices \\f$ Dx \\f$ and \\f$ Dy \\f$ are the partial derivatives of '
    'the design matrix \\f$ D \\f$ with\n'
    'respect to x and y. The matrices are formed row by row applying the '
    'following to\n'
    'each of the points in the set:\n'
    '\\f{align*}{\n'
    'D(i,:)&=\\left\\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\\right\\} &\n'
    'D_x(i,:)&=\\left\\{2 x_i,y_i,0,1,0,0\\right\\} &\n'
    'D_y(i,:)&=\\left\\{0,x_i,2 y_i,0,1,0\\right\\}\n'
    '\\f}\n'
    'The AMS method minimizes the cost function\n'
    '\\f{equation*}{\n'
    '\\epsilon ^2=\\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }\n'
    '\\f}\n'
    '\n'
    'The minimum cost is found by solving the generalized eigenvalue problem.\n'
    '\n'
    '\\f{equation*}{\n'
    'D^T D A = \\lambda  \\left( D_x^T D_x +  D_y^T D_y\\right) A\n'
    '\\f}\n'
    '\n'
    '@param points Input 2D point set, stored in std::vector\\<\\> or Mat']
parse_name: cv.fitEllipseAMS with ['cv'] -> fullname:cv::fitEllipseAMS namespace:cv classpath: classname: name:fitEllipseAMS
register (function) fitEllipseAMS (cv_fitEllipseAMS__InputArray)

--- Incoming ---
[   'cv.fitEllipseDirect',
    'RotatedRect',
    [],
    [['InputArray', 'points', '', []]],
    None,
    '@brief Fits an ellipse around a set of 2D points.\n'
    '\n'
    'The function calculates the ellipse that fits a set of 2D points.\n'
    'It returns the rotated rectangle in which the ellipse is inscribed.\n'
    'The Direct least square (Direct) method by @cite Fitzgibbon1999 is used.\n'
    '\n'
    'For an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, '
    '1\\right) \\f$,\n'
    'which is a set of six free coefficients \\f$ '
    'A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} '
    '\\f$.\n'
    'However, to specify an ellipse, all that is needed is five numbers; the '
    'major and minor axes lengths \\f$ (a,b) \\f$,\n'
    'the position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. '
    'This is because the basis set includes lines,\n'
    'quadratics, parabolic and hyperbolic functions as well as elliptical '
    'functions as possible fits.\n'
    'The Direct method confines the fit to ellipses by ensuring that \\f$ 4 '
    'A_{xx} A_{yy}- A_{xy}^2 > 0 \\f$.\n'
    'The condition imposed is that \\f$ 4 A_{xx} A_{yy}- A_{xy}^2=1 \\f$ which '
    'satisfies the inequality\n'
    'and as the coefficients can be arbitrarily scaled is not overly '
    'restrictive.\n'
    '\n'
    '\\f{equation*}{\n'
    '\\epsilon ^2= A^T D^T D A \\quad \\text{with} \\quad A^T C A =1 \\quad '
    '\\text{and} \\quad C=\\left(\\begin{matrix}\n'
    '0 & 0  & 2  & 0  & 0  &  0  \\\\\n'
    '0 & -1  & 0  & 0  & 0  &  0 \\\\\n'
    '2 & 0  & 0  & 0  & 0  &  0 \\\\\n'
    '0 & 0  & 0  & 0  & 0  &  0 \\\\\n'
    '0 & 0  & 0  & 0  & 0  &  0 \\\\\n'
    '0 & 0  & 0  & 0  & 0  &  0\n'
    '\\end{matrix} \\right)\n'
    '\\f}\n'
    '\n'
    'The minimum cost is found by solving the generalized eigenvalue problem.\n'
    '\n'
    '\\f{equation*}{\n'
    'D^T D A = \\lambda  \\left( C\\right) A\n'
    '\\f}\n'
    '\n'
    'The system produces only one positive eigenvalue \\f$ \\lambda\\f$ which '
    'is chosen as the solution\n'
    'with its eigenvector \\f$\\mathbf{u}\\f$. These are used to find the '
    'coefficients\n'
    '\n'
    '\\f{equation*}{\n'
    'A = \\sqrt{\\frac{1}{\\mathbf{u}^T C \\mathbf{u}}}  \\mathbf{u}\n'
    '\\f}\n'
    'The scaling factor guarantees that  \\f$A^T C A =1\\f$.\n'
    '\n'
    '@param points Input 2D point set, stored in std::vector\\<\\> or Mat']
parse_name: cv.fitEllipseDirect with ['cv'] -> fullname:cv::fitEllipseDirect namespace:cv classpath: classname: name:fitEllipseDirect
register (function) fitEllipseDirect (cv_fitEllipseDirect__InputArray)

--- Incoming ---
[   'cv.fitLine',
    'void',
    [],
    [   ['InputArray', 'points', '', []],
        ['OutputArray', 'line', '', []],
        ['int', 'distType', '', []],
        ['double', 'param', '', []],
        ['double', 'reps', '', []],
        ['double', 'aeps', '', []]],
    None,
    '@brief Fits a line to a 2D or 3D point set.\n'
    '\n'
    'The function fitLine fits a line to a 2D or 3D point set by minimizing '
    '\\f$\\sum_i \\rho(r_i)\\f$ where\n'
    '\\f$r_i\\f$ is a distance between the \\f$i^{th}\\f$ point, the line and '
    '\\f$\\rho(r)\\f$ is a distance function, one\n'
    'of the following:\n'
    '-  DIST_L2\n'
    '\\f[\\rho (r) = r^2/2  \\quad \\text{(the simplest and the fastest '
    'least-squares method)}\\f]\n'
    '- DIST_L1\n'
    '\\f[\\rho (r) = r\\f]\n'
    '- DIST_L12\n'
    '\\f[\\rho (r) = 2  \\cdot ( \\sqrt{1 + \\frac{r^2}{2}} - 1)\\f]\n'
    '- DIST_FAIR\n'
    '\\f[\\rho \\left (r \\right ) = C^2  \\cdot \\left (  \\frac{r}{C} -  '
    '\\log{\\left(1 + \\frac{r}{C}\\right)} \\right )  \\quad \\text{where} '
    '\\quad C=1.3998\\f]\n'
    '- DIST_WELSCH\n'
    '\\f[\\rho \\left (r \\right ) =  \\frac{C^2}{2} \\cdot \\left ( 1 -  '
    '\\exp{\\left(-\\left(\\frac{r}{C}\\right)^2\\right)} \\right )  \\quad '
    '\\text{where} \\quad C=2.9846\\f]\n'
    '- DIST_HUBER\n'
    '\\f[\\rho (r) =  \\fork{r^2/2}{if \\(r < C\\)}{C \\cdot '
    '(r-C/2)}{otherwise} \\quad \\text{where} \\quad C=1.345\\f]\n'
    '\n'
    'The algorithm is based on the M-estimator ( '
    '<http://en.wikipedia.org/wiki/M-estimator> ) technique\n'
    'that iteratively fits the line using the weighted least-squares '
    'algorithm. After each iteration the\n'
    'weights \\f$w_i\\f$ are adjusted to be inversely proportional to '
    '\\f$\\rho(r_i)\\f$ .\n'
    '\n'
    '@param points Input vector of 2D or 3D points, stored in '
    'std::vector\\<\\> or Mat.\n'
    '@param line Output line parameters. In case of 2D fitting, it should be a '
    'vector of 4 elements\n'
    '(like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector '
    'collinear to the line and\n'
    '(x0, y0) is a point on the line. In case of 3D fitting, it should be a '
    'vector of 6 elements (like\n'
    'Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized '
    'vector collinear to the line\n'
    'and (x0, y0, z0) is a point on the line.\n'
    '@param distType Distance used by the M-estimator, see #DistanceTypes\n'
    '@param param Numerical parameter ( C ) for some types of distances. If it '
    'is 0, an optimal value\n'
    'is chosen.\n'
    '@param reps Sufficient accuracy for the radius (distance between the '
    'coordinate origin and the line).\n'
    '@param aeps Sufficient accuracy for the angle. 0.01 would be a good '
    'default value for reps and aeps.']
parse_name: cv.fitLine with ['cv'] -> fullname:cv::fitLine namespace:cv classpath: classname: name:fitLine
register (function) fitLine (cv_fitLine__InputArray__OutputArray_int_double_double_double)

--- Incoming ---
[   'cv.pointPolygonTest',
    'double',
    [],
    [   ['InputArray', 'contour', '', []],
        ['Point2f', 'pt', '', []],
        ['bool', 'measureDist', '', []]],
    None,
    '@brief Performs a point-in-contour test.\n'
    '\n'
    'The function determines whether the point is inside a contour, outside, '
    'or lies on an edge (or\n'
    'coincides with a vertex). It returns positive (inside), negative '
    '(outside), or zero (on an edge)\n'
    'value, correspondingly. When measureDist=false , the return value is +1, '
    '-1, and 0, respectively.\n'
    'Otherwise, the return value is a signed distance between the point and '
    'the nearest contour edge.\n'
    '\n'
    'See below a sample output of the function where each image pixel is '
    'tested against the contour:\n'
    '\n'
    '![sample output](pics/pointpolygon.png)\n'
    '\n'
    '@param contour Input contour.\n'
    '@param pt Point tested against the contour.\n'
    '@param measureDist If true, the function estimates the signed distance '
    'from the point to the\n'
    'nearest contour edge. Otherwise, the function only checks if the point is '
    'inside a contour or not.']
parse_name: cv.pointPolygonTest with ['cv'] -> fullname:cv::pointPolygonTest namespace:cv classpath: classname: name:pointPolygonTest
register (function) pointPolygonTest (cv_pointPolygonTest__InputArray_Point2f_bool)

--- Incoming ---
[   'cv.rotatedRectangleIntersection',
    'int',
    [],
    [   ['const RotatedRect&', 'rect1', '', []],
        ['const RotatedRect&', 'rect2', '', []],
        ['OutputArray', 'intersectingRegion', '', []]],
    None,
    '@brief Finds out if there is any intersection between two rotated '
    'rectangles.\n'
    '\n'
    'If there is then the vertices of the intersecting region are returned as '
    'well.\n'
    '\n'
    'Below are some examples of intersection configurations. The hatched '
    'pattern indicates the\n'
    'intersecting region and the red vertices are returned by the function.\n'
    '\n'
    '![intersection examples](pics/intersection.png)\n'
    '\n'
    '@param rect1 First rectangle\n'
    '@param rect2 Second rectangle\n'
    '@param intersectingRegion The output array of the vertices of the '
    'intersecting region. It returns\n'
    'at most 8 vertices. Stored as std::vector\\<cv::Point2f\\> or cv::Mat as '
    'Mx1 of type CV_32FC2.\n'
    '@returns One of #RectanglesIntersectTypes']
parse_name: cv.rotatedRectangleIntersection with ['cv'] -> fullname:cv::rotatedRectangleIntersection namespace:cv classpath: classname: name:rotatedRectangleIntersection
register (function) rotatedRectangleIntersection (cv_rotatedRectangleIntersection_RotatedRect_RotatedRect__OutputArray)

--- Incoming ---
[   'cv.createGeneralizedHoughBallard',
    'Ptr<GeneralizedHoughBallard>',
    [],
    [],
    None,
    '@brief Creates a smart pointer to a cv::GeneralizedHoughBallard class and '
    'initializes it.']
parse_name: cv.createGeneralizedHoughBallard with ['cv'] -> fullname:cv::createGeneralizedHoughBallard namespace:cv classpath: classname: name:createGeneralizedHoughBallard
register (function) createGeneralizedHoughBallard (cv_createGeneralizedHoughBallard)

--- Incoming ---
[   'cv.createGeneralizedHoughGuil',
    'Ptr<GeneralizedHoughGuil>',
    [],
    [],
    None,
    '@brief Creates a smart pointer to a cv::GeneralizedHoughGuil class and '
    'initializes it.']
parse_name: cv.createGeneralizedHoughGuil with ['cv'] -> fullname:cv::createGeneralizedHoughGuil namespace:cv classpath: classname: name:createGeneralizedHoughGuil
register (function) createGeneralizedHoughGuil (cv_createGeneralizedHoughGuil)

--- Incoming ---
[   'enum cv.ColormapTypes',
    '',
    [],
    [   [   'const cv.COLORMAP_AUTUMN',
            '0',
            [],
            [],
            None,
            '![autumn](pics/colormaps/colorscale_autumn.jpg)\n'],
        [   'const cv.COLORMAP_BONE',
            '1',
            [],
            [],
            None,
            '![bone](pics/colormaps/colorscale_bone.jpg)\n'],
        [   'const cv.COLORMAP_JET',
            '2',
            [],
            [],
            None,
            '![jet](pics/colormaps/colorscale_jet.jpg)\n'],
        [   'const cv.COLORMAP_WINTER',
            '3',
            [],
            [],
            None,
            '![winter](pics/colormaps/colorscale_winter.jpg)\n'],
        [   'const cv.COLORMAP_RAINBOW',
            '4',
            [],
            [],
            None,
            '![rainbow](pics/colormaps/colorscale_rainbow.jpg)\n'],
        [   'const cv.COLORMAP_OCEAN',
            '5',
            [],
            [],
            None,
            '![ocean](pics/colormaps/colorscale_ocean.jpg)\n'],
        [   'const cv.COLORMAP_SUMMER',
            '6',
            [],
            [],
            None,
            '![summer](pics/colormaps/colorscale_summer.jpg)\n'],
        [   'const cv.COLORMAP_SPRING',
            '7',
            [],
            [],
            None,
            '![spring](pics/colormaps/colorscale_spring.jpg)\n'],
        [   'const cv.COLORMAP_COOL',
            '8',
            [],
            [],
            None,
            '![cool](pics/colormaps/colorscale_cool.jpg)\n'],
        [   'const cv.COLORMAP_HSV',
            '9',
            [],
            [],
            None,
            '![HSV](pics/colormaps/colorscale_hsv.jpg)\n'],
        [   'const cv.COLORMAP_PINK',
            '10',
            [],
            [],
            None,
            '![pink](pics/colormaps/colorscale_pink.jpg)\n'],
        [   'const cv.COLORMAP_HOT',
            '11',
            [],
            [],
            None,
            '![hot](pics/colormaps/colorscale_hot.jpg)\n'],
        [   'const cv.COLORMAP_PARULA',
            '12',
            [],
            [],
            None,
            '![parula](pics/colormaps/colorscale_parula.jpg)\n'],
        [   'const cv.COLORMAP_MAGMA',
            '13',
            [],
            [],
            None,
            '![magma](pics/colormaps/colorscale_magma.jpg)\n'],
        [   'const cv.COLORMAP_INFERNO',
            '14',
            [],
            [],
            None,
            '![inferno](pics/colormaps/colorscale_inferno.jpg)\n'],
        [   'const cv.COLORMAP_PLASMA',
            '15',
            [],
            [],
            None,
            '![plasma](pics/colormaps/colorscale_plasma.jpg)\n'],
        [   'const cv.COLORMAP_VIRIDIS',
            '16',
            [],
            [],
            None,
            '![viridis](pics/colormaps/colorscale_viridis.jpg)\n'],
        [   'const cv.COLORMAP_CIVIDIS',
            '17',
            [],
            [],
            None,
            '![cividis](pics/colormaps/colorscale_cividis.jpg)\n'],
        [   'const cv.COLORMAP_TWILIGHT',
            '18',
            [],
            [],
            None,
            '![twilight](pics/colormaps/colorscale_twilight.jpg)\n'],
        [   'const cv.COLORMAP_TWILIGHT_SHIFTED',
            '19',
            [],
            [],
            None,
            '![twilight '
            'shifted](pics/colormaps/colorscale_twilight_shifted.jpg)\n']],
    None,
    '@} imgproc_shape\n'
    '@addtogroup imgproc_colormap\n'
    '@{\n'
    'GNU Octave/MATLAB equivalent colormaps']
parse_name: const cv.COLORMAP_AUTUMN with ['cv'] -> fullname:cv::COLORMAP_AUTUMN namespace:cv classpath: classname: name:COLORMAP_AUTUMN
parse_name: const cv.COLORMAP_BONE with ['cv'] -> fullname:cv::COLORMAP_BONE namespace:cv classpath: classname: name:COLORMAP_BONE
parse_name: const cv.COLORMAP_JET with ['cv'] -> fullname:cv::COLORMAP_JET namespace:cv classpath: classname: name:COLORMAP_JET
parse_name: const cv.COLORMAP_WINTER with ['cv'] -> fullname:cv::COLORMAP_WINTER namespace:cv classpath: classname: name:COLORMAP_WINTER
parse_name: const cv.COLORMAP_RAINBOW with ['cv'] -> fullname:cv::COLORMAP_RAINBOW namespace:cv classpath: classname: name:COLORMAP_RAINBOW
parse_name: const cv.COLORMAP_OCEAN with ['cv'] -> fullname:cv::COLORMAP_OCEAN namespace:cv classpath: classname: name:COLORMAP_OCEAN
parse_name: const cv.COLORMAP_SUMMER with ['cv'] -> fullname:cv::COLORMAP_SUMMER namespace:cv classpath: classname: name:COLORMAP_SUMMER
parse_name: const cv.COLORMAP_SPRING with ['cv'] -> fullname:cv::COLORMAP_SPRING namespace:cv classpath: classname: name:COLORMAP_SPRING
parse_name: const cv.COLORMAP_COOL with ['cv'] -> fullname:cv::COLORMAP_COOL namespace:cv classpath: classname: name:COLORMAP_COOL
parse_name: const cv.COLORMAP_HSV with ['cv'] -> fullname:cv::COLORMAP_HSV namespace:cv classpath: classname: name:COLORMAP_HSV
parse_name: const cv.COLORMAP_PINK with ['cv'] -> fullname:cv::COLORMAP_PINK namespace:cv classpath: classname: name:COLORMAP_PINK
parse_name: const cv.COLORMAP_HOT with ['cv'] -> fullname:cv::COLORMAP_HOT namespace:cv classpath: classname: name:COLORMAP_HOT
parse_name: const cv.COLORMAP_PARULA with ['cv'] -> fullname:cv::COLORMAP_PARULA namespace:cv classpath: classname: name:COLORMAP_PARULA
parse_name: const cv.COLORMAP_MAGMA with ['cv'] -> fullname:cv::COLORMAP_MAGMA namespace:cv classpath: classname: name:COLORMAP_MAGMA
parse_name: const cv.COLORMAP_INFERNO with ['cv'] -> fullname:cv::COLORMAP_INFERNO namespace:cv classpath: classname: name:COLORMAP_INFERNO
parse_name: const cv.COLORMAP_PLASMA with ['cv'] -> fullname:cv::COLORMAP_PLASMA namespace:cv classpath: classname: name:COLORMAP_PLASMA
parse_name: const cv.COLORMAP_VIRIDIS with ['cv'] -> fullname:cv::COLORMAP_VIRIDIS namespace:cv classpath: classname: name:COLORMAP_VIRIDIS
parse_name: const cv.COLORMAP_CIVIDIS with ['cv'] -> fullname:cv::COLORMAP_CIVIDIS namespace:cv classpath: classname: name:COLORMAP_CIVIDIS
parse_name: const cv.COLORMAP_TWILIGHT with ['cv'] -> fullname:cv::COLORMAP_TWILIGHT namespace:cv classpath: classname: name:COLORMAP_TWILIGHT
parse_name: const cv.COLORMAP_TWILIGHT_SHIFTED with ['cv'] -> fullname:cv::COLORMAP_TWILIGHT_SHIFTED namespace:cv classpath: classname: name:COLORMAP_TWILIGHT_SHIFTED
parse_name: enum cv.ColormapTypes with ['cv'] -> fullname:cv::ColormapTypes namespace:cv classpath: classname: name:ColormapTypes
parse_name: const cv.COLORMAP_AUTUMN with ['cv'] -> fullname:cv::COLORMAP_AUTUMN namespace:cv classpath: classname: name:COLORMAP_AUTUMN
parse_name: const cv.COLORMAP_BONE with ['cv'] -> fullname:cv::COLORMAP_BONE namespace:cv classpath: classname: name:COLORMAP_BONE
parse_name: const cv.COLORMAP_JET with ['cv'] -> fullname:cv::COLORMAP_JET namespace:cv classpath: classname: name:COLORMAP_JET
parse_name: const cv.COLORMAP_WINTER with ['cv'] -> fullname:cv::COLORMAP_WINTER namespace:cv classpath: classname: name:COLORMAP_WINTER
parse_name: const cv.COLORMAP_RAINBOW with ['cv'] -> fullname:cv::COLORMAP_RAINBOW namespace:cv classpath: classname: name:COLORMAP_RAINBOW
parse_name: const cv.COLORMAP_OCEAN with ['cv'] -> fullname:cv::COLORMAP_OCEAN namespace:cv classpath: classname: name:COLORMAP_OCEAN
parse_name: const cv.COLORMAP_SUMMER with ['cv'] -> fullname:cv::COLORMAP_SUMMER namespace:cv classpath: classname: name:COLORMAP_SUMMER
parse_name: const cv.COLORMAP_SPRING with ['cv'] -> fullname:cv::COLORMAP_SPRING namespace:cv classpath: classname: name:COLORMAP_SPRING
parse_name: const cv.COLORMAP_COOL with ['cv'] -> fullname:cv::COLORMAP_COOL namespace:cv classpath: classname: name:COLORMAP_COOL
parse_name: const cv.COLORMAP_HSV with ['cv'] -> fullname:cv::COLORMAP_HSV namespace:cv classpath: classname: name:COLORMAP_HSV
parse_name: const cv.COLORMAP_PINK with ['cv'] -> fullname:cv::COLORMAP_PINK namespace:cv classpath: classname: name:COLORMAP_PINK
parse_name: const cv.COLORMAP_HOT with ['cv'] -> fullname:cv::COLORMAP_HOT namespace:cv classpath: classname: name:COLORMAP_HOT
parse_name: const cv.COLORMAP_PARULA with ['cv'] -> fullname:cv::COLORMAP_PARULA namespace:cv classpath: classname: name:COLORMAP_PARULA
parse_name: const cv.COLORMAP_MAGMA with ['cv'] -> fullname:cv::COLORMAP_MAGMA namespace:cv classpath: classname: name:COLORMAP_MAGMA
parse_name: const cv.COLORMAP_INFERNO with ['cv'] -> fullname:cv::COLORMAP_INFERNO namespace:cv classpath: classname: name:COLORMAP_INFERNO
parse_name: const cv.COLORMAP_PLASMA with ['cv'] -> fullname:cv::COLORMAP_PLASMA namespace:cv classpath: classname: name:COLORMAP_PLASMA
parse_name: const cv.COLORMAP_VIRIDIS with ['cv'] -> fullname:cv::COLORMAP_VIRIDIS namespace:cv classpath: classname: name:COLORMAP_VIRIDIS
parse_name: const cv.COLORMAP_CIVIDIS with ['cv'] -> fullname:cv::COLORMAP_CIVIDIS namespace:cv classpath: classname: name:COLORMAP_CIVIDIS
parse_name: const cv.COLORMAP_TWILIGHT with ['cv'] -> fullname:cv::COLORMAP_TWILIGHT namespace:cv classpath: classname: name:COLORMAP_TWILIGHT
parse_name: const cv.COLORMAP_TWILIGHT_SHIFTED with ['cv'] -> fullname:cv::COLORMAP_TWILIGHT_SHIFTED namespace:cv classpath: classname: name:COLORMAP_TWILIGHT_SHIFTED

--- Incoming ---
[   'cv.applyColorMap',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['int', 'colormap', '', []]],
    None,
    '@brief Applies a GNU Octave/MATLAB equivalent colormap on a given image.\n'
    '\n'
    '@param src The source image, grayscale or colored of type CV_8UC1 or '
    'CV_8UC3.\n'
    '@param dst The result is the colormapped source image. Note: Mat::create '
    'is called on dst.\n'
    '@param colormap The colormap to apply, see #ColormapTypes']
parse_name: cv.applyColorMap with ['cv'] -> fullname:cv::applyColorMap namespace:cv classpath: classname: name:applyColorMap
register (function) applyColorMap (cv_applyColorMap__InputArray__OutputArray_int)

--- Incoming ---
[   'cv.applyColorMap',
    'void',
    [],
    [   ['InputArray', 'src', '', []],
        ['OutputArray', 'dst', '', []],
        ['InputArray', 'userColor', '', []]],
    None,
    '@brief Applies a user colormap on a given image.\n'
    '\n'
    '@param src The source image, grayscale or colored of type CV_8UC1 or '
    'CV_8UC3.\n'
    '@param dst The result is the colormapped source image. Note: Mat::create '
    'is called on dst.\n'
    '@param userColor The colormap to apply of type CV_8UC1 or CV_8UC3 and '
    'size 256']
parse_name: cv.applyColorMap with ['cv'] -> fullname:cv::applyColorMap namespace:cv classpath: classname: name:applyColorMap
register (function) applyColorMap (cv_applyColorMap__InputArray__OutputArray__InputArray)

--- Incoming ---
[   'cv.line',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['Point', 'pt1', '', []],
        ['Point', 'pt2', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@brief Draws a line segment connecting two points.\n'
    '\n'
    'The function line draws the line segment between pt1 and pt2 points in '
    'the image. The line is\n'
    'clipped by the image boundaries. For non-antialiased lines with integer '
    'coordinates, the 8-connected\n'
    'or 4-connected Bresenham algorithm is used. Thick lines are drawn with '
    'rounding endings. Antialiased\n'
    'lines are drawn using Gaussian filtering.\n'
    '\n'
    '@param img Image.\n'
    '@param pt1 First point of the line segment.\n'
    '@param pt2 Second point of the line segment.\n'
    '@param color Line color.\n'
    '@param thickness Line thickness.\n'
    '@param lineType Type of the line. See #LineTypes.\n'
    '@param shift Number of fractional bits in the point coordinates.']
parse_name: cv.line with ['cv'] -> fullname:cv::line namespace:cv classpath: classname: name:line
register (function) line (cv_line__InputOutputArray_Point_Point_Scalar_int_int_int)

--- Incoming ---
[   'cv.arrowedLine',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['Point', 'pt1', '', []],
        ['Point', 'pt2', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'line_type', '8', []],
        ['int', 'shift', '0', []],
        ['double', 'tipLength', '0.1', []]],
    None,
    '@brief Draws a arrow segment pointing from the first point to the second '
    'one.\n'
    '\n'
    'The function cv::arrowedLine draws an arrow between pt1 and pt2 points in '
    'the image. See also #line.\n'
    '\n'
    '@param img Image.\n'
    '@param pt1 The point the arrow starts from.\n'
    '@param pt2 The point the arrow points to.\n'
    '@param color Line color.\n'
    '@param thickness Line thickness.\n'
    '@param line_type Type of the line. See #LineTypes\n'
    '@param shift Number of fractional bits in the point coordinates.\n'
    '@param tipLength The length of the arrow tip in relation to the arrow '
    'length']
parse_name: cv.arrowedLine with ['cv'] -> fullname:cv::arrowedLine namespace:cv classpath: classname: name:arrowedLine
register (function) arrowedLine (cv_arrowedLine__InputOutputArray_Point_Point_Scalar_int_int_int_double)

--- Incoming ---
[   'cv.rectangle',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['Point', 'pt1', '', []],
        ['Point', 'pt2', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@brief Draws a simple, thick, or filled up-right rectangle.\n'
    '\n'
    'The function cv::rectangle draws a rectangle outline or a filled '
    'rectangle whose two opposite corners\n'
    'are pt1 and pt2.\n'
    '\n'
    '@param img Image.\n'
    '@param pt1 Vertex of the rectangle.\n'
    '@param pt2 Vertex of the rectangle opposite to pt1 .\n'
    '@param color Rectangle color or brightness (grayscale image).\n'
    '@param thickness Thickness of lines that make up the rectangle. Negative '
    'values, like #FILLED,\n'
    'mean that the function has to draw a filled rectangle.\n'
    '@param lineType Type of the line. See #LineTypes\n'
    '@param shift Number of fractional bits in the point coordinates.']
parse_name: cv.rectangle with ['cv'] -> fullname:cv::rectangle namespace:cv classpath: classname: name:rectangle
register (function) rectangle (cv_rectangle__InputOutputArray_Point_Point_Scalar_int_int_int)

--- Incoming ---
[   'cv.rectangle',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['Rect', 'rec', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@overload\n'
    '\n'
    'use `rec` parameter as alternative specification of the drawn rectangle: '
    '`r.tl() and\n'
    'r.br()-Point(1,1)` are opposite corners']
parse_name: cv.rectangle with ['cv'] -> fullname:cv::rectangle namespace:cv classpath: classname: name:rectangle
register (function) rectangle (cv_rectangle__InputOutputArray_Rect_Scalar_int_int_int)

--- Incoming ---
[   'cv.circle',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['Point', 'center', '', []],
        ['int', 'radius', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@brief Draws a circle.\n'
    '\n'
    'The function cv::circle draws a simple or filled circle with a given '
    'center and radius.\n'
    '@param img Image where the circle is drawn.\n'
    '@param center Center of the circle.\n'
    '@param radius Radius of the circle.\n'
    '@param color Circle color.\n'
    '@param thickness Thickness of the circle outline, if positive. Negative '
    'values, like #FILLED,\n'
    'mean that a filled circle is to be drawn.\n'
    '@param lineType Type of the circle boundary. See #LineTypes\n'
    '@param shift Number of fractional bits in the coordinates of the center '
    'and in the radius value.']
parse_name: cv.circle with ['cv'] -> fullname:cv::circle namespace:cv classpath: classname: name:circle
register (function) circle (cv_circle__InputOutputArray_Point_int_Scalar_int_int_int)

--- Incoming ---
[   'cv.ellipse',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['Point', 'center', '', []],
        ['Size', 'axes', '', []],
        ['double', 'angle', '', []],
        ['double', 'startAngle', '', []],
        ['double', 'endAngle', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@brief Draws a simple or thick elliptic arc or fills an ellipse sector.\n'
    '\n'
    'The function cv::ellipse with more parameters draws an ellipse outline, a '
    'filled ellipse, an elliptic\n'
    'arc, or a filled ellipse sector. The drawing code uses general parametric '
    'form.\n'
    'A piecewise-linear curve is used to approximate the elliptic arc\n'
    'boundary. If you need more control of the ellipse rendering, you can '
    'retrieve the curve using\n'
    '#ellipse2Poly and then render it with #polylines or fill it with '
    '#fillPoly. If you use the first\n'
    'variant of the function and want to draw the whole ellipse, not an arc, '
    'pass `startAngle=0` and\n'
    '`endAngle=360`. If `startAngle` is greater than `endAngle`, they are '
    'swapped. The figure below explains\n'
    'the meaning of the parameters to draw the blue arc.\n'
    '\n'
    '![Parameters of Elliptic Arc](pics/ellipse.svg)\n'
    '\n'
    '@param img Image.\n'
    '@param center Center of the ellipse.\n'
    '@param axes Half of the size of the ellipse main axes.\n'
    '@param angle Ellipse rotation angle in degrees.\n'
    '@param startAngle Starting angle of the elliptic arc in degrees.\n'
    '@param endAngle Ending angle of the elliptic arc in degrees.\n'
    '@param color Ellipse color.\n'
    '@param thickness Thickness of the ellipse arc outline, if positive. '
    'Otherwise, this indicates that\n'
    'a filled ellipse sector is to be drawn.\n'
    '@param lineType Type of the ellipse boundary. See #LineTypes\n'
    '@param shift Number of fractional bits in the coordinates of the center '
    'and values of axes.']
parse_name: cv.ellipse with ['cv'] -> fullname:cv::ellipse namespace:cv classpath: classname: name:ellipse
register (function) ellipse (cv_ellipse__InputOutputArray_Point_Size_double_double_double_Scalar_int_int_int)

--- Incoming ---
[   'cv.ellipse',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['const RotatedRect&', 'box', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []]],
    None,
    '@overload\n'
    '@param img Image.\n'
    '@param box Alternative ellipse representation via RotatedRect. This means '
    'that the function draws\n'
    'an ellipse inscribed in the rotated rectangle.\n'
    '@param color Ellipse color.\n'
    '@param thickness Thickness of the ellipse arc outline, if positive. '
    'Otherwise, this indicates that\n'
    'a filled ellipse sector is to be drawn.\n'
    '@param lineType Type of the ellipse boundary. See #LineTypes']
parse_name: cv.ellipse with ['cv'] -> fullname:cv::ellipse namespace:cv classpath: classname: name:ellipse
register (function) ellipse (cv_ellipse__InputOutputArray_RotatedRect_Scalar_int_int)

--- Incoming ---
[   'cv.drawMarker',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['Point', 'position', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'markerType', 'MARKER_CROSS', []],
        ['int', 'markerSize', '20', []],
        ['int', 'thickness', '1', []],
        ['int', 'line_type', '8', []]],
    None,
    '@brief Draws a marker on a predefined position in an image.\n'
    '\n'
    'The function cv::drawMarker draws a marker on a given position in the '
    'image. For the moment several\n'
    'marker types are supported, see #MarkerTypes for more information.\n'
    '\n'
    '@param img Image.\n'
    '@param position The point where the crosshair is positioned.\n'
    '@param color Line color.\n'
    '@param markerType The specific type of marker you want to use, see '
    '#MarkerTypes\n'
    '@param thickness Line thickness.\n'
    '@param line_type Type of the line, See #LineTypes\n'
    '@param markerSize The length of the marker axis [default = 20 pixels]']
parse_name: cv.drawMarker with ['cv'] -> fullname:cv::drawMarker namespace:cv classpath: classname: name:drawMarker
register (function) drawMarker (cv_drawMarker__InputOutputArray_Point_Scalar_int_int_int_int)

--- Incoming ---
[   'cv.fillConvexPoly',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['const Point*', 'pts', '', []],
        ['int', 'npts', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@overload']
parse_name: cv.fillConvexPoly with ['cv'] -> fullname:cv::fillConvexPoly namespace:cv classpath: classname: name:fillConvexPoly
register (function) fillConvexPoly (cv_fillConvexPoly__InputOutputArray_const_Point_X_int_Scalar_int_int)

--- Incoming ---
[   'cv.fillConvexPoly',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['InputArray', 'points', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@brief Fills a convex polygon.\n'
    '\n'
    'The function cv::fillConvexPoly draws a filled convex polygon. This '
    'function is much faster than the\n'
    'function #fillPoly . It can fill not only convex polygons but any '
    'monotonic polygon without\n'
    'self-intersections, that is, a polygon whose contour intersects every '
    'horizontal line (scan line)\n'
    'twice at the most (though, its top-most and/or the bottom edge could be '
    'horizontal).\n'
    '\n'
    '@param img Image.\n'
    '@param points Polygon vertices.\n'
    '@param color Polygon color.\n'
    '@param lineType Type of the polygon boundaries. See #LineTypes\n'
    '@param shift Number of fractional bits in the vertex coordinates.']
parse_name: cv.fillConvexPoly with ['cv'] -> fullname:cv::fillConvexPoly namespace:cv classpath: classname: name:fillConvexPoly
register (function) fillConvexPoly (cv_fillConvexPoly__InputOutputArray__InputArray_Scalar_int_int)

--- Incoming ---
[   'cv.fillPoly',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['const Point**', 'pts', '', []],
        ['const int*', 'npts', '', []],
        ['int', 'ncontours', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []],
        ['Point', 'offset', 'Point()', []]],
    None,
    '@overload']
parse_name: cv.fillPoly with ['cv'] -> fullname:cv::fillPoly namespace:cv classpath: classname: name:fillPoly
register (function) fillPoly (cv_fillPoly__InputOutputArray_Point**_const_int_X_int_Scalar_int_int_Point)

--- Incoming ---
[   'cv.fillPoly',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['InputArrayOfArrays', 'pts', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []],
        ['Point', 'offset', 'Point()', []]],
    None,
    '@brief Fills the area bounded by one or more polygons.\n'
    '\n'
    'The function cv::fillPoly fills an area bounded by several polygonal '
    'contours. The function can fill\n'
    'complex areas, for example, areas with holes, contours with '
    'self-intersections (some of their\n'
    'parts), and so forth.\n'
    '\n'
    '@param img Image.\n'
    '@param pts Array of polygons where each polygon is represented as an '
    'array of points.\n'
    '@param color Polygon color.\n'
    '@param lineType Type of the polygon boundaries. See #LineTypes\n'
    '@param shift Number of fractional bits in the vertex coordinates.\n'
    '@param offset Optional offset of all points of the contours.']
parse_name: cv.fillPoly with ['cv'] -> fullname:cv::fillPoly namespace:cv classpath: classname: name:fillPoly
register (function) fillPoly (cv_fillPoly__InputOutputArray__InputArray_Scalar_int_int_Point)

--- Incoming ---
[   'cv.polylines',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['const Point* const*', 'pts', '', []],
        ['const int*', 'npts', '', []],
        ['int', 'ncontours', '', []],
        ['bool', 'isClosed', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@overload']
parse_name: cv.polylines with ['cv'] -> fullname:cv::polylines namespace:cv classpath: classname: name:polylines
Registering an unknown type: Point* const
register (function) polylines (cv_polylines__InputOutputArray_Point* const*_const_int_X_int_bool_Scalar_int_int_int)

--- Incoming ---
[   'cv.polylines',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['InputArrayOfArrays', 'pts', '', []],
        ['bool', 'isClosed', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    None,
    '@brief Draws several polygonal curves.\n'
    '\n'
    '@param img Image.\n'
    '@param pts Array of polygonal curves.\n'
    '@param isClosed Flag indicating whether the drawn polylines are closed or '
    'not. If they are closed,\n'
    'the function draws a line from the last vertex of each curve to its first '
    'vertex.\n'
    '@param color Polyline color.\n'
    '@param thickness Thickness of the polyline edges.\n'
    '@param lineType Type of the line segments. See #LineTypes\n'
    '@param shift Number of fractional bits in the vertex coordinates.\n'
    '\n'
    'The function cv::polylines draws one or more polygonal curves.']
parse_name: cv.polylines with ['cv'] -> fullname:cv::polylines namespace:cv classpath: classname: name:polylines
register (function) polylines (cv_polylines__InputOutputArray__InputArray_bool_Scalar_int_int_int)

--- Incoming ---
[   'cv.drawContours',
    'void',
    [],
    [   ['InputOutputArray', 'image', '', []],
        ['InputArrayOfArrays', 'contours', '', []],
        ['int', 'contourIdx', '', []],
        ['const Scalar&', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['InputArray', 'hierarchy', 'noArray()', []],
        ['int', 'maxLevel', 'INT_MAX', []],
        ['Point', 'offset', 'Point()', []]],
    None,
    '@brief Draws contours outlines or filled contours.\n'
    '\n'
    'The function draws contour outlines in the image if '
    '\\f$\\texttt{thickness} \\ge 0\\f$ or fills the area\n'
    'bounded by the contours if \\f$\\texttt{thickness}<0\\f$ . The example '
    'below shows how to retrieve\n'
    'connected components from the binary image and label them: :\n'
    '@include snippets/imgproc_drawContours.cpp\n'
    '\n'
    '@param image Destination image.\n'
    '@param contours All the input contours. Each contour is stored as a point '
    'vector.\n'
    '@param contourIdx Parameter indicating a contour to draw. If it is '
    'negative, all the contours are drawn.\n'
    '@param color Color of the contours.\n'
    '@param thickness Thickness of lines the contours are drawn with. If it is '
    'negative (for example,\n'
    'thickness=#FILLED ), the contour interiors are drawn.\n'
    '@param lineType Line connectivity. See #LineTypes\n'
    '@param hierarchy Optional information about hierarchy. It is only needed '
    'if you want to draw only\n'
    'some of the contours (see maxLevel ).\n'
    '@param maxLevel Maximal level for drawn contours. If it is 0, only the '
    'specified contour is drawn.\n'
    'If it is 1, the function draws the contour(s) and all the nested '
    'contours. If it is 2, the function\n'
    'draws the contours, all the nested contours, all the nested-to-nested '
    'contours, and so on. This\n'
    'parameter is only taken into account when there is hierarchy available.\n'
    '@param offset Optional contour shift parameter. Shift all the drawn '
    'contours by the specified\n'
    '\\f$\\texttt{offset}=(dx,dy)\\f$ .\n'
    '@note When thickness=#FILLED, the function is designed to handle '
    'connected components with holes correctly\n'
    'even when no hierarchy date is provided. This is done by analyzing all '
    'the outlines together\n'
    'using even-odd rule. This may give incorrect results if you have a joint '
    'collection of separately retrieved\n'
    'contours. In order to solve this problem, you need to call #drawContours '
    'separately for each sub-group\n'
    'of contours, or iterate over the collection using contourIdx parameter.']
parse_name: cv.drawContours with ['cv'] -> fullname:cv::drawContours namespace:cv classpath: classname: name:drawContours
register (function) drawContours (cv_drawContours__InputOutputArray__InputArray_int_Scalar_int_int__InputArray_int_Point)

--- Incoming ---
[   'cv.clipLine',
    'bool',
    [],
    [   ['Size', 'imgSize', '', []],
        ['Point&', 'pt1', '', []],
        ['Point&', 'pt2', '', []]],
    None,
    '@brief Clips the line against the image rectangle.\n'
    '\n'
    'The function cv::clipLine calculates a part of the line segment that is '
    'entirely within the specified\n'
    'rectangle. it returns false if the line segment is completely outside the '
    'rectangle. Otherwise,\n'
    'it returns true .\n'
    '@param imgSize Image size. The image rectangle is Rect(0, 0, '
    'imgSize.width, imgSize.height) .\n'
    '@param pt1 First line point.\n'
    '@param pt2 Second line point.']
parse_name: cv.clipLine with ['cv'] -> fullname:cv::clipLine namespace:cv classpath: classname: name:clipLine
register (function) clipLine (cv_clipLine_Size_Point_Point)

--- Incoming ---
[   'cv.clipLine',
    'bool',
    [],
    [   ['Size2l', 'imgSize', '', []],
        ['Point2l&', 'pt1', '', []],
        ['Point2l&', 'pt2', '', []]],
    None,
    '@overload\n'
    '@param imgSize Image size. The image rectangle is Rect(0, 0, '
    'imgSize.width, imgSize.height) .\n'
    '@param pt1 First line point.\n'
    '@param pt2 Second line point.']
parse_name: cv.clipLine with ['cv'] -> fullname:cv::clipLine namespace:cv classpath: classname: name:clipLine
register (function) clipLine (cv_clipLine_Size2l_Point2l_Point2l)

--- Incoming ---
[   'cv.clipLine',
    'bool',
    [],
    [   ['Rect', 'imgRect', '', []],
        ['Point&', 'pt1', '', []],
        ['Point&', 'pt2', '', []]],
    None,
    '@overload\n'
    '@param imgRect Image rectangle.\n'
    '@param pt1 First line point.\n'
    '@param pt2 Second line point.']
parse_name: cv.clipLine with ['cv'] -> fullname:cv::clipLine namespace:cv classpath: classname: name:clipLine
register (function) clipLine (cv_clipLine_Rect_Point_Point)

--- Incoming ---
[   'cv.ellipse2Poly',
    'void',
    [],
    [   ['Point', 'center', '', []],
        ['Size', 'axes', '', []],
        ['int', 'angle', '', []],
        ['int', 'arcStart', '', []],
        ['int', 'arcEnd', '', []],
        ['int', 'delta', '', []],
        ['std::vector<Point>&', 'pts', '', []]],
    None,
    '@brief Approximates an elliptic arc with a polyline.\n'
    '\n'
    'The function ellipse2Poly computes the vertices of a polyline that '
    'approximates the specified\n'
    'elliptic arc. It is used by #ellipse. If `arcStart` is greater than '
    '`arcEnd`, they are swapped.\n'
    '\n'
    '@param center Center of the arc.\n'
    '@param axes Half of the size of the ellipse main axes. See #ellipse for '
    'details.\n'
    '@param angle Rotation angle of the ellipse in degrees. See #ellipse for '
    'details.\n'
    '@param arcStart Starting angle of the elliptic arc in degrees.\n'
    '@param arcEnd Ending angle of the elliptic arc in degrees.\n'
    '@param delta Angle between the subsequent polyline vertices. It defines '
    'the approximation\n'
    'accuracy.\n'
    '@param pts Output vector of polyline vertices.']
parse_name: cv.ellipse2Poly with ['cv'] -> fullname:cv::ellipse2Poly namespace:cv classpath: classname: name:ellipse2Poly
register (function) ellipse2Poly (cv_ellipse2Poly_Point_Size_int_int_int_int_VectorOfPoint)

--- Incoming ---
[   'cv.ellipse2Poly',
    'void',
    [],
    [   ['Point2d', 'center', '', []],
        ['Size2d', 'axes', '', []],
        ['int', 'angle', '', []],
        ['int', 'arcStart', '', []],
        ['int', 'arcEnd', '', []],
        ['int', 'delta', '', []],
        ['std::vector<Point2d>&', 'pts', '', []]],
    None,
    '@overload\n'
    '@param center Center of the arc.\n'
    '@param axes Half of the size of the ellipse main axes. See #ellipse for '
    'details.\n'
    '@param angle Rotation angle of the ellipse in degrees. See #ellipse for '
    'details.\n'
    '@param arcStart Starting angle of the elliptic arc in degrees.\n'
    '@param arcEnd Ending angle of the elliptic arc in degrees.\n'
    '@param delta Angle between the subsequent polyline vertices. It defines '
    'the approximation accuracy.\n'
    '@param pts Output vector of polyline vertices.']
parse_name: cv.ellipse2Poly with ['cv'] -> fullname:cv::ellipse2Poly namespace:cv classpath: classname: name:ellipse2Poly
register (function) ellipse2Poly (cv_ellipse2Poly_Point2d_Size2d_int_int_int_int_VectorOfPoint2d)

--- Incoming ---
[   'cv.putText',
    'void',
    [],
    [   ['InputOutputArray', 'img', '', []],
        ['const String&', 'text', '', []],
        ['Point', 'org', '', []],
        ['int', 'fontFace', '', []],
        ['double', 'fontScale', '', []],
        ['Scalar', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['bool', 'bottomLeftOrigin', 'false', []]],
    None,
    '@brief Draws a text string.\n'
    '\n'
    'The function cv::putText renders the specified text string in the image. '
    'Symbols that cannot be rendered\n'
    'using the specified font are replaced by question marks. See #getTextSize '
    'for a text rendering code\n'
    'example.\n'
    '\n'
    '@param img Image.\n'
    '@param text Text string to be drawn.\n'
    '@param org Bottom-left corner of the text string in the image.\n'
    '@param fontFace Font type, see #HersheyFonts.\n'
    '@param fontScale Font scale factor that is multiplied by the '
    'font-specific base size.\n'
    '@param color Text color.\n'
    '@param thickness Thickness of the lines used to draw a text.\n'
    '@param lineType Line type. See #LineTypes\n'
    '@param bottomLeftOrigin When true, the image data origin is at the '
    'bottom-left corner. Otherwise,\n'
    'it is at the top-left corner.']
parse_name: cv.putText with ['cv'] -> fullname:cv::putText namespace:cv classpath: classname: name:putText
register (function) putText (cv_putText__InputOutputArray_String_Point_int_double_Scalar_int_int_bool)

--- Incoming ---
[   'cv.getTextSize',
    'Size',
    [],
    [   ['const String&', 'text', '', []],
        ['int', 'fontFace', '', []],
        ['double', 'fontScale', '', []],
        ['int', 'thickness', '', []],
        ['int*', 'baseLine', '', []]],
    None,
    '@brief Calculates the width and height of a text string.\n'
    '\n'
    'The function cv::getTextSize calculates and returns the size of a box '
    'that contains the specified text.\n'
    'That is, the following code renders some text, the tight box surrounding '
    'it, and the baseline: :\n'
    '@code\n'
    'String text = "Funny text inside the box";\n'
    'int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;\n'
    'double fontScale = 2;\n'
    'int thickness = 3;\n'
    '\n'
    'Mat img(600, 800, CV_8UC3, Scalar::all(0));\n'
    '\n'
    'int baseline=0;\n'
    'Size textSize = getTextSize(text, fontFace,\n'
    'fontScale, thickness, &baseline);\n'
    'baseline += thickness;\n'
    '\n'
    '// center the text\n'
    'Point textOrg((img.cols - textSize.width)/2,\n'
    '(img.rows + textSize.height)/2);\n'
    '\n'
    '// draw the box\n'
    'rectangle(img, textOrg + Point(0, baseline),\n'
    'textOrg + Point(textSize.width, -textSize.height),\n'
    'Scalar(0,0,255));\n'
    '// ... and the baseline first\n'
    'line(img, textOrg + Point(0, thickness),\n'
    'textOrg + Point(textSize.width, thickness),\n'
    'Scalar(0, 0, 255));\n'
    '\n'
    '// then put the text itself\n'
    'putText(img, text, textOrg, fontFace, fontScale,\n'
    'Scalar::all(255), thickness, 8);\n'
    '@endcode\n'
    '\n'
    '@param text Input text string.\n'
    '@param fontFace Font to use, see #HersheyFonts.\n'
    '@param fontScale Font scale factor that is multiplied by the '
    'font-specific base size.\n'
    '@param thickness Thickness of lines used to render the text. See #putText '
    'for details.\n'
    '@param[out] baseLine y-coordinate of the baseline relative to the '
    'bottom-most text\n'
    'point.\n'
    '@return The size of a box that contains the specified text.\n'
    '\n'
    '@see putText']
parse_name: cv.getTextSize with ['cv'] -> fullname:cv::getTextSize namespace:cv classpath: classname: name:getTextSize
register (function) getTextSize (cv_getTextSize_String_int_double_int_int_X)

--- Incoming ---
[   'cv.getFontScaleFromHeight',
    'double',
    [],
    [   ['const int', 'fontFace', '', []],
        ['const int', 'pixelHeight', '', []],
        ['const int', 'thickness', '1', []]],
    None,
    '@brief Calculates the font-specific size to use to achieve a given height '
    'in pixels.\n'
    '\n'
    '@param fontFace Font to use, see cv::HersheyFonts.\n'
    '@param pixelHeight Pixel height to compute the fontScale for\n'
    '@param thickness Thickness of lines used to render the text.See putText '
    'for details.\n'
    '@return The fontSize to use for cv::putText\n'
    '\n'
    '@see cv::putText']
parse_name: cv.getFontScaleFromHeight with ['cv'] -> fullname:cv::getFontScaleFromHeight namespace:cv classpath: classname: name:getFontScaleFromHeight
register (function) getFontScaleFromHeight (cv_getFontScaleFromHeight_int_int_int)

--- Incoming ---
[   'class cv.LineIterator',
    '',
    [],
    [],
    None,
    '@brief Line iterator\n'
    '\n'
    'The class is used to iterate over all the pixels on the raster line\n'
    'segment connecting two specified points.\n'
    '\n'
    'The class LineIterator is used to get each pixel of a raster line. It\n'
    'can be treated as versatile implementation of the Bresenham algorithm\n'
    'where you can stop at each pixel and do some extra processing, for\n'
    'example, grab pixel values along the line or draw a line with an effect\n'
    '(for example, with XOR operation).\n'
    '\n'
    'The number of pixels along the line is stored in LineIterator::count.\n'
    'The method LineIterator::pos returns the current position in the image:\n'
    '\n'
    '@code{.cpp}\n'
    '// grabs pixels along the line (pt1, pt2)\n'
    '// from 8-bit 3-channel image to the buffer\n'
    'LineIterator it(img, pt1, pt2, 8);\n'
    'LineIterator it2 = it;\n'
    'vector<Vec3b> buf(it.count);\n'
    '\n'
    'for(int i = 0; i < it.count; i++, ++it)\n'
    'buf[i] = *(const Vec3b*)*it;\n'
    '\n'
    '// alternative way of iterating through the line\n'
    'for(int i = 0; i < it2.count; i++, ++it2)\n'
    '{\n'
    'Vec3b val = img.at<Vec3b>(it2.pos());\n'
    'CV_Assert(buf[i] == val);\n'
    '}\n'
    '@endcode']
parse_name: class cv.LineIterator with ['cv'] -> fullname:cv::LineIterator namespace:cv classpath: classname: name:LineIterator
register class cv::LineIterator (['class cv.LineIterator', '', [], [], None, '@brief Line iterator\n\nThe class is used to iterate over all the pixels on the raster line\nsegment connecting two specified points.\n\nThe class LineIterator is used to get each pixel of a raster line. It\ncan be treated as versatile implementation of the Bresenham algorithm\nwhere you can stop at each pixel and do some extra processing, for\nexample, grab pixel values along the line or draw a line with an effect\n(for example, with XOR operation).\n\nThe number of pixels along the line is stored in LineIterator::count.\nThe method LineIterator::pos returns the current position in the image:\n\n@code{.cpp}\n// grabs pixels along the line (pt1, pt2)\n// from 8-bit 3-channel image to the buffer\nLineIterator it(img, pt1, pt2, 8);\nLineIterator it2 = it;\nvector<Vec3b> buf(it.count);\n\nfor(int i = 0; i < it.count; i++, ++it)\nbuf[i] = *(const Vec3b*)*it;\n\n// alternative way of iterating through the line\nfor(int i = 0; i < it2.count; i++, ++it2)\n{\nVec3b val = img.at<Vec3b>(it2.pos());\nCV_Assert(buf[i] == val);\n}\n@endcode'])

--- Incoming ---
[   'cv.LineIterator.LineIterator',
    'L',
    [],
    [   ['const Mat&', 'img', '', []],
        ['Point', 'pt1', '', []],
        ['Point', 'pt2', '', []],
        ['int', 'connectivity', '8', []],
        ['bool', 'leftToRight', 'false', []]],
    None,
    '@brief initializes the iterator\n'
    '\n'
    'creates iterators for the line connecting pt1 and pt2\n'
    'the line will be clipped on the image boundaries\n'
    'the line is 8-connected or 4-connected\n'
    'If leftToRight=true, then the iteration is always done\n'
    'from the left-most point to the right most,\n'
    'not to depend on the ordering of pt1 and pt2 parameters']
parse_name: cv.LineIterator.LineIterator with ['cv'] -> fullname:cv::LineIterator::LineIterator namespace:cv classpath:LineIterator classname:LineIterator name:LineIterator
register (constructor) new in cv::LineIterator (cv_LineIterator_LineIterator_Mat_Point_Point_int_bool)

--- Incoming ---
[   'cv.LineIterator.operator *',
    'uchar* operator *',
    [],
    [],
    None,
    '@brief returns pointer to the current pixel']
parse_name: cv.LineIterator.operator * with ['cv'] -> fullname:cv::LineIterator::operator * namespace:cv classpath:LineIterator classname:LineIterator name:operator *
Registering an unknown type: uchar* operator
ignore (method) operator * in cv::LineIterator

--- Incoming ---
[   'cv.LineIterator.operator ++',
    'LineIterator&',
    [],
    [],
    None,
    '@brief prefix increment operator (++it). shifts iterator to the next '
    'pixel']
parse_name: cv.LineIterator.operator ++ with ['cv'] -> fullname:cv::LineIterator::operator ++ namespace:cv classpath:LineIterator classname:LineIterator name:operator ++
ignore (method) operator ++ in cv::LineIterator

--- Incoming ---
[   'cv.LineIterator.operator ++',
    'LineIterator',
    [],
    [['int', '', '', []]],
    None,
    '@brief postfix increment operator (it++). shifts iterator to the next '
    'pixel']
parse_name: cv.LineIterator.operator ++ with ['cv'] -> fullname:cv::LineIterator::operator ++ namespace:cv classpath:LineIterator classname:LineIterator name:operator ++
ignore (method) operator ++ in cv::LineIterator

--- Incoming ---
[   'cv.LineIterator.pos',
    'Point',
    ['/C'],
    [],
    None,
    '@brief returns coordinates of the current pixel']
parse_name: cv.LineIterator.pos with ['cv'] -> fullname:cv::LineIterator::pos namespace:cv classpath:LineIterator classname:LineIterator name:pos
register (method) pos in cv::LineIterator (cv_LineIterator_pos_const)

--- Incoming ---
[   'cv.LineIterator.operator *',
    'uchar* LineIterator::operator *',
    [],
    [],
    None,
    '@cond IGNORED']
parse_name: cv.LineIterator.operator * with ['cv'] -> fullname:cv::LineIterator::operator * namespace:cv classpath:LineIterator classname:LineIterator name:operator *
Registering an unknown type: uchar* LineIterator::operator
ignore (method) operator * in cv::LineIterator

--- Incoming ---
['cv.LineIterator.operator ++', 'LineIterator&', [], [], None, '']
parse_name: cv.LineIterator.operator ++ with ['cv'] -> fullname:cv::LineIterator::operator ++ namespace:cv classpath:LineIterator classname:LineIterator name:operator ++
ignore (method) operator ++ in cv::LineIterator

--- Incoming ---
[   'cv.LineIterator.operator ++',
    'LineIterator',
    [],
    [['int', '', '', []]],
    None,
    '']
parse_name: cv.LineIterator.operator ++ with ['cv'] -> fullname:cv::LineIterator::operator ++ namespace:cv classpath:LineIterator classname:LineIterator name:operator ++
ignore (method) operator ++ in cv::LineIterator

--- Incoming ---
['cv.LineIterator.pos', 'Point', ['/C'], [], None, '']
parse_name: cv.LineIterator.pos with ['cv'] -> fullname:cv::LineIterator::pos namespace:cv classpath:LineIterator classname:LineIterator name:pos
register (method) pos in cv::LineIterator (cv_LineIterator_pos_const)


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/imgproc/hal/interface.h ================


Namespaces: ['cv']
Comment: {'imgproc': '\n@defgroup imgproc Image Processing\n\nThis module includes image-processing functions.\n\n@{\n@defgroup imgproc_filter Image Filtering\n\nFunctions and classes described in this section are used to perform various linear or non-linear\nfiltering operations on 2D images (represented as Mat\'s). It means that for each pixel location\n\\f$(x,y)\\f$ in the source image (normally, rectangular), its neighborhood is considered and used to\ncompute the response. In case of a linear filter, it is a weighted sum of pixel values. In case of\nmorphological operations, it is the minimum or maximum values, and so on. The computed response is\nstored in the destination image at the same location \\f$(x,y)\\f$. It means that the output image\nwill be of the same size as the input image. Normally, the functions support multi-channel arrays,\nin which case every channel is processed independently. Therefore, the output image will also have\nthe same number of channels as the input one.\n\nAnother common feature of the functions and classes described in this section is that, unlike\nsimple arithmetic functions, they need to extrapolate values of some non-existing pixels. For\nexample, if you want to smooth an image using a Gaussian \\f$3 \\times 3\\f$ filter, then, when\nprocessing the left-most pixels in each row, you need pixels to the left of them, that is, outside\nof the image. You can let these pixels be the same as the left-most image pixels ("replicated\nborder" extrapolation method), or assume that all the non-existing pixels are zeros ("constant\nborder" extrapolation method), and so on. OpenCV enables you to specify the extrapolation method.\nFor details, see #BorderTypes\n\n@anchor filter_depths\n### Depth combinations\nInput depth (src.depth()) | Output depth (ddepth)\n--------------------------|----------------------\nCV_8U                     | -1/CV_16S/CV_32F/CV_64F\nCV_16U/CV_16S             | -1/CV_32F/CV_64F\nCV_32F                    | -1/CV_32F/CV_64F\nCV_64F                    | -1/CV_64F\n\n@note when ddepth=-1, the output image will have the same depth as the source.\n\n@defgroup imgproc_transform Geometric Image Transformations\n\nThe functions in this section perform various geometrical transformations of 2D images. They do not\nchange the image content but deform the pixel grid and map this deformed grid to the destination\nimage. In fact, to avoid sampling artifacts, the mapping is done in the reverse order, from\ndestination to the source. That is, for each pixel \\f$(x, y)\\f$ of the destination image, the\nfunctions compute coordinates of the corresponding "donor" pixel in the source image and copy the\npixel value:\n\n\\f[\\texttt{dst} (x,y)= \\texttt{src} (f_x(x,y), f_y(x,y))\\f]\n\nIn case when you specify the forward mapping \\f$\\left<g_x, g_y\\right>: \\texttt{src} \\rightarrow\n\\texttt{dst}\\f$, the OpenCV functions first compute the corresponding inverse mapping\n\\f$\\left<f_x, f_y\\right>: \\texttt{dst} \\rightarrow \\texttt{src}\\f$ and then use the above formula.\n\nThe actual implementations of the geometrical transformations, from the most generic remap and to\nthe simplest and the fastest resize, need to solve two main problems with the above formula:\n\n- Extrapolation of non-existing pixels. Similarly to the filtering functions described in the\nprevious section, for some \\f$(x,y)\\f$, either one of \\f$f_x(x,y)\\f$, or \\f$f_y(x,y)\\f$, or both\nof them may fall outside of the image. In this case, an extrapolation method needs to be used.\nOpenCV provides the same selection of extrapolation methods as in the filtering functions. In\naddition, it provides the method #BORDER_TRANSPARENT. This means that the corresponding pixels in\nthe destination image will not be modified at all.\n\n- Interpolation of pixel values. Usually \\f$f_x(x,y)\\f$ and \\f$f_y(x,y)\\f$ are floating-point\nnumbers. This means that \\f$\\left<f_x, f_y\\right>\\f$ can be either an affine or perspective\ntransformation, or radial lens distortion correction, and so on. So, a pixel value at fractional\ncoordinates needs to be retrieved. In the simplest case, the coordinates can be just rounded to the\nnearest integer coordinates and the corresponding pixel can be used. This is called a\nnearest-neighbor interpolation. However, a better result can be achieved by using more\nsophisticated [interpolation methods](http://en.wikipedia.org/wiki/Multivariate_interpolation) ,\nwhere a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\nf_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\ninterpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\nresize for details.\n\n@note The geometrical transformations do not work with `CV_8S` or `CV_32S` images.\n\n@defgroup imgproc_misc Miscellaneous Image Transformations\n@defgroup imgproc_draw Drawing Functions\n\nDrawing functions work with matrices/images of arbitrary depth. The boundaries of the shapes can be\nrendered with antialiasing (implemented only for 8-bit images for now). All the functions include\nthe parameter color that uses an RGB value (that may be constructed with the Scalar constructor )\nfor color images and brightness for grayscale images. For color images, the channel ordering is\nnormally *Blue, Green, Red*. This is what imshow, imread, and imwrite expect. So, if you form a\ncolor using the Scalar constructor, it should look like:\n\n\\f[\\texttt{Scalar} (blue \\_ component, green \\_ component, red \\_ component[, alpha \\_ component])\\f]\n\nIf you are using your own image rendering and I/O functions, you can use any channel ordering. The\ndrawing functions process each channel independently and do not depend on the channel order or even\non the used color space. The whole image can be converted from BGR to RGB or to a different color\nspace using cvtColor .\n\nIf a drawn figure is partially or completely outside the image, the drawing functions clip it. Also,\nmany drawing functions can handle pixel coordinates specified with sub-pixel accuracy. This means\nthat the coordinates can be passed as fixed-point numbers encoded as integers. The number of\nfractional bits is specified by the shift parameter and the real point coordinates are calculated as\n\\f$\\texttt{Point}(x,y)\\rightarrow\\texttt{Point2f}(x*2^{-shift},y*2^{-shift})\\f$ . This feature is\nespecially effective when rendering antialiased shapes.\n\n@note The functions do not support alpha-transparency when the target image is 4-channel. In this\ncase, the color[3] is simply copied to the repainted pixels. Thus, if you want to paint\nsemi-transparent shapes, you can paint them in a separate buffer and then blend it with the main\nimage.\n\n@defgroup imgproc_color_conversions Color Space Conversions\n@defgroup imgproc_colormap ColorMaps in OpenCV\n\nThe human perception isn\'t built for observing fine changes in grayscale images. Human eyes are more\nsensitive to observing changes between colors, so you often need to recolor your grayscale images to\nget a clue about them. OpenCV now comes with various colormaps to enhance the visualization in your\ncomputer vision application.\n\nIn OpenCV you only need applyColorMap to apply a colormap on a given image. The following sample\ncode reads the path to an image from command line, applies a Jet colormap on it and shows the\nresult:\n\n@include snippets/imgproc_applyColorMap.cpp\n\n@see #ColormapTypes\n\n@defgroup imgproc_subdiv2d Planar Subdivision\n\nThe Subdiv2D class described in this section is used to perform various planar subdivision on\na set of 2D points (represented as vector of Point2f). OpenCV subdivides a plane into triangles\nusing the Delaunay\'s algorithm, which corresponds to the dual graph of the Voronoi diagram.\nIn the figure below, the Delaunay\'s triangulation is marked with black lines and the Voronoi\ndiagram with red lines.\n\n![Delaunay triangulation (black) and Voronoi (red)](pics/delaunay_voronoi.png)\n\nThe subdivisions can be used for the 3D piece-wise transformation of a plane, morphing, fast\nlocation of points on the plane, building special graphs (such as NNG,RNG), and so forth.\n\n@defgroup imgproc_hist Histograms\n@defgroup imgproc_shape Structural Analysis and Shape Descriptors\n@defgroup imgproc_motion Motion Analysis and Object Tracking\n@defgroup imgproc_feature Feature Detection\n@defgroup imgproc_object Object Detection\n@defgroup imgproc_c C API\n@defgroup imgproc_hal Hardware Acceleration Layer\n@{\n@defgroup imgproc_hal_functions Functions\n@defgroup imgproc_hal_interface Interface\n@}\n@}\n\n'}

--- Incoming ---
[   'const CV_HAL_INTER_NEAREST',
    '0',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n']
parse_name: const CV_HAL_INTER_NEAREST with ['cv'] -> fullname:CV_HAL_INTER_NEAREST namespace: classpath: classname: name:CV_HAL_INTER_NEAREST

--- Incoming ---
[   'const CV_HAL_INTER_LINEAR',
    '1',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n']
parse_name: const CV_HAL_INTER_LINEAR with ['cv'] -> fullname:CV_HAL_INTER_LINEAR namespace: classpath: classname: name:CV_HAL_INTER_LINEAR

--- Incoming ---
[   'const CV_HAL_INTER_CUBIC',
    '2',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n']
parse_name: const CV_HAL_INTER_CUBIC with ['cv'] -> fullname:CV_HAL_INTER_CUBIC namespace: classpath: classname: name:CV_HAL_INTER_CUBIC

--- Incoming ---
[   'const CV_HAL_INTER_AREA',
    '3',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n']
parse_name: const CV_HAL_INTER_AREA with ['cv'] -> fullname:CV_HAL_INTER_AREA namespace: classpath: classname: name:CV_HAL_INTER_AREA

--- Incoming ---
[   'const CV_HAL_INTER_LANCZOS4',
    '4',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n']
parse_name: const CV_HAL_INTER_LANCZOS4 with ['cv'] -> fullname:CV_HAL_INTER_LANCZOS4 namespace: classpath: classname: name:CV_HAL_INTER_LANCZOS4

--- Incoming ---
[   'const CV_HAL_MORPH_ERODE',
    '0',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n']
parse_name: const CV_HAL_MORPH_ERODE with ['cv'] -> fullname:CV_HAL_MORPH_ERODE namespace: classpath: classname: name:CV_HAL_MORPH_ERODE

--- Incoming ---
[   'const CV_HAL_MORPH_DILATE',
    '1',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n']
parse_name: const CV_HAL_MORPH_DILATE with ['cv'] -> fullname:CV_HAL_MORPH_DILATE namespace: classpath: classname: name:CV_HAL_MORPH_DILATE

--- Incoming ---
[   'const CV_HAL_THRESH_BINARY',
    '0',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_BINARY with ['cv'] -> fullname:CV_HAL_THRESH_BINARY namespace: classpath: classname: name:CV_HAL_THRESH_BINARY

--- Incoming ---
[   'const CV_HAL_THRESH_BINARY_INV',
    '1',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_BINARY_INV with ['cv'] -> fullname:CV_HAL_THRESH_BINARY_INV namespace: classpath: classname: name:CV_HAL_THRESH_BINARY_INV

--- Incoming ---
[   'const CV_HAL_THRESH_TRUNC',
    '2',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_TRUNC with ['cv'] -> fullname:CV_HAL_THRESH_TRUNC namespace: classpath: classname: name:CV_HAL_THRESH_TRUNC

--- Incoming ---
[   'const CV_HAL_THRESH_TOZERO',
    '3',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_TOZERO with ['cv'] -> fullname:CV_HAL_THRESH_TOZERO namespace: classpath: classname: name:CV_HAL_THRESH_TOZERO

--- Incoming ---
[   'const CV_HAL_THRESH_TOZERO_INV',
    '4',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_TOZERO_INV with ['cv'] -> fullname:CV_HAL_THRESH_TOZERO_INV namespace: classpath: classname: name:CV_HAL_THRESH_TOZERO_INV

--- Incoming ---
[   'const CV_HAL_THRESH_MASK',
    '7',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_MASK with ['cv'] -> fullname:CV_HAL_THRESH_MASK namespace: classpath: classname: name:CV_HAL_THRESH_MASK

--- Incoming ---
[   'const CV_HAL_THRESH_OTSU',
    '8',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_OTSU with ['cv'] -> fullname:CV_HAL_THRESH_OTSU namespace: classpath: classname: name:CV_HAL_THRESH_OTSU

--- Incoming ---
[   'const CV_HAL_THRESH_TRIANGLE',
    '16',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_THRESH_TRIANGLE with ['cv'] -> fullname:CV_HAL_THRESH_TRIANGLE namespace: classpath: classname: name:CV_HAL_THRESH_TRIANGLE

--- Incoming ---
[   'const CV_HAL_ADAPTIVE_THRESH_MEAN_C',
    '0',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n'
    '@}\n'
    '@name Adaptive threshold algorithm\n'
    '@sa cv::AdaptiveThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_ADAPTIVE_THRESH_MEAN_C with ['cv'] -> fullname:CV_HAL_ADAPTIVE_THRESH_MEAN_C namespace: classpath: classname: name:CV_HAL_ADAPTIVE_THRESH_MEAN_C

--- Incoming ---
[   'const CV_HAL_ADAPTIVE_THRESH_GAUSSIAN_C',
    '1',
    [],
    [],
    '@addtogroup imgproc_hal_interface\n'
    '@{\n'
    '@name Interpolation modes\n'
    '@sa cv::InterpolationFlags\n'
    '@{\n'
    '@}\n'
    '@name Morphology operations\n'
    '@sa cv::MorphTypes\n'
    '@{\n'
    '@}\n'
    '@name Threshold types\n'
    '@sa cv::ThresholdTypes\n'
    '@{\n'
    '@}\n'
    '@name Adaptive threshold algorithm\n'
    '@sa cv::AdaptiveThresholdTypes\n'
    '@{\n']
parse_name: const CV_HAL_ADAPTIVE_THRESH_GAUSSIAN_C with ['cv'] -> fullname:CV_HAL_ADAPTIVE_THRESH_GAUSSIAN_C namespace: classpath: classname: name:CV_HAL_ADAPTIVE_THRESH_GAUSSIAN_C


=============== Header: /Users/ianlum/.cargo/registry/src/github.com-1ecc6299db9ec823/opencv-0.23.0/headers/4.1/opencv2/imgproc/imgproc.hpp ================


Namespaces: ['cv']
Comment: {'imgproc': '\n@defgroup imgproc Image Processing\n\nThis module includes image-processing functions.\n\n@{\n@defgroup imgproc_filter Image Filtering\n\nFunctions and classes described in this section are used to perform various linear or non-linear\nfiltering operations on 2D images (represented as Mat\'s). It means that for each pixel location\n\\f$(x,y)\\f$ in the source image (normally, rectangular), its neighborhood is considered and used to\ncompute the response. In case of a linear filter, it is a weighted sum of pixel values. In case of\nmorphological operations, it is the minimum or maximum values, and so on. The computed response is\nstored in the destination image at the same location \\f$(x,y)\\f$. It means that the output image\nwill be of the same size as the input image. Normally, the functions support multi-channel arrays,\nin which case every channel is processed independently. Therefore, the output image will also have\nthe same number of channels as the input one.\n\nAnother common feature of the functions and classes described in this section is that, unlike\nsimple arithmetic functions, they need to extrapolate values of some non-existing pixels. For\nexample, if you want to smooth an image using a Gaussian \\f$3 \\times 3\\f$ filter, then, when\nprocessing the left-most pixels in each row, you need pixels to the left of them, that is, outside\nof the image. You can let these pixels be the same as the left-most image pixels ("replicated\nborder" extrapolation method), or assume that all the non-existing pixels are zeros ("constant\nborder" extrapolation method), and so on. OpenCV enables you to specify the extrapolation method.\nFor details, see #BorderTypes\n\n@anchor filter_depths\n### Depth combinations\nInput depth (src.depth()) | Output depth (ddepth)\n--------------------------|----------------------\nCV_8U                     | -1/CV_16S/CV_32F/CV_64F\nCV_16U/CV_16S             | -1/CV_32F/CV_64F\nCV_32F                    | -1/CV_32F/CV_64F\nCV_64F                    | -1/CV_64F\n\n@note when ddepth=-1, the output image will have the same depth as the source.\n\n@defgroup imgproc_transform Geometric Image Transformations\n\nThe functions in this section perform various geometrical transformations of 2D images. They do not\nchange the image content but deform the pixel grid and map this deformed grid to the destination\nimage. In fact, to avoid sampling artifacts, the mapping is done in the reverse order, from\ndestination to the source. That is, for each pixel \\f$(x, y)\\f$ of the destination image, the\nfunctions compute coordinates of the corresponding "donor" pixel in the source image and copy the\npixel value:\n\n\\f[\\texttt{dst} (x,y)= \\texttt{src} (f_x(x,y), f_y(x,y))\\f]\n\nIn case when you specify the forward mapping \\f$\\left<g_x, g_y\\right>: \\texttt{src} \\rightarrow\n\\texttt{dst}\\f$, the OpenCV functions first compute the corresponding inverse mapping\n\\f$\\left<f_x, f_y\\right>: \\texttt{dst} \\rightarrow \\texttt{src}\\f$ and then use the above formula.\n\nThe actual implementations of the geometrical transformations, from the most generic remap and to\nthe simplest and the fastest resize, need to solve two main problems with the above formula:\n\n- Extrapolation of non-existing pixels. Similarly to the filtering functions described in the\nprevious section, for some \\f$(x,y)\\f$, either one of \\f$f_x(x,y)\\f$, or \\f$f_y(x,y)\\f$, or both\nof them may fall outside of the image. In this case, an extrapolation method needs to be used.\nOpenCV provides the same selection of extrapolation methods as in the filtering functions. In\naddition, it provides the method #BORDER_TRANSPARENT. This means that the corresponding pixels in\nthe destination image will not be modified at all.\n\n- Interpolation of pixel values. Usually \\f$f_x(x,y)\\f$ and \\f$f_y(x,y)\\f$ are floating-point\nnumbers. This means that \\f$\\left<f_x, f_y\\right>\\f$ can be either an affine or perspective\ntransformation, or radial lens distortion correction, and so on. So, a pixel value at fractional\ncoordinates needs to be retrieved. In the simplest case, the coordinates can be just rounded to the\nnearest integer coordinates and the corresponding pixel can be used. This is called a\nnearest-neighbor interpolation. However, a better result can be achieved by using more\nsophisticated [interpolation methods](http://en.wikipedia.org/wiki/Multivariate_interpolation) ,\nwhere a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\nf_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\ninterpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\nresize for details.\n\n@note The geometrical transformations do not work with `CV_8S` or `CV_32S` images.\n\n@defgroup imgproc_misc Miscellaneous Image Transformations\n@defgroup imgproc_draw Drawing Functions\n\nDrawing functions work with matrices/images of arbitrary depth. The boundaries of the shapes can be\nrendered with antialiasing (implemented only for 8-bit images for now). All the functions include\nthe parameter color that uses an RGB value (that may be constructed with the Scalar constructor )\nfor color images and brightness for grayscale images. For color images, the channel ordering is\nnormally *Blue, Green, Red*. This is what imshow, imread, and imwrite expect. So, if you form a\ncolor using the Scalar constructor, it should look like:\n\n\\f[\\texttt{Scalar} (blue \\_ component, green \\_ component, red \\_ component[, alpha \\_ component])\\f]\n\nIf you are using your own image rendering and I/O functions, you can use any channel ordering. The\ndrawing functions process each channel independently and do not depend on the channel order or even\non the used color space. The whole image can be converted from BGR to RGB or to a different color\nspace using cvtColor .\n\nIf a drawn figure is partially or completely outside the image, the drawing functions clip it. Also,\nmany drawing functions can handle pixel coordinates specified with sub-pixel accuracy. This means\nthat the coordinates can be passed as fixed-point numbers encoded as integers. The number of\nfractional bits is specified by the shift parameter and the real point coordinates are calculated as\n\\f$\\texttt{Point}(x,y)\\rightarrow\\texttt{Point2f}(x*2^{-shift},y*2^{-shift})\\f$ . This feature is\nespecially effective when rendering antialiased shapes.\n\n@note The functions do not support alpha-transparency when the target image is 4-channel. In this\ncase, the color[3] is simply copied to the repainted pixels. Thus, if you want to paint\nsemi-transparent shapes, you can paint them in a separate buffer and then blend it with the main\nimage.\n\n@defgroup imgproc_color_conversions Color Space Conversions\n@defgroup imgproc_colormap ColorMaps in OpenCV\n\nThe human perception isn\'t built for observing fine changes in grayscale images. Human eyes are more\nsensitive to observing changes between colors, so you often need to recolor your grayscale images to\nget a clue about them. OpenCV now comes with various colormaps to enhance the visualization in your\ncomputer vision application.\n\nIn OpenCV you only need applyColorMap to apply a colormap on a given image. The following sample\ncode reads the path to an image from command line, applies a Jet colormap on it and shows the\nresult:\n\n@include snippets/imgproc_applyColorMap.cpp\n\n@see #ColormapTypes\n\n@defgroup imgproc_subdiv2d Planar Subdivision\n\nThe Subdiv2D class described in this section is used to perform various planar subdivision on\na set of 2D points (represented as vector of Point2f). OpenCV subdivides a plane into triangles\nusing the Delaunay\'s algorithm, which corresponds to the dual graph of the Voronoi diagram.\nIn the figure below, the Delaunay\'s triangulation is marked with black lines and the Voronoi\ndiagram with red lines.\n\n![Delaunay triangulation (black) and Voronoi (red)](pics/delaunay_voronoi.png)\n\nThe subdivisions can be used for the 3D piece-wise transformation of a plane, morphing, fast\nlocation of points on the plane, building special graphs (such as NNG,RNG), and so forth.\n\n@defgroup imgproc_hist Histograms\n@defgroup imgproc_shape Structural Analysis and Shape Descriptors\n@defgroup imgproc_motion Motion Analysis and Object Tracking\n@defgroup imgproc_feature Feature Detection\n@defgroup imgproc_object Object Detection\n@defgroup imgproc_c C API\n@defgroup imgproc_hal Hardware Acceleration Layer\n@{\n@defgroup imgproc_hal_functions Functions\n@defgroup imgproc_hal_interface Interface\n@}\n@}\n\n'}


===== Generating... =====
Generating func cv_Canny__InputArray__InputArray__OutputArray_double_double_bool
Generating func cv_Canny__InputArray__OutputArray_double_double_int_bool
Generating func cv_EMD__InputArray__InputArray_int__InputArray_float_X__OutputArray
Generating func cv_GaussianBlur__InputArray__OutputArray_Size_double_double_int
Generating func cv_HoughCircles__InputArray__OutputArray_int_double_double_double_double_int_int
Generating func cv_HoughLinesP__InputArray__OutputArray_double_double_int_double_double
Generating func cv_HoughLinesPointSet__InputArray__OutputArray_int_int_double_double_double_double_double_double
Generating func cv_HoughLines__InputArray__OutputArray_double_double_int_double_double_double_double
Generating func cv_HuMoments_Moments__OutputArray
  ignored: can not map type Unknown[Moments] yet
Generating func cv_HuMoments_Moments_double[7]
  ignored: can not map type Unknown[Moments] yet
Generating func cv_Laplacian__InputArray__OutputArray_int_int_double_double_int
Generating func cv_Scharr__InputArray__OutputArray_int_int_int_double_double_int
Generating func cv_Sobel__InputArray__OutputArray_int_int_int_int_double_double_int
Generating func cv_accumulateProduct__InputArray__InputArray__InputOutputArray__InputArray
Generating func cv_accumulateSquare__InputArray__InputOutputArray__InputArray
Generating func cv_accumulateWeighted__InputArray__InputOutputArray_double__InputArray
Generating func cv_accumulate__InputArray__InputOutputArray__InputArray
Generating func cv_adaptiveThreshold__InputArray__OutputArray_double_int_int_int_double
Generating func cv_applyColorMap__InputArray__OutputArray__InputArray
Generating func cv_applyColorMap__InputArray__OutputArray_int
Generating func cv_approxPolyDP__InputArray__OutputArray_double_bool
Generating func cv_arcLength__InputArray_bool
Generating func cv_arrowedLine__InputOutputArray_Point_Point_Scalar_int_int_int_double
Generating func cv_bilateralFilter__InputArray__OutputArray_int_double_double_int
Generating func cv_blendLinear__InputArray__InputArray__InputArray__InputArray__OutputArray
Generating func cv_blur__InputArray__OutputArray_Size_Point_int
Generating func cv_boundingRect__InputArray
Generating func cv_boxFilter__InputArray__OutputArray_int_Size_Point_bool_int
Generating func cv_boxPoints_RotatedRect__OutputArray
Generating func cv_buildPyramid__InputArray__OutputArray_int_int
Generating func cv_calcBackProject__InputArray_VectorOfint__InputArray__OutputArray_VectorOffloat_double
Generating func cv_calcBackProject_const_Mat_int_const_int_X_SparseMat__OutputArray_float**_double_bool
  ignored: can not map type Unknown[SparseMat] yet
Generating func cv_calcBackProject_const_Mat_int_const_int_X__InputArray__OutputArray_float**_double_bool
  ignored: can not map type RawPtr[RawPtr[Primitive(float)]] yet
Generating func cv_calcHist__InputArray_VectorOfint__InputArray__OutputArray_VectorOfint_VectorOffloat_bool
Generating func cv_calcHist_const_Mat_int_const_int_X__InputArray_SparseMat_int_const_int_X_float**_bool_bool
  ignored: can not map type Unknown[SparseMat] yet
Generating func cv_calcHist_const_Mat_int_const_int_X__InputArray__OutputArray_int_const_int_X_float**_bool_bool
  ignored: can not map type RawPtr[RawPtr[Primitive(float)]] yet
Generating func cv_circle__InputOutputArray_Point_int_Scalar_int_int_int
Generating func cv_clipLine_Rect_Point_Point
Generating func cv_clipLine_Size2l_Point2l_Point2l
Generating func cv_clipLine_Size_Point_Point
Generating func cv_compareHist_SparseMat_SparseMat_int
  ignored: can not map type Unknown[SparseMat] yet
Generating func cv_compareHist__InputArray__InputArray_int
Generating func cv_connectedComponentsWithStats__InputArray__OutputArray__OutputArray__OutputArray_int_int
Generating func cv_connectedComponentsWithStats__InputArray__OutputArray__OutputArray__OutputArray_int_int_int
Generating func cv_connectedComponents__InputArray__OutputArray_int_int
Generating func cv_connectedComponents__InputArray__OutputArray_int_int_int
Generating func cv_contourArea__InputArray_bool
Generating func cv_convertMaps__InputArray__InputArray__OutputArray__OutputArray_int_bool
Generating func cv_convexHull__InputArray__OutputArray_bool_bool
Generating func cv_convexityDefects__InputArray__InputArray__OutputArray
Generating func cv_cornerEigenValsAndVecs__InputArray__OutputArray_int_int_int
Generating func cv_cornerHarris__InputArray__OutputArray_int_int_double_int
Generating func cv_cornerMinEigenVal__InputArray__OutputArray_int_int_int
Generating func cv_cornerSubPix__InputArray__InputOutputArray_Size_Size_TermCriteria
Generating func cv_createCLAHE_double_Size
Generating func cv_createGeneralizedHoughBallard
Generating func cv_createGeneralizedHoughGuil
Generating func cv_createHanningWindow__OutputArray_Size_int
Generating func cv_createLineSegmentDetector_int_double_double_double_double_double_double_int
Generating func cv_cvtColorTwoPlane__InputArray__InputArray__OutputArray_int
Generating func cv_cvtColor__InputArray__OutputArray_int_int
Generating func cv_demosaicing__InputArray__OutputArray_int_int
Generating func cv_dilate__InputArray__OutputArray__InputArray_Point_int_int_Scalar
Generating func cv_distanceTransform__InputArray__OutputArray__OutputArray_int_int_int
Generating func cv_distanceTransform__InputArray__OutputArray_int_int_int
Generating func cv_drawContours__InputOutputArray__InputArray_int_Scalar_int_int__InputArray_int_Point
Generating func cv_drawMarker__InputOutputArray_Point_Scalar_int_int_int_int
Generating func cv_ellipse2Poly_Point2d_Size2d_int_int_int_int_VectorOfPoint2d
Generating func cv_ellipse2Poly_Point_Size_int_int_int_int_VectorOfPoint
Generating func cv_ellipse__InputOutputArray_Point_Size_double_double_double_Scalar_int_int_int
Generating func cv_ellipse__InputOutputArray_RotatedRect_Scalar_int_int
Generating func cv_equalizeHist__InputArray__OutputArray
Generating func cv_erode__InputArray__OutputArray__InputArray_Point_int_int_Scalar
Generating func cv_fillConvexPoly__InputOutputArray__InputArray_Scalar_int_int
Generating func cv_fillConvexPoly__InputOutputArray_const_Point_X_int_Scalar_int_int
  ignored: ignored by rename table
Generating func cv_fillPoly__InputOutputArray_Point**_const_int_X_int_Scalar_int_int_Point
  ignored: can not map type RawPtr[RawPtr[cv::Point (simple)]] yet
Generating func cv_fillPoly__InputOutputArray__InputArray_Scalar_int_int_Point
Generating func cv_filter2D__InputArray__OutputArray_int__InputArray_Point_double_int
Generating func cv_findContours__InputArray__OutputArray__OutputArray_int_int_Point
Generating func cv_findContours__InputArray__OutputArray_int_int_Point
Generating func cv_fitEllipseAMS__InputArray
Generating func cv_fitEllipseDirect__InputArray
Generating func cv_fitEllipse__InputArray
Generating func cv_fitLine__InputArray__OutputArray_int_double_double_double
Generating func cv_floodFill__InputOutputArray_Point_Scalar_Rect_X_Scalar_Scalar_int
Generating func cv_floodFill__InputOutputArray__InputOutputArray_Point_Scalar_Rect_X_Scalar_Scalar_int
Generating func cv_getAffineTransform__InputArray__InputArray
Generating func cv_getAffineTransform_const_Point2f_X_const_Point2f_X
Generating func cv_getDerivKernels__OutputArray__OutputArray_int_int_int_bool_int
Generating func cv_getFontScaleFromHeight_int_int_int
Generating func cv_getGaborKernel_Size_double_double_double_double_double_int
Generating func cv_getGaussianKernel_int_double_int
Generating func cv_getPerspectiveTransform__InputArray__InputArray_int
Generating func cv_getPerspectiveTransform_const_Point2f_X_const_Point2f_X_int
Generating func cv_getRectSubPix__InputArray_Size_Point2f__OutputArray_int
Generating func cv_getRotationMatrix2D_Point2f_double_double
Generating func cv_getStructuringElement_int_Size_Point
Generating func cv_getTextSize_String_int_double_int_int_X
Generating func cv_goodFeaturesToTrack__InputArray__OutputArray_int_double_double__InputArray_int_bool_double
Generating func cv_goodFeaturesToTrack__InputArray__OutputArray_int_double_double__InputArray_int_int_bool_double
Generating func cv_grabCut__InputArray__InputOutputArray_Rect__InputOutputArray__InputOutputArray_int_int
Generating func cv_integral__InputArray__OutputArray__OutputArray__OutputArray_int_int
Generating func cv_integral__InputArray__OutputArray__OutputArray_int_int
Generating func cv_integral__InputArray__OutputArray_int
Generating func cv_intersectConvexConvex__InputArray__InputArray__OutputArray_bool
Generating func cv_invertAffineTransform__InputArray__OutputArray
Generating func cv_isContourConvex__InputArray
Generating func cv_line__InputOutputArray_Point_Point_Scalar_int_int_int
Generating func cv_linearPolar__InputArray__OutputArray_Point2f_double_int
Generating func cv_logPolar__InputArray__OutputArray_Point2f_double_int
Generating func cv_matchShapes__InputArray__InputArray_int_double
Generating func cv_matchTemplate__InputArray__InputArray__OutputArray_int__InputArray
Generating func cv_medianBlur__InputArray__OutputArray_int
Generating func cv_minAreaRect__InputArray
Generating func cv_minEnclosingCircle__InputArray_Point2f_float
Generating func cv_minEnclosingTriangle__InputArray__OutputArray
Generating func cv_moments__InputArray_bool
  ignored: return type class Unknown[Moments] is ignored
Generating func cv_morphologyDefaultBorderValue
Generating func cv_morphologyEx__InputArray__OutputArray_int__InputArray_Point_int_int_Scalar
Generating func cv_phaseCorrelate__InputArray__InputArray__InputArray_double_X
Generating func cv_pointPolygonTest__InputArray_Point2f_bool
Generating func cv_polylines__InputOutputArray_Point* const*_const_int_X_int_bool_Scalar_int_int_int
  ignored: can not map type RawPtr[Unknown[Point* const]] yet
Generating func cv_polylines__InputOutputArray__InputArray_bool_Scalar_int_int_int
Generating func cv_preCornerDetect__InputArray__OutputArray_int_int
Generating func cv_putText__InputOutputArray_String_Point_int_double_Scalar_int_int_bool
Generating func cv_pyrDown__InputArray__OutputArray_Size_int
Generating func cv_pyrMeanShiftFiltering__InputArray__OutputArray_double_double_int_TermCriteria
Generating func cv_pyrUp__InputArray__OutputArray_Size_int
Generating func cv_rectangle__InputOutputArray_Point_Point_Scalar_int_int_int
Generating func cv_rectangle__InputOutputArray_Rect_Scalar_int_int_int
Generating func cv_remap__InputArray__OutputArray__InputArray__InputArray_int_int_Scalar
Generating func cv_resize__InputArray__OutputArray_Size_double_double_int
Generating func cv_rotatedRectangleIntersection_RotatedRect_RotatedRect__OutputArray
Generating func cv_sepFilter2D__InputArray__OutputArray_int__InputArray__InputArray_Point_double_int
Generating func cv_spatialGradient__InputArray__OutputArray__OutputArray_int_int
Generating func cv_sqrBoxFilter__InputArray__OutputArray_int_Size_Point_bool_int
Generating func cv_threshold__InputArray__OutputArray_double_double_int
Generating func cv_warpAffine__InputArray__OutputArray__InputArray_Size_int_int_Scalar
Generating func cv_warpPerspective__InputArray__OutputArray__InputArray_Size_int_int_Scalar
Generating func cv_warpPolar__InputArray__OutputArray_Size_Point2f_double_int
Generating func cv_watershed__InputArray__InputOutputArray
Generating func cv_wrapperEMD__InputArray__InputArray_int__InputArray_PtrOffloat__OutputArray
Ghost class cv::Algorithm (ghost, trait), ignoring
Generating impl for trait cv::CLAHE (trait)
Generating func cv_CLAHE_apply__InputArray__OutputArray
Generating func cv_CLAHE_setClipLimit_double
Generating func cv_CLAHE_getClipLimit_const
Generating func cv_CLAHE_setTilesGridSize_Size
Generating func cv_CLAHE_getTilesGridSize_const
Generating func cv_CLAHE_collectGarbage
Ghost class cv::DMatch (simple, ghost), ignoring
Ghost class cv::DescriptorMatcher (ghost, trait), ignoring
Ghost class cv::Feature2D (ghost, trait), ignoring
Ghost class cv::FileNode (ghost), ignoring
Ghost class cv::FileStorage (ghost), ignoring
Generating impl for trait cv::GeneralizedHough (trait)
Generating func cv_GeneralizedHough_setTemplate__InputArray_Point
Generating func cv_GeneralizedHough_setTemplate__InputArray__InputArray__InputArray_Point
Generating func cv_GeneralizedHough_detect__InputArray__OutputArray__OutputArray
Generating func cv_GeneralizedHough_detect__InputArray__InputArray__InputArray__OutputArray__OutputArray
Generating func cv_GeneralizedHough_setCannyLowThresh_int
Generating func cv_GeneralizedHough_getCannyLowThresh_const
Generating func cv_GeneralizedHough_setCannyHighThresh_int
Generating func cv_GeneralizedHough_getCannyHighThresh_const
Generating func cv_GeneralizedHough_setMinDist_double
Generating func cv_GeneralizedHough_getMinDist_const
Generating func cv_GeneralizedHough_setDp_double
Generating func cv_GeneralizedHough_getDp_const
Generating func cv_GeneralizedHough_setMaxBufferSize_int
Generating func cv_GeneralizedHough_getMaxBufferSize_const
Generating impl for trait cv::GeneralizedHoughBallard (trait)
Generating func cv_GeneralizedHoughBallard_setLevels_int
Generating func cv_GeneralizedHoughBallard_getLevels_const
Generating func cv_GeneralizedHoughBallard_setVotesThreshold_int
Generating func cv_GeneralizedHoughBallard_getVotesThreshold_const
Generating impl for trait cv::GeneralizedHoughGuil (trait)
Generating func cv_GeneralizedHoughGuil_setXi_double
Generating func cv_GeneralizedHoughGuil_getXi_const
Generating func cv_GeneralizedHoughGuil_setLevels_int
Generating func cv_GeneralizedHoughGuil_getLevels_const
Generating func cv_GeneralizedHoughGuil_setAngleEpsilon_double
Generating func cv_GeneralizedHoughGuil_getAngleEpsilon_const
Generating func cv_GeneralizedHoughGuil_setMinAngle_double
Generating func cv_GeneralizedHoughGuil_getMinAngle_const
Generating func cv_GeneralizedHoughGuil_setMaxAngle_double
Generating func cv_GeneralizedHoughGuil_getMaxAngle_const
Generating func cv_GeneralizedHoughGuil_setAngleStep_double
Generating func cv_GeneralizedHoughGuil_getAngleStep_const
Generating func cv_GeneralizedHoughGuil_setAngleThresh_int
Generating func cv_GeneralizedHoughGuil_getAngleThresh_const
Generating func cv_GeneralizedHoughGuil_setMinScale_double
Generating func cv_GeneralizedHoughGuil_getMinScale_const
Generating func cv_GeneralizedHoughGuil_setMaxScale_double
Generating func cv_GeneralizedHoughGuil_getMaxScale_const
Generating func cv_GeneralizedHoughGuil_setScaleStep_double
Generating func cv_GeneralizedHoughGuil_getScaleStep_const
Generating func cv_GeneralizedHoughGuil_setScaleThresh_int
Generating func cv_GeneralizedHoughGuil_getScaleThresh_const
Generating func cv_GeneralizedHoughGuil_setPosThresh_int
Generating func cv_GeneralizedHoughGuil_getPosThresh_const
Ghost class cv::KeyPoint (simple, ghost), ignoring
Generating box for cv::LineIterator
Generating func cv_LineIterator_LineIterator_Mat_Point_Point_int_bool
Generating func cv_LineIterator_pos_const
Generating func cv_LineIterator_pos_const
  ignored: already there
Generating impl for trait cv::LineSegmentDetector (trait)
Generating func cv_LineSegmentDetector_detect__InputArray__OutputArray__OutputArray__OutputArray__OutputArray
Generating func cv_LineSegmentDetector_drawSegments__InputOutputArray__InputArray
Generating func cv_LineSegmentDetector_compareSegments_Size__InputArray__InputArray__InputOutputArray
Ghost class cv::Mat (ghost), ignoring
Ghost class cv::MatExpr (ghost), ignoring
Ghost class cv::Range (ghost), ignoring
Ghost class cv::RotatedRect (ghost), ignoring
Generating box for cv::Subdiv2D
Generating func cv_Subdiv2D_Subdiv2D
Generating func cv_Subdiv2D_Subdiv2D_Rect
Generating func cv_Subdiv2D_initDelaunay_Rect
Generating func cv_Subdiv2D_insert_Point2f
Generating func cv_Subdiv2D_insert_VectorOfPoint2f
Generating func cv_Subdiv2D_locate_Point2f_int_int
Generating func cv_Subdiv2D_findNearest_Point2f_Point2f_X
Generating func cv_Subdiv2D_getEdgeList_const_VectorOfVec4f
Generating func cv_Subdiv2D_getLeadingEdgeList_const_VectorOfint
Generating func cv_Subdiv2D_getTriangleList_const_VectorOfVec6f
Generating func cv_Subdiv2D_getVoronoiFacetList_VectorOfint_VectorOfVectorOfPoint2f_VectorOfPoint2f
Generating func cv_Subdiv2D_getVertex_const_int_int_X
Generating func cv_Subdiv2D_getEdge_const_int_int
Generating func cv_Subdiv2D_nextEdge_const_int
Generating func cv_Subdiv2D_rotateEdge_const_int_int
Generating func cv_Subdiv2D_symEdge_const_int
Generating func cv_Subdiv2D_edgeOrg_const_int_Point2f_X
Generating func cv_Subdiv2D_edgeDst_const_int_Point2f_X
Manual ignore class cv::Subdiv2D::QuadEdge (ignored)
Manual ignore class cv::Subdiv2D::Vertex (ignored)
Ghost class cv::TermCriteria (ghost), ignoring
Ghost class cv::UMat (ghost), ignoring
Ghost class cv::_InputArray (ghost, trait), ignoring
Ghost class cv::_InputOutputArray (ghost, trait), ignoring
Ghost class cv::_OutputArray (ghost, trait), ignoring
Ghost class cv::dnn::Layer (ghost, trait), ignoring
Ghost class cv::dnn::LayerParams (ghost), ignoring
Ghost class cv::utils::logging::LogTag (ghost), ignoring
